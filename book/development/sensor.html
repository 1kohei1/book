<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Sensor Driver - Tock Tutorial</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="../introduction.html">Introduction</a></li><li><a href="../guides.html"><strong aria-hidden="true">1.</strong> Hands-on Guides</a></li><li><ol class="section"><li><a href="../getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li><li><a href="../course.html"><strong aria-hidden="true">1.2.</strong> Tock Course</a></li><li><ol class="section"><li><a href="../course_setup.html"><strong aria-hidden="true">1.2.1.</strong> Course Setup</a></li><li><a href="../modules.html"><strong aria-hidden="true">1.2.2.</strong> Modules</a></li><li><ol class="section"><li><a href="../application.html"><strong aria-hidden="true">1.2.2.1.</strong> Application</a></li><li><a href="../important_client.html"><strong aria-hidden="true">1.2.2.2.</strong> Important Client</a></li><li><a href="../capsule.html"><strong aria-hidden="true">1.2.2.3.</strong> Capsule</a></li></ol></li><li><a href="../graduation.html"><strong aria-hidden="true">1.2.3.</strong> Graduation</a></li></ol></li><li><a href="../tutorials/tutorials.html"><strong aria-hidden="true">1.3.</strong> Mini Tutorials</a></li><li><ol class="section"><li><a href="../tutorials/01_running_blink.html"><strong aria-hidden="true">1.3.1.</strong> Blink an LED</a></li><li><a href="../tutorials/02_button_print.html"><strong aria-hidden="true">1.3.2.</strong> Button to Printf()</a></li><li><a href="../tutorials/03_ble_scan.html"><strong aria-hidden="true">1.3.3.</strong> BLE Advertisement Scanning</a></li><li><a href="../tutorials/04_sensors_and_drivers.html"><strong aria-hidden="true">1.3.4.</strong> Sample Sensors and Use Drivers</a></li><li><a href="../tutorials/05_ipc.html"><strong aria-hidden="true">1.3.5.</strong> Inter-process Communication</a></li></ol></li></ol></li><li><a href="../development/guides.html"><strong aria-hidden="true">2.</strong> Kernel Development Guides</a></li><li><ol class="section"><li><a href="../development/peripheral.html"><strong aria-hidden="true">2.1.</strong> Chip Peripheral Driver</a></li><li><a href="../development/sensor.html" class="active"><strong aria-hidden="true">2.2.</strong> Sensor Driver</a></li><li><a href="../development/syscall.html"><strong aria-hidden="true">2.3.</strong> Syscall Interface</a></li><li><a href="../development/hil.html"><strong aria-hidden="true">2.4.</strong> HIL</a></li><li><a href="../development/virtual.html"><strong aria-hidden="true">2.5.</strong> Virtualizers</a></li><li><a href="../development/tests.html"><strong aria-hidden="true">2.6.</strong> Kernel Tests</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Tock Tutorial</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#implementing-a-sensor-driver" id="implementing-a-sensor-driver">Implementing a Sensor Driver</a></h1>
<p>This guide describes the steps necessary to implement a capsule in Tock that
interfaces with an external IC, like a sensor, memory chip, or display. These
are devices which are not part of the same chip as the main microcontroller
(MCU), but are on the same board and connected via some physical connection.</p>
<blockquote>
<p>Note: to attempt to be generic, this guide will use the term &quot;IC&quot; to refer to
the device the driver is for.</p>
</blockquote>
<blockquote>
<p>Note: &quot;driver&quot; is a bit of an overloaded term in Tock. In this guide, &quot;driver&quot;
is used in the generic sense to mean code that interfaces with the external
IC.</p>
</blockquote>
<p>To illustrate the steps, this guide will use a generic light sensor as the
running example. You will need to adapt the generic steps for your particular
use case.</p>
<p>Often the goal of an IC driver is to expose an interface to that sensor or other
IC to userspace applications. This guide does not cover creating that userspace
interface as that is covered in a different guide.</p>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p>As mentioned, this guide describes creating a capsule. Capsules in Tock are
units of Rust code that extend the kernel to add interesting features, like
interfacing with new sensors. Capsules are &quot;untrusted&quot;, meaning they cannot call
unsafe code in Rust and cannot use the <code>unsafe</code> keyword.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Create a struct for the IC driver.</li>
<li>Implement the logic to interface with the IC.</li>
</ol>
<p>Optional:</p>
<ol>
<li>Provide a HIL interface for the IC driver.</li>
<li>Provide a userspace interface for the IC driver.</li>
</ol>
<h2><a class="header" href="#step-by-step-guide" id="step-by-step-guide">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Create a struct for the IC driver.</strong></p>
<p>The driver will be implemented as a capsule, so the first step is to create
a new file in the <code>capsules/src</code> directory. The name of this file should be
<code>[chipname].rs</code> where <code>[chipname]</code> is the part number of the IC you are
writing the driver for. There are several other examples in the capsules
folder.</p>
<p>For our example we will assume the part number is <code>ls1234</code>.</p>
<p>You then need to add the filename to <code>capsules/src/lib.rs</code> like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod ls1234;
#}</code></pre></pre>
<p>Now inside of the new file you should create a struct with the fields
necessary to implement the driver for the IC. In our example we will assume
the IC is connected to the MCU with an I2C bus. Your IC might use SPI, UART,
or some other standard interface. You will need to adjust how you create the
struct based on the interface. You should be able to find examples in the
capsules directory to copy from.</p>
<p>The struct will look something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Ls1234 {
    i2c: &amp;'a dyn I2CDevice,
    state: Cell&lt;State&gt;,
    buffer: TakeCell&lt;'static, [u8]&gt;,
    client: OptionalCell&lt;&amp;'a dyn Ls1234Client&gt;,
}
#}</code></pre></pre>
<p>You can see the resources this driver requires to successfully interface
with the light sensor:</p>
<ul>
<li>
<p><code>i2c</code>: This is a reference to the I2C bus that the driver will use to
communicate with the IC. Notice in Tock the type is <code>I2CDevice</code>, and no
address is provided. This is because the <code>I2CDevice</code> type wraps the
address in internally, so that the driver code can <em>only</em> communicate with
the correct address.</p>
</li>
<li>
<p><code>state</code>: Often drivers will iterate through various states as they
communicate with the IC, and it is common for drivers to keep some state
variable to manage this. Our <code>State</code> is defined as an enum, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Copy, Clone, PartialEq)]
enum State {
    Disabled,
    Enabling,
    ReadingLight,
}
#}</code></pre></pre>
<p>Also note that the <code>state</code> variable uses a <code>Cell</code>. This is so that the
driver can update the state.</p>
</li>
<li>
<p><code>buffer</code>: This holds a reference to a buffer of memory the driver will use
to send messages over the I2C bus. By convention, these buffers are
defined statically in the same file as the driver, but then passed to the
driver when the board boots. This provides the board flexibility on the
buffer to use, while still allowing the driver to hint at the size
required for successful operation. In our case the static buffer is
defined as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub static mut BUF: [u8; 3] = [0; 3];
#}</code></pre></pre>
<p>Note the buffer is wrapped in a <code>TakeCell</code> such that it can be passed
to the I2C hardware when necessary, and re-stored in the driver struct
when the I2C code returns the buffer.</p>
</li>
<li>
<p><code>client</code>: This is the callback that will be called after the driver has
received a reading from the sensor. All execution is event-based in Tock,
so the caller will not block waiting for a sample, but instead will expect
a callback via the client when the same is ready. The driver has to define
the type of the callback by defining the <code>Ls1234Client</code> trait in this
case:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Ls1234Client {
	 fn callback(light_reading: usize);
}
#}</code></pre></pre>
<p>Note that the client is stored in an <code>OptionalCell</code>. This allows the
callback to not be set initially, and configured at bootup.</p>
</li>
</ul>
<p>Your driver may require other state to be stored as well. You can update
this struct as needed to for state required to successfully implement the
driver. Note that if the state needs to be updated at runtime it will need
to be stored in a cell type. See the cell documentation for more information
on the various cell types in Tock.</p>
<blockquote>
<p>Note: your driver should not keep any state in the struct that is also
stored by the hardware. This easily leads to bugs when that state becomes
out of sync, and makes further development on the driver difficult.</p>
</blockquote>
<p>The last step is to write a function that enables creating an instance of
your driver. By convention, the function is called <code>new()</code> and looks
something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ls1234&lt;'a&gt; {
    pub fn new(i2c: &amp;'a dyn I2CDevice, buffer: &amp;'static mut [u8]) -&gt; Ls1234&lt;'a&gt; {
        Ls1234 {
            i2c: i2c,
            alarm: alarm,
            state: Cell::new(State::Disabled),
            client: OptionalCell::empty(),
        }
    }
}
#}</code></pre></pre>
<p>This function will get called by the board's <code>main.rs</code> file when the driver
is instantiated. All of the static objects or configuration that the driver
requires must be passed in here. In this example, a reference to the I2C
device and the static buffer for passing messages must be provided.</p>
<p><strong>Checkpoint</strong>: You have defined the struct which will become the driver for
the IC.</p>
</li>
<li>
<p><strong>Implement the logic to interface with the IC.</strong></p>
<p>Now, you will actually write the code that interfaces with the IC. This
requires extending the <code>impl</code> of the driver struct with additional functions
appropriate for your particular IC.</p>
<p>With our light sensor example, we likely want to write a sample function for
reading a light sensor value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ls1234&lt;'a&gt; {
    pub fn new(...) -&gt; Ls1234&lt;'a&gt; {...}

    pub fn start_light_reading(&amp;self) {...}
}
#}</code></pre></pre>
<p>Note that the function name is &quot;start light reading&quot;, which is appropriate
because of the event-driven, non-blocking nature of the Tock kernel.
Actually communicating with the sensor will take some time, and likely
requires multiple messages to be sent to and received from the sensor.
Therefore, our sample function will not be able to return the result
directly. Instead, the reading will be provided in the callback function
described earlier.</p>
<p>The start reading function will likely prepare the message buffer in a way
that is IC-specific, then send the command to the IC. A rough example of
that operation looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ls1234&lt;'a&gt; {
    pub fn new(...) -&gt; Ls1234&lt;'a&gt; {...}

    pub fn start_light_reading(&amp;self) {
        if self.state.get() == State::Disabled {
            self.buffer.take().map(|buf| {
                self.i2c.enable();

                // Set the first byte of the buffer to the &quot;on&quot; command.
                // This is IC-specific and will be described in the IC
                // datasheet.
                buf[0] = 0b10100000;

                // Send the command to the chip and update our state
                // variable.
                self.i2c.write(buf, 1);
                self.state.set(State::Enabling);
            });
        }
    }
}
#}</code></pre></pre>
<p>The <code>start_light_reading()</code> function kicks off reading the light value from
the IC and updates our internal state machine state to mark that we are
waiting for the IC to turn on. Now the <code>Ls1234</code> code is finished for the
time being and we now wait for the I2C message to finish being sent. We will
know when this has completed based on a callback from the I2C hardware.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], error: Error) {
        // Handle what happens with the I2C send is complete here.
    }
}
#}</code></pre></pre>
<p>In our example, we have to send a new command after turning on the light
sensor to actually read a sampled value. We use our state machine here to
organize the code as in this example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: Error) {
        match self.state.get() {
            State::Enabling =&gt; {
                // Put the read command in the buffer and send it back to
                // the sensor.
                buffer[0] = 0b10100001;
                self.i2c.write_read(buf, 1, 2);
                // Update our state machine state.
                self.state.set(State::ReadingLight);
            }
            _ =&gt; {}
        }
    }
}
#}</code></pre></pre>
<p>This will send another command to the sensor to read the actual light
measurement. We also update our <code>self.state</code> variable because when this I2C
transaction finishes the exact same <code>command_complete</code> callback will be
called, and we must be able to remember where we are in the process of
communicating with the sensor.</p>
<p>When the read finishes, the <code>command_complete()</code> callback will fire again,
and we must handle the result. Since we now have the reading we can call our
client's callback after updating out state machine.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: Error) {
        match self.state.get() {
            State::Enabling =&gt; {
                // Put the read command in the buffer and send it back to
                // the sensor.
                buffer[0] = 0b10100001;
                self.i2c.write_read(buf, 1, 2);
                // Update our state machine state.
                self.state.set(State::ReadingLight);
            }
            State::ReadingLight =&gt; {
                // Extract the light reading value.
                let mut reading: u16 = buffer[0] as 16;
                reading |= (buffer[1] as u16) &lt;&lt; 8;

                // Update our state machine state.
                self.state.set(State::Disabled);

                // Trigger our callback with the result.
                self.client.map(|client| client.callback(reading));
            }
            _ =&gt; {}
        }
    }
}
#}</code></pre></pre>
<blockquote>
<p>Note: likely the sensor would need to be disabled and returned to a low
power state.</p>
</blockquote>
<p>At this point your driver can read the IC and return the information from
the IC. For your IC you will likely need to expand on this general template.
You can add additional functions to the main struct implementation, and then
expand the state machine to implement those functions. You may also need
additional resources, like GPIO pins or timer alarms to implement the state
machine for the IC. There are examples in the <code>capsules/src</code> folder with
drivers that need different resources.</p>
</li>
</ol>
<h2><a class="header" href="#optional-steps" id="optional-steps">Optional Steps</a></h2>
<ol>
<li>
<p><strong>Provide a HIL interface for the IC driver.</strong></p>
<p>The driver so far has a very IC-specific interface. That is, any code that
uses the driver must be written specifically with that IC in mind. In some
cases that may be reasonable, for example if the IC is very unusual or has a
very unique set of features. However, many ICs provide similar
functionality, and higher-level code can be written without knowing what
specific IC is being used on a particular hardware platform.</p>
<p>To enable this, some IC types have HILs in the <code>kernel/src/hil</code> folder in
the <code>sensors.rs</code> file. Drivers can implement one of these HILs and then
higher-level code can use the HIL interface rather than a specific IC.</p>
<p>To implement the HIL, you must implement the HIL trait functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl AmbientLight for Ls1234&lt;'a&gt; {
    fn set_client(&amp;self, client: &amp;'static dyn AmbientLightClient) {

    }

    fn read_light_intensity(&amp;self) -&gt; ReturnCode {

    }
}
#}</code></pre></pre>
<p>The user of the <code>AmbientLight</code> HIL will implement the <code>AmbientLightClient</code>
and provide the client through the <code>set_client()</code> function.</p>
</li>
<li>
<p><strong>Provide a userspace interface for the IC driver.</strong></p>
<p>Sometimes the IC is needed by userspace, and therefore needs a syscall
interface so that userspace applications can use the IC. Please refer to a
separate guide on how to implement a userspace interface for a capsule.</p>
</li>
</ol>
<h2><a class="header" href="#wrap-up" id="wrap-up">Wrap-Up</a></h2>
<p>Congratulations! You have implemented an IC driver as a capsule in Tock! We
encourage you to submit a pull request to upstream this to the Tock repository.
Tock is happy to accept capsule drivers even if no boards in the Tock repository
currently use the driver.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../development/peripheral.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../development/syscall.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../development/peripheral.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../development/syscall.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
