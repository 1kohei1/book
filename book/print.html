<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tock Tutorial</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="guides.html"><strong aria-hidden="true">1.</strong> Hands-on Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="course.html"><strong aria-hidden="true">1.2.</strong> Tock Course</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="course_setup.html"><strong aria-hidden="true">1.2.1.</strong> Course Setup</a></li><li class="chapter-item expanded "><a href="modules.html"><strong aria-hidden="true">1.2.2.</strong> Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="application.html"><strong aria-hidden="true">1.2.2.1.</strong> Application</a></li><li class="chapter-item expanded "><a href="important_client.html"><strong aria-hidden="true">1.2.2.2.</strong> Important Client</a></li><li class="chapter-item expanded "><a href="capsule.html"><strong aria-hidden="true">1.2.2.3.</strong> Capsule</a></li></ol></li><li class="chapter-item expanded "><a href="graduation.html"><strong aria-hidden="true">1.2.3.</strong> Graduation</a></li></ol></li><li class="chapter-item expanded "><a href="tutorials/tutorials.html"><strong aria-hidden="true">1.3.</strong> Mini Tutorials</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/01_running_blink.html"><strong aria-hidden="true">1.3.1.</strong> Blink an LED</a></li><li class="chapter-item expanded "><a href="tutorials/02_button_print.html"><strong aria-hidden="true">1.3.2.</strong> Button to Printf()</a></li><li class="chapter-item expanded "><a href="tutorials/03_ble_scan.html"><strong aria-hidden="true">1.3.3.</strong> BLE Advertisement Scanning</a></li><li class="chapter-item expanded "><a href="tutorials/04_sensors_and_drivers.html"><strong aria-hidden="true">1.3.4.</strong> Sample Sensors and Use Drivers</a></li><li class="chapter-item expanded "><a href="tutorials/05_ipc.html"><strong aria-hidden="true">1.3.5.</strong> Inter-process Communication</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="development/guides.html"><strong aria-hidden="true">2.</strong> Kernel Development Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="development/peripheral.html"><strong aria-hidden="true">2.1.</strong> Chip Peripheral Driver</a></li><li class="chapter-item expanded "><a href="development/sensor.html"><strong aria-hidden="true">2.2.</strong> Sensor Driver</a></li><li class="chapter-item expanded "><a href="development/syscall.html"><strong aria-hidden="true">2.3.</strong> System Call Interface</a></li><li class="chapter-item expanded "><a href="development/hil.html"><strong aria-hidden="true">2.4.</strong> HIL</a></li><li class="chapter-item expanded "><a href="development/virtual.html"><strong aria-hidden="true">2.5.</strong> Virtualizers</a></li><li class="chapter-item expanded "><a href="development/tests.html"><strong aria-hidden="true">2.6.</strong> Kernel Tests</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Tock Tutorial</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="tock-os-book"><a class="header" href="#tock-os-book">Tock OS Book</a></h1>
<img src="../imgs/tock.svg" style="float:right;" />
This book introduces you to Tock, a secure embedded operating system for sensor
networks and the Internet of Things. Tock is the first operating system to allow
multiple untrusted applications to run concurrently on a microcontroller-based
computer. The Tock kernel is written in Rust, a memory-safe systems language
that does not rely on a garbage collector. Userspace applications are run in
single-threaded processes that can be written in any language.
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>The book includes a <a href="../getting_started.html">quick start guide</a>.</p>
<h2 id="tock-workshop-courses"><a class="header" href="#tock-workshop-courses">Tock Workshop Courses</a></h2>
<p>For a more in-depth walkthough-style less, look <a href="../course.html">here</a>.</p>
<h2 id="development-guides"><a class="header" href="#development-guides">Development Guides</a></h2>
<p>The book also has <a href="../development/guides.html">walkthoughs</a> on how to implement
different features in Tock OS.</p>
<h1 id="hands-on-guides"><a class="header" href="#hands-on-guides">Hands-on Guides</a></h1>
<p>This portion of the book includes workshops and tutorials to teach how to use
and develop with Tock, and is divided into two sections: the course and a series
of mini tutorials. The course is a good place to start, and provides a
structured introduction to Tock that should take a few hours to complete (it was
designed for a half day workshop). The tutorials are smaller examples that
highlight specific features.</p>
<h2 id="tock-course"><a class="header" href="#tock-course">Tock Course</a></h2>
<p>In this hands-on guide, we will look at some of the high-level services provided
by Tock.  We will start with an understanding of the OS and its programming
environment.  Then we'll look at how a process management application can help
afford remote debugging, diagnosing and fixing a resource-intensive app over the
network.  The last part of the tutorial is a bit more free-form, inviting
attendees to further explore the networking and application features of Tock or
to dig into the kernel a bit and explore how to enhance and extend the kernel.</p>
<p>This course assumes some experience programming embedded devices and fluency in
C. It assumes no knowledge of Rust, although knowing Rust will allow you to be
more creative during the kernel exploration at the end.</p>
<h2 id="tock-mini-tutorials"><a class="header" href="#tock-mini-tutorials">Tock Mini Tutorials</a></h2>
<p>These <a href="./tutorials/tutorials.html">tutorials</a> feature specific examples of Tock
applications. They can be completed after the course to learn about different
capabilities of Tock apps.</p>
<h1 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h1>
<p>This getting started guide covers how to get started using Tock.</p>
<h2 id="hardware"><a class="header" href="#hardware">Hardware</a></h2>
<p>To really be able to use Tock and get a feel for the operating system, you will
need a hardware platform that tock supports. The <a href="https://www.tockos.org/hardware/">TockOs
Hardware</a> includes a list of supported
hardware boards. You can also view the <a href="https://github.com/tock/tock/tree/master/boards">boards
folder</a> to see what platforms
are supported.</p>
<p>As of February 2021, this getting started guide is based around five hardware
platforms. Steps for each of these platforms are explicitly described here.
Other platforms will work for Tock, but you may need to reference the README
files in <code>tock/boards/</code> for specific setup information. The five boards are:</p>
<ul>
<li>Hail</li>
<li>imix</li>
<li>nRF52840dk (PCA10056)</li>
<li>Arduino Nano 33 BLE (regular or Sense version)</li>
<li>BBC Micro:bit v2</li>
</ul>
<p>These boards are reasonably well supported, but note that others in Tock may
have some &quot;quirks&quot; around what is implemented (or not), and exactly how to load
code and test that it is working. This guides tries to be general, and Tock
generally tries to follow a certain convention, but the project is under active
development and new boards are added rapidly. You should definitely consult the
board-specific README to see if there are any board-specific details you should
be aware of.</p>
<h2 id="host-machine-setup"><a class="header" href="#host-machine-setup">Host Machine Setup</a></h2>
<p>You can either download a <a href="getting_started.html#virtual-machine">virtual machine</a> with the
development environment pre-installed, or, if you have a Linux or OS X
workstation, you may install the development environment
<a href="getting_started.html#native-installation">natively</a>. Using a virtual machine is quicker and easier
to set up, while installing natively will yield the most comfortable development
environment and is better for long term use.</p>
<h3 id="virtual-machine"><a class="header" href="#virtual-machine">Virtual Machine</a></h3>
<p>If you're comfortable working inside a Debian virtual machine, you can download
an image with all of the dependencies already installed
<a href="https://cesar.cs.princeton.edu/Tock.ova">here</a> or
<a href="https://www.cs.virginia.edu/%7Ebjc8c/archive/Tock.ova">here</a>. Using <code>curl</code> to
download the image is recommended, but your browser should be able to download
it as well:</p>
<pre><code>$ curl -O &lt;url&gt;
</code></pre>
<p>With the virtual machine image downloaded, you can run it with VirtualBox or
VMWare:</p>
<ul>
<li>VirtualBox users: <a href="https://docs.oracle.com/cd/E26217_01/E26796/html/qs-import-vm.html">File → Import Appliance...</a>,</li>
<li>VMWare users: <a href="https://pubs.vmware.com/workstation-9/index.jsp?topic=%2Fcom.vmware.ws.using.doc%2FGUID-DDCBE9C0-0EC9-4D09-8042-18436DA62F7A.html">File → Open...</a></li>
</ul>
<p>The VM account is &quot;tock&quot; with password &quot;tock&quot;. Feel free to customize it with
whichever editors, window managers, etc. you like before the training starts.</p>
<blockquote>
<p>If the Host OS is Linux, you may need to add your user to the <code>vboxusers</code>
group on your machine in order to connect the hardware boards to the virtual
machine.</p>
</blockquote>
<h3 id="native-installation"><a class="header" href="#native-installation">Native Installation</a></h3>
<p>If you choose to install the development environment natively on an existing
operating system install, you will need the following software:</p>
<ol>
<li>
<p>Command line utilities: <code>curl</code>, <code>make</code>, <code>git</code>, <code>python</code> (version 3) and <code>pip3</code>.</p>
</li>
<li>
<p>Clone the Tock kernel repository.</p>
<pre><code> $ git clone https://github.com/tock/tock
</code></pre>
</li>
<li>
<p><a href="http://rustup.rs/">rustup</a>. This tool helps manage installations of the
Rust compiler and related tools.</p>
<pre><code> $ curl https://sh.rustup.rs -sSf | sh
</code></pre>
</li>
<li>
<p><a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">arm-none-eabi
toolchain</a>
(version &gt;= 5.2). This enables you to compile apps written in C for Cortex-M
boards.</p>
<pre><code> # mac
 $ brew tap ARMmbed/homebrew-formulae &amp;&amp; brew update &amp;&amp; brew install arm-none-eabi-gcc

 # linux
 $ sudo apt install gcc-arm-none-eabi
</code></pre>
</li>
<li>
<p><a href="https://www.sifive.com/boards">riscv64-unknown-elf toolchain</a> (version &gt;=
v2019.08.0). Scroll down to the &quot;Prebuilt RISC‑V GCC Toolchain&quot; section. This
enables you to compile apps written in C for RISC-V boards.</p>
<pre><code> # mac
 $ brew install riscv-gnu-toolchain --with-multilib
</code></pre>
</li>
<li>
<p><a href="https://github.com/tock/tockloader">tockloader</a>. This is an all-in-one tool
for programming boards and using Tock.</p>
<pre><code> $ pip3 install -U --user tockloader
</code></pre>
<blockquote>
<p>Note: On MacOS, you may need to add <code>tockloader</code> to your path. If you
cannot run it after installation, run the following:</p>
</blockquote>
<pre><code> $ export PATH=$HOME/Library/Python/3.6/bin/:$PATH
</code></pre>
<blockquote>
<p>Similarly, on Linux distributions, this will typically install to
<code>$HOME/.local/bin</code>, and you may need to add that to your <code>$PATH</code> if not
already present:</p>
</blockquote>
<pre><code> $ PATH=$HOME/.local/bin:$PATH
</code></pre>
</li>
</ol>
<h3 id="testing-you-can-compile-the-kernel"><a class="header" href="#testing-you-can-compile-the-kernel">Testing You Can Compile the Kernel</a></h3>
<p>To test if your environment is working enough to compile Tock, go to the
<code>tock/boards/</code> directory and then to the board folder for the hardware you have
(e.g. <code>tock/boards/imix</code> for imix). Then run <code>make</code> in that directory. This
should compile the kernel. It may need to compile several supporting libraries
first (so may take 30 seconds or so the first time). You should see output like
this:</p>
<pre><code>$ cd tock/boards/imix
$ make
   Compiling tock-cells v0.1.0 (/Users/bradjc/git/tock/libraries/tock-cells)
   Compiling tock-registers v0.5.0 (/Users/bradjc/git/tock/libraries/tock-register-interface)
   Compiling enum_primitive v0.1.0 (/Users/bradjc/git/tock/libraries/enum_primitive)
   Compiling tock-rt0 v0.1.0 (/Users/bradjc/git/tock/libraries/tock-rt0)
   Compiling imix v0.1.0 (/Users/bradjc/git/tock/boards/imix)
   Compiling kernel v0.1.0 (/Users/bradjc/git/tock/kernel)
   Compiling cortexm v0.1.0 (/Users/bradjc/git/tock/arch/cortex-m)
   Compiling capsules v0.1.0 (/Users/bradjc/git/tock/capsules)
   Compiling cortexm4 v0.1.0 (/Users/bradjc/git/tock/arch/cortex-m4)
   Compiling sam4l v0.1.0 (/Users/bradjc/git/tock/chips/sam4l)
   Compiling components v0.1.0 (/Users/bradjc/git/tock/boards/components)
    Finished release [optimized + debuginfo] target(s) in 28.67s
   text    data     bss     dec     hex filename
 165376    3272   54072  222720   36600 /Users/bradjc/git/tock/target/thumbv7em-none-eabi/release/imix
   Compiling typenum v1.11.2
   Compiling byteorder v1.3.4
   Compiling byte-tools v0.3.1
   Compiling fake-simd v0.1.2
   Compiling opaque-debug v0.2.3
   Compiling block-padding v0.1.5
   Compiling generic-array v0.12.3
   Compiling block-buffer v0.7.3
   Compiling digest v0.8.1
   Compiling sha2 v0.8.1
   Compiling sha256sum v0.1.0 (/Users/bradjc/git/tock/tools/sha256sum)
6fa1b0d8e224e775d08e8b58c6c521c7b51fb0332b0ab5031fdec2bd612c907f  /Users/bradjc/git/tock/target/thumbv7em-none-eabi/release/imix.bin
</code></pre>
<p>You can check that tockloader is installed by running:</p>
<pre><code>$ tockloader --help
</code></pre>
<p>If either of these steps fail, please double check that you followed the
environment setup instructions above.</p>
<h2 id="getting-the-hardware-connected-and-setup"><a class="header" href="#getting-the-hardware-connected-and-setup">Getting the Hardware Connected and Setup</a></h2>
<p>Plug your hardware board into your computer. Generally this requires a micro USB
cable, but your board may be different.</p>
<blockquote>
<h4 id="note-some-boards-have-multiple-usb-ports"><a class="header" href="#note-some-boards-have-multiple-usb-ports">Note! Some boards have multiple USB ports.</a></h4>
<p>Some boards have two USB ports, where one is generally for debugging, and the
other allows the board to act as any USB peripheral. You will want to connect
using the &quot;debug&quot; port.</p>
<p>Some example boards:</p>
<ul>
<li>imix: Use the port labeled <code>DEBUG</code>.</li>
<li>nRF52 development boards: Use the port of the left, on the skinny side of
the board.</li>
</ul>
</blockquote>
<p>The board should appear as a regular serial device (e.g.
<code>/dev/tty.usbserial-c098e5130006</code> on my Mac or <code>/dev/ttyUSB0</code> on my Linux box).
This may require some setup, see the &quot;one-time fixups&quot; box.</p>
<blockquote>
<h4 id="one-time-fixups"><a class="header" href="#one-time-fixups">One-Time Fixups</a></h4>
<ul>
<li>
<p>On Linux, you might need to give your user access to the serial port used by
the board. If you get permission errors or you cannot access the serial
port, this is likely the issue.</p>
<p>You can fix this by setting up a udev rule to set the permissions correctly
for the serial device when it is attached. You only need to run the command
below for your specific board, but if you don't know which one to use,
running both is totally fine, and will set things up in case you get a
different hardware board!</p>
<pre><code>$ sudo bash -c &quot;echo 'ATTRS{idVendor}==\&quot;0403\&quot;, ATTRS{idProduct}==\&quot;6015\&quot;, MODE=\&quot;0666\&quot;' &gt; /etc/udev/rules.d/99-ftdi.rules&quot;
$ sudo bash -c &quot;echo 'ATTRS{idVendor}==\&quot;2341\&quot;, ATTRS{idProduct}==\&quot;005a\&quot;, MODE=\&quot;0666\&quot;' &gt; /etc/udev/rules.d/98-arduino.rules&quot;
</code></pre>
<p>Afterwards, detach and re-attach the board to reload the rule.</p>
</li>
<li>
<p>With a virtual machine, you might need to attach the USB device to the
VM. To do so, after plugging in the board, select in the VirtualBox/VMWare
menu bar:</p>
<pre><code>Devices -&gt; USB Devices -&gt; [The name of your board]
</code></pre>
<p>If you aren't sure which board to select, it is often easiest to unplug and
re-plug the board and see which entry is removed and then added.</p>
<p>If this generates an error, often unplugging/replugging fixes it. You can
also create a rule in the VM USB settings which will auto-attach the board
to the VM.</p>
</li>
<li>
<p>With Windows Subsystem for Linux (WSL), the serial device parameters stored in
the FTDI chip do not seem to get passed to Ubuntu. Plus, WSL enumerates
every possible serial device. Therefore, tockloader cannot automatically
guess which serial port is the correct one, and there are a lot to choose
from.</p>
<p>You will need to open Device Manager on Windows, and find which <code>COM</code> port
the tock board is using. It will likely be called &quot;USB Serial Port&quot; and be
listed as an FTDI device. The COM number will match what is used in WSL.
For example, <code>COM9</code> is <code>/dev/ttyS9</code> on WSL.</p>
<p>To use tockloader you should be able to specify the port manually. For example:
<code>tockloader --port /dev/ttyS9 list</code>.</p>
</li>
</ul>
</blockquote>
<h3 id="one-time-board-setup"><a class="header" href="#one-time-board-setup">One Time Board Setup</a></h3>
<p>If you have a <strong>Hail</strong>, <strong>imix</strong>, or <strong>nRF52840dk</strong> please skip to the next
section.</p>
<p>If you have an <strong>Arduino Nano 33 BLE</strong> (sense or regular), you need to update
the bootloader on the board to the Tock bootloader. Please follow the
<a href="https://github.com/tock/tock/tree/master/boards/nano33ble#getting-started">bootloader update
instructions</a>.</p>
<p>If you have a <strong>Micro:bit v2</strong> then you need to load the Tock booloader. Please
follow the <a href="https://github.com/tock/tock/tree/master/boards/microbit_v2">bootloader installation
instructions</a>.</p>
<h3 id="test-the-board"><a class="header" href="#test-the-board">Test The Board</a></h3>
<p>With the board connected, you should be able to use tockloader to interact with
the board. For example, to retrieve serial UART data from the board, run
<code>tockloader listen</code>, and you should see something like:</p>
<pre><code>$ tockloader listen
No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/ttyUSB0 - Imix - TockOS&quot;

Listening for serial output.
Initialization complete. Entering main loop
Hello World!
</code></pre>
<p>You may also need to reset (by pressing the reset button on the board) the board
to see the message. You may also not see any output if the Tock kernel has not
been flashed yet.</p>
<p>You can also see if any applications are installed with <code>tockloader list</code>:</p>
<pre><code>$ tockloader list
[INFO   ] No device name specified. Using default name &quot;tock&quot;.
[INFO   ] Using &quot;/dev/cu.usbmodem14101 - Nano 33 BLE - TockOS&quot;.
[INFO   ] Paused an active tockloader listen in another session.
[INFO   ] Waiting for the bootloader to start
[INFO   ] No found apps.
[INFO   ] Finished in 2.928 seconds
[INFO   ] Resumed other tockloader listen session
</code></pre>
<p>If these commands fail you may not have installed Tockloader, or you may need to
update to a later version of Tockloader. There may be other issues as well, and
you can ask on
<a href="https://join.slack.com/t/tockos/shared_invite/enQtNDE5ODQyNDU4NTE1LWVjNTgzMTMwYzA1NDI1MjExZjljMjFmOTMxMGIwOGJlMjk0ZTI4YzY0NTYzNWM0ZmJmZGFjYmY5MTJiMDBlOTk">Slack</a>
if you need help.</p>
<h3 id="flash-the-kernel"><a class="header" href="#flash-the-kernel">Flash the kernel</a></h3>
<p>Now that the board is connected and you have verified that the kernel compiles
(from the steps above), we can flash the board with the latest Tock kernel:</p>
<pre><code>$ cd boards/&lt;your board&gt;
$ make
</code></pre>
<p>Generally boards are programmed with either <code>make program</code> or <code>make flash</code>. Try
<code>make program</code> first:</p>
<pre><code>$ make program
</code></pre>
<p>If that is not available, you can use <code>make flash</code>:</p>
<pre><code>$ make flash
</code></pre>
<p>You can also look at the board's README for more details.</p>
<blockquote>
<h4 id="why-both-make-program-and-make-flash"><a class="header" href="#why-both-make-program-and-make-flash">Why both <code>make program</code> and <code>make flash</code>?</a></h4>
<p>While these commands do the same thing, the way they go about it is very
different.</p>
<p>The <code>make program</code> version communicates with the board via a serial connection
and a bootloader running on the board. You may need to manually enter the
bootloader when using <code>make program</code>.</p>
<p>The <code>make flash</code> version uses a JTAG debugger to communicate with the chip and
flash the kernel binary directly to the chip.</p>
</blockquote>
<h3 id="install-some-applications"><a class="header" href="#install-some-applications">Install Some Applications</a></h3>
<p>We have the kernel flashed, but the kernel doesn't actually <em>do</em> anything.
Applications do! To load applications, we are going to use tockloader.</p>
<h4 id="loading-pre-built-applications"><a class="header" href="#loading-pre-built-applications">Loading Pre-built Applications</a></h4>
<p>We're going to install some pre-built applications, but first, let's make sure
we're in a clean state, in case your board already has some applications
installed. This command removes any processes that may have already been
installed.</p>
<pre><code>$ tockloader erase-apps
</code></pre>
<p>Now, let's install two pre-compiled example apps. Remember, you may need to
specify which board you are using and how to communicate with it for all of
these commands. If you are using Hail or imix you will not have to.</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/blink.tab
</code></pre>
<blockquote>
<p>The <code>install</code> subcommand takes a path or URL to an TAB (Tock Application
Binary) file to install.</p>
</blockquote>
<p>The board should restart and the user LED should start blinking. Let's also
install a simple &quot;Hello World&quot; application:</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/c_hello.tab
</code></pre>
<p>If you now run <code>tockloader listen</code> you should be able to see the output of the
Hello World! application. You may need to manually reset the board for this to
happen.</p>
<pre><code>$ tockloader listen
[INFO   ] No device name specified. Using default name &quot;tock&quot;.
[INFO   ] Using &quot;/dev/cu.usbserial-c098e513000a - Hail IoT Module - TockOS&quot;.

[INFO   ] Listening for serial output.
Initialization complete. Entering main loop.
Hello World!
␀
</code></pre>
<h4 id="uninstalling-and-installing-more-apps"><a class="header" href="#uninstalling-and-installing-more-apps">Uninstalling and Installing More Apps</a></h4>
<p>Lets check what's on the board right now:</p>
<pre><code>$ tockloader list
...
┌──────────────────────────────────────────────────┐
│ App 0                                            |
└──────────────────────────────────────────────────┘
  Name:                  blink
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes


┌──────────────────────────────────────────────────┐
│ App 1                                            |
└──────────────────────────────────────────────────┘
  Name:                  c_hello
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   1024 bytes


[INFO   ] Finished in 2.939 seconds
</code></pre>
<p>As you can see, the apps are still installed on the board. We can remove apps
with the following command:</p>
<pre><code>$ tockloader uninstall
</code></pre>
<p>Following the prompt, if you remove the <code>blink</code> app, the LED will stop blinking,
however the console will still print <code>Hello World</code>.</p>
<p>Now let's try adding a more interesting app:</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/sensors.tab
</code></pre>
<p>The <code>sensors</code> app will automatically discover all available sensors, sample them
once a second, and print the results.</p>
<pre><code>$ tockloader listen
[INFO   ] No device name specified. Using default name &quot;tock&quot;.
[INFO   ] Using &quot;/dev/cu.usbserial-c098e513000a - Hail IoT Module - TockOS&quot;.

[INFO   ] Listening for serial output.
Initialization complete. Entering main loop.
[Sensors] Starting Sensors App.
Hello World!
␀[Sensors] All available sensors on the platform will be sampled.
ISL29035:   Light Intensity: 218
Temperature:                 28 deg C
Humidity:                    42%
FXOS8700CQ: X:               -112
FXOS8700CQ: Y:               23
FXOS8700CQ: Z:               987
</code></pre>
<h4 id="compiling-and-loading-applications"><a class="header" href="#compiling-and-loading-applications">Compiling and Loading Applications</a></h4>
<p>There are many more example applications in the <code>libtock-c</code> repository that you
can use. Let's try installing the ROT13 cipher pair. These two applications use
inter-process communication (IPC) to implement a <a href="https://en.wikipedia.org/wiki/ROT13">ROT13
cipher</a>.</p>
<p>Start by uninstalling any applications:</p>
<pre><code>$ tockloader uninstall
</code></pre>
<p>Get the libtock-c repository:</p>
<pre><code>$ git clone https://github.com/tock/libtock-c
</code></pre>
<p>Build the rot13_client application and install it:</p>
<pre><code>$ cd libtock-c/examples/rot13_client
$ make
$ tockloader install
</code></pre>
<p>Then make and install the rot13_service application:</p>
<pre><code>$ cd ../rot13_service
$ tockloader install --make
</code></pre>
<p>Then you should be able to see the output:</p>
<pre><code>$ tockloader listen
[INFO   ] No device name specified. Using default name &quot;tock&quot;.
[INFO   ] Using &quot;/dev/cu.usbserial-c098e5130152 - Hail IoT Module - TockOS&quot;.
[INFO   ] Listening for serial output.
Initialization complete. Entering main loop.
12: Uryyb Jbeyq!
12: Hello World!
12: Uryyb Jbeyq!
12: Hello World!
12: Uryyb Jbeyq!
12: Hello World!
12: Uryyb Jbeyq!
12: Hello World!
</code></pre>
<blockquote>
<p>Note: Tock platforms are limited in the number of apps they can load and run.
However, it is possible to install more apps than this limit, since tockloader
is (currently) unaware of this limitation and will allow to you to load
additional apps. However the kernel will only load the first apps until the
limit is reached.</p>
</blockquote>
<h4 id="note-about-identifying-boards"><a class="header" href="#note-about-identifying-boards">Note about Identifying Boards</a></h4>
<p>Tockloader tries to automatically identify which board is attached to make this
process simple. This means for many boards (particularly the ones listed at the
top of this guide) tockloader should &quot;just work&quot;.</p>
<p>However, for some boards tockloader does not have a good way to identify which
board is attached, and requires that you manually specify which board you are
trying to program. This can be done with the <code>--board</code> argument. For example, if
you have an nrf52dk or nrf52840dk, you would run Tockloader like:</p>
<pre><code>$ tockloader &lt;command&gt; --board nrf52dk --jlink
</code></pre>
<p>The <code>--jlink</code> flag tells tockloader to use the JLink JTAG tool to communicate
with the board (this mirrors using <code>make flash</code> above). Some boards support
OpenOCD, in which case you would pass <code>--openocd</code> instead.</p>
<p>To see a list of boards that tockloader supports, you can run <code>tockloader list-known-boards</code>. If you have an imix or Hail board, you should not need to
specify the board.</p>
<blockquote>
<p>Note, a board listed in <code>tockloader list-known-boards</code> means there are default
settings hardcoded into tockloader's source on how to support those boards.
However, all of those settings can be passed in via command-line parameters
for boards that tockloader does not know about. See <code>tockloader --help</code> for
more information.</p>
</blockquote>
<h2 id="familiarize-yourself-with-tockloader-commands"><a class="header" href="#familiarize-yourself-with-tockloader-commands">Familiarize Yourself with <code>tockloader</code> Commands</a></h2>
<p>The <code>tockloader</code> tool is a useful and versatile tool for managing and installing
applications on Tock. It supports a number of commands, and a more complete list
can be found in the tockloader repository, located at
<a href="https://github.com/tock/tockloader#usage">github.com/tock/tockloader</a>. Below is
a list of the more useful and important commands for programming and querying a
board.</p>
<h3 id="tockloader-install"><a class="header" href="#tockloader-install"><code>tockloader install</code></a></h3>
<p>This is the main tockloader command, used to load Tock applications onto a
board.  By default, <code>tockloader install</code> adds the new application, but does not
erase any others, replacing any already existing application with the same name.
Use the <code>--no-replace</code> flag to install multiple copies of the same app. To
install an app, either specify the <code>tab</code> file as an argument, or navigate to the
app's source directory, build it (probably using <code>make</code>), then issue the install
command:</p>
<pre><code>$ tockloader install
</code></pre>
<blockquote>
<p><em>Tip:</em> You can add the <code>--make</code> flag to have tockloader automatically
run make before installing, i.e. <code>tockloader install --make</code></p>
</blockquote>
<blockquote>
<p><em>Tip:</em> You can add the <code>--erase</code> flag to have tockloader automatically
remove other applications when installing a new one.</p>
</blockquote>
<h3 id="tockloader-uninstall-application-names"><a class="header" href="#tockloader-uninstall-application-names"><code>tockloader uninstall [application name(s)]</code></a></h3>
<p>Removes one or more applications from the board by name.</p>
<h3 id="tockloader-erase-apps"><a class="header" href="#tockloader-erase-apps"><code>tockloader erase-apps</code></a></h3>
<p>Removes all applications from the board.</p>
<h3 id="tockloader-list"><a class="header" href="#tockloader-list"><code>tockloader list</code></a></h3>
<p>Prints basic information about the apps currently loaded onto the board.</p>
<h3 id="tockloader-info"><a class="header" href="#tockloader-info"><code>tockloader info</code></a></h3>
<p>Shows all properties of the board, including information about currently
loaded applications, their sizes and versions, and any set attributes.</p>
<h3 id="tockloader-listen"><a class="header" href="#tockloader-listen"><code>tockloader listen</code></a></h3>
<p>This command prints output from Tock apps to the terminal. It listens via UART,
and will print out anything written to stdout/stderr from a board.</p>
<blockquote>
<p><em>Tip:</em> As a long-running command, <code>listen</code> interacts with other tockloader
sessions. You can leave a terminal window open and listening. If another
tockloader process needs access to the board (e.g. to install an app update),
tockloader will automatically pause and resume listening.</p>
</blockquote>
<h3 id="tockloader-flash"><a class="header" href="#tockloader-flash"><code>tockloader flash</code></a></h3>
<p>Loads binaries onto hardware platforms that are running a compatible bootloader.
This is used by the Tock Make system when kernel binaries are programmed to the
board with <code>make program</code>.</p>
<h1 id="tock-course-1"><a class="header" href="#tock-course-1">Tock Course</a></h1>
<p>The Tock course includes several different modules that guide you through
various aspects of Tock and Tock applications. Each module is designed to be
standalone such that a full course can be composed of different modules
depending on the interests and backgrounds of those doing the course.</p>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>You should follow the <a href="../getting_started.html">getting started guide</a> to get
your development setup and ensure you can communicate with the hardware.</p>
<h2 id="hardware-1"><a class="header" href="#hardware-1">Hardware</a></h2>
<p><img src="../imgs/imix.svg" alt="" /></p>
<p>The Tock course is currently written for an imix hardware platform. To follow
the directions directly, you will need an <em>imix</em> hardware platform (pictured
above). Tock is a general operating system, however, and other boards <em>should</em>
work, but they might not provide the exact same hardware sensors or peripherals.</p>
<p>To complete the 6LoWPAN networking portion of this guide, you'll need an
additional imix to act as a hub.</p>
<h2 id="setup-to-compile-and-program-the-kernel"><a class="header" href="#setup-to-compile-and-program-the-kernel">Setup to Compile and Program the Kernel</a></h2>
<p>All of the hands-on exercises will be done within the source code for this book.
So pop open a terminal, and navigate to the repository. If you're using the VM,
that'll be:</p>
<pre><code>$ cd ~/book
</code></pre>
<h3 id="make-sure-your-tock-repository-is-up-to-date"><a class="header" href="#make-sure-your-tock-repository-is-up-to-date">Make sure your Tock repository is up to date</a></h3>
<pre><code>$ git pull
</code></pre>
<h3 id="build-the-kernel"><a class="header" href="#build-the-kernel">Build the kernel</a></h3>
<p>To build the kernel, just type make in the <code>imix/</code> subdirectory.</p>
<pre><code>$ cd imix/
$ make
</code></pre>
<p>If this is the first time you are trying to make the kernel, the build system
will use cargo and rustup to install various Tock dependencies.</p>
<p>If this is your first time building a Tock kernel for this particular
architecture, you may get an error complaining that you don't have the proper
the <code>cargo</code> target installed. We can use <code>rustup</code> to fix that:</p>
<pre><code>$ rustup target add thumbv7em-none-eabi
</code></pre>
<blockquote>
<p><code>imix</code> is based around an ARM Cortex-M4 microcontroller, which uses the
thumbv7em instruction set. The rustup command above just downloads Rust core
libraries for this architecture.</p>
</blockquote>
<h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>The various modules are independent lessons that guide you through certain
aspects of Tock. You should be able to do the lessons that are of interest to
you.</p>
<p>Each module begins with a description of the lesson, and then includes steps to
follow. The modules cover both programming in the kernel as well as
applications.</p>
<h1 id="write-an-environment-sensing-application"><a class="header" href="#write-an-environment-sensing-application">Write an environment sensing application</a></h1>
<h2 id="process-overview-relocation-model-and-system-call-api"><a class="header" href="#process-overview-relocation-model-and-system-call-api">Process overview, relocation model and system call API</a></h2>
<p>In this section, we're going to learn about processes (a.k.a applications) in
Tock, and build our own applications in C.</p>
<h2 id="get-a-c-application-running-on-your-board"><a class="header" href="#get-a-c-application-running-on-your-board">Get a C application running on your board</a></h2>
<p>You'll find the outline of a C application in the directory
<code>exercises/app</code>.</p>
<p>Take a look at the code in <code>main.c</code>. So far, this application merely prints
&quot;Hello, World!&quot;.</p>
<p>The code uses the standard C library routine <code>printf</code> to compose a message
using a format string and print it to the console. Let's break down what the
code layers are here:</p>
<ol>
<li>
<p><code>printf</code> is provided by the C standard library (implemented by
<a href="https://sourceware.org/newlib/">newlib</a>). It takes the format string and
arguments, and generates an output string from them. To actually write the
string to standard out, <code>printf</code> calls <code>_write</code>.</p>
</li>
<li>
<p><code>_write</code> (in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/sys.c"><code>sys.c</code></a>) is a
wrapper for actually writing to output streams (in this case, standard out
a.k.a. the console). It calls the Tock-specific console writing function
<code>putnstr</code>.</p>
</li>
<li>
<p><code>putnstr</code>(in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/console.c"><code>console.c</code></a>)
is a buffers data to be written, calls <code>putnstr_async</code>, and acts as a
synchronous wrapper, yielding until the operation is complete.</p>
</li>
<li>
<p>Finally, <code>putnstr_async</code> (in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/console.c"><code>console.c</code></a>)
performs the actual system calls, calling to <code>allow</code>, <code>subscribe</code>, and
<code>command</code> to enable the kernel to access the buffer, request a callback when
the write is complete, and begin the write operation respectively.</p>
</li>
</ol>
<p>The application could accomplish all of this by invoking Tock system calls
directly, but using libraries makes for a much cleaner interface and allows
users to not need to know the inner workings of the OS.</p>
<h3 id="loading-an-application"><a class="header" href="#loading-an-application">Loading an application</a></h3>
<p>Okay, let's build and load this simple program.</p>
<ol>
<li>
<p>Erase all other applications from the development board:</p>
<pre><code> $ tockloader erase-apps
</code></pre>
</li>
<li>
<p>Build the application and load it (Note: <code>tockloader install</code> automatically searches the
current working directory and its subdirectories for Tock binaries.)</p>
<pre><code> $ tockloader install --make
</code></pre>
</li>
<li>
<p>Check that it worked:</p>
<pre><code> $ tockloader listen
</code></pre>
<p>The output should look something like:</p>
<pre><code>$ tockloader listen
No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/cu.usbserial-c098e5130012 - Hail IoT Module - TockOS&quot;

Listening for serial output.
Hello, World!
</code></pre>
</li>
</ol>
<h2 id="creating-your-own-application"><a class="header" href="#creating-your-own-application">Creating your own application</a></h2>
<p>Now that you've got a basic app working, modify it so that it continuously
prints out <code>Hello World</code> twice per second.  You'll want to use the user
library's timer facilities to manage this:</p>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p>You'll find the interface for timers in <code>libtock/timer.h</code>. The
function you'll find useful today is:</p>
<pre><code class="language-c">#include &lt;timer.h&gt;
void delay_ms(uint32_t ms);
</code></pre>
<p>This function sleeps until the specified number of milliseconds have passed, and
then returns.  So we call this function &quot;synchronous&quot;: no further code will run
until the delay is complete.</p>
<h2 id="write-an-app-that-periodically-samples-the-on-board-sensors"><a class="header" href="#write-an-app-that-periodically-samples-the-on-board-sensors">Write an app that periodically samples the on-board sensors</a></h2>
<p>Now that we have the ability to write applications, let's do something a little
more complex. The development board you are using has several sensors on it.
These sensors include a light sensor, a humidity sensor, and a temperature
sensor. Each sensing medium can be accessed separately via the Tock user
library. We'll just be using the light and temperature for this exercise.</p>
<h4 id="light"><a class="header" href="#light">Light</a></h4>
<p>The interface in <code>libtock/ambient_light.h</code> is used to measure ambient
light conditions in <a href="https://en.wikipedia.org/wiki/Lux">lux</a>. imix uses the
<a href="https://www.intersil.com/en/products/optoelectronics/ambient-light-sensors/light-to-digital-sensors/ISL29035.html">ISL29035</a>
sensor, but the userland library is abstracted from the details of particular
sensors.  It contains the function:</p>
<pre><code class="language-c">#include &lt;ambient_light.h&gt;
int ambient_light_read_intensity_sync(int* lux);
</code></pre>
<p>Note that the light reading is written to the location passed as an
argument, and the function returns non-zero in the case of an error.</p>
<h4 id="temperature"><a class="header" href="#temperature">Temperature</a></h4>
<p>The interface in <code>libtock/temperature.h</code> is used to measure ambient
temperature in degrees Celsius, times 100. imix uses the
<a href="https://www.silabs.com/products/sensors/humidity-sensors/Pages/si7013-20-21.aspx">SI7021</a>
sensor. It contains the function:</p>
<pre><code class="language-c">#include &lt;temperature.h&gt;
int temperature_read_sync(int* temperature);
</code></pre>
<p>Again, this function returns non-zero in the case of an error.</p>
<h3 id="read-sensors-in-a-tock-application"><a class="header" href="#read-sensors-in-a-tock-application">Read sensors in a Tock application</a></h3>
<p>Using the example program you're working on, write an application that reads
all of the sensors on your development board and reports their readings over
the serial port.</p>
<p>As a bonus, experiment with toggling an LED when readings are above or below a
certain threshold:</p>
<h4 id="led"><a class="header" href="#led">LED</a></h4>
<p>The interface in <code>libtock/led.h</code> is used to control lights on Tock boards. On the Hail
board, there are three LEDs which can be controlled: Red, Blue, and Green. The
functions in the LED module are:</p>
<pre><code class="language-c">#include &lt;led.h&gt;
int led_count(void);
</code></pre>
<p>Which returns the number of LEDs available on the board.</p>
<pre><code class="language-c">int led_on(int led_num);
</code></pre>
<p>Which turns an LED on, accessed by its number.</p>
<pre><code class="language-c">int led_off(int led_num);
</code></pre>
<p>Which turns an LED off, accessed by its number.</p>
<pre><code class="language-c">int led_toggle(int led_num);
</code></pre>
<p>Which toggles the state of an LED, accessed by its number.</p>
<h1 id="keep-the-client-happy"><a class="header" href="#keep-the-client-happy">Keep the client happy</a></h1>
<p>You, an engineer newly added to a top-secret project in your organization, have
been directed to commission a new imix node for your most important client. The
directions you receive are terse, but helpful:</p>
<pre><code>On Sunday, Nov 4, 2018, Director Hines wrote:

Welcome to the team, need you to get started right away. The client needs an
imix setup with their two apps -- ASAP. Make sure it is working, we need to keep
this client happy.

- DH
</code></pre>
<p>Hmm, ok, not a lot to go on, but luckily in orientation you learned how to flash
a kernel and apps on to the imix board, so you are all set for your first
assignment.</p>
<p>Poking around, you notice a folder called &quot;important-client&quot;. While that is a
good start, you also notice that it has two apps inside of it! &quot;Alright!&quot; you
are thinking, &quot;My first day is shaping up to go pretty smoothly.&quot;</p>
<p>After installing those two apps, which are a little mysterious still, you decide
that it would also be a good idea to install an app you are more familiar with:
the &quot;blink&quot; app. After doing all of that, you run <code>tockloader list</code> and see the
following:</p>
<pre><code>$ tockloader list

No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/ttyUSB1 - imix IoT Module - TockOS&quot;

[App 0]
  Name:                  app2
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   16384 bytes


[App 1]
  Name:                  app1
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   8192 bytes


[App 2]
  Name:                  blink
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes


Finished in 1.959 seconds
</code></pre>
<hr />
<blockquote>
<p><strong>Checkpoint</strong></p>
<p>Make sure you have these apps installed correctly and <code>tockloader list</code>
produces similar output as shown here.</p>
</blockquote>
<hr />
<p>Great! Now you check that the LED is blinking, and sure enough, no problems
there. The blink app was just for testing, so you <code>tockloader uninstall blink</code>
to remove that. So far, so good, Tock! But, before you prepare to head home
after a successful day, you start to wonder if maybe this was a little too easy.
Also, if you get this wrong, it's not going to look good as the new person on
the team.</p>
<p>Looking in the folders for the two applications, you notice a brief description
of the apps, and a URL. Ok, maybe you can check if everything is working.
After trying things for a little bit, everything seems to be in order. You
tell the director the board is ready and head home a little early—you did
just successfully complete your first project for a major client after all.</p>
<h2 id="back-at-work-the-next-day"><a class="header" href="#back-at-work-the-next-day">Back at Work the Next Day</a></h2>
<p>Expecting a more challenging project after how well things went yesterday, you
are instead greeted by this email:</p>
<pre><code>On Monday, Nov 5, 2018, Director Hines wrote:

I know you are new, but what did you do?? I've been getting calls all morning
from the client, the imix board you gave them ran out battery already!! Are you
sure you set up the board correctly? Fix it, and get it back to me later today.

- DH
</code></pre>
<p>Well, that's not good. You already removed the blink app, so it can't be that.
What you need is some way to inspect the board and see if something looks like
it is going awry. You first try:</p>
<pre><code>$ tockloader listen
</code></pre>
<p>to see if any debugging information is being printed. A little, but nothing
helpful. Before trying to look around the code, you decided to try sending the
board a plea for help:</p>
<pre><code>help
</code></pre>
<p>and, surprisingly, it responded!</p>
<pre><code>Welcome to the process console.
Valid commands are: help status list stop start
</code></pre>
<p>Ok! Maybe the process console can help. Try the <code>status</code> command:</p>
<pre><code>Total processes: 2
Active processes: 2
Timeslice expirations: 4277
</code></pre>
<p>It seems this tool is actually able to inspect the current system and the active
processes! But hmmm, it seems there are a lot of &quot;timeslice expirations&quot;. From
orientation, you remember that processes are allocated only a certain quantum of
time to execute, and if they exceed that the kernel forces a context switch back
to the kernel. If that is happening a lot, then the board is likely unable to go
to sleep! That could explain why the battery is draining so fast!</p>
<p>But which process is at fault? Perhaps we should try another command.
Maybe <code>list</code>:</p>
<pre><code> PID    Name                Quanta  Syscalls  Dropped Callbacks    State
  00	app2                     0       336                  0  Yielded
  01	app1                  8556   1439951                  0  Running
</code></pre>
<p>Ok! Now we have the status of individual applications. And aha! We can clearly
see the faulty application. From our testing we know that one app detects
button presses and one app is transmitting sensor data. Let's see if we can
disable the faulty app somehow and see which data packets we are still getting.
Going back to the help command, the <code>stop</code> command seems promising:</p>
<pre><code>stop &lt;app name&gt;
</code></pre>
<h2 id="time-to-fix-the-app"><a class="header" href="#time-to-fix-the-app">Time to Fix the App</a></h2>
<p>After debugging, we now know a couple things about the issue:</p>
<ul>
<li>The name of the faulty app.</li>
<li>That it is functionally correct but is for some reason consuming excess CPU
cycles.</li>
</ul>
<p>Using this information, dig into the the faulty app.</p>
<h3 id="a-quick-fix"><a class="header" href="#a-quick-fix">A Quick Fix</a></h3>
<p>To get the director off your back, you should be able to introduce a simple fix
that will reduce wakeups by waiting a bit between samples.</p>
<h3 id="a-better-way"><a class="header" href="#a-better-way">A Better Way</a></h3>
<p>While the quick fix will slow the number of wakeups, you know that you can do
better than polling for something like a button press! Tock supports
asynchronous operations allowing user processes to <em>subscribe</em> to interrupts.</p>
<p>Looking at the button interface (in button.h), it looks like we'll first have to
enable interrupts and then sign up to listen to them.</p>
<p>Once this energy-optimal patch is in place, it'll be time to kick off a
triumphant e-mail to the director, and then off to celebrate!</p>
<h1 id="capsule"><a class="header" href="#capsule">Capsule</a></h1>
<p>The goal of this part of the course is to make you comfortable with the
Tock kernel and writing code for it. By the end of this part, you'll have
written a new capsule that reads a humidity sensor and outputs its readings
over the serial port.</p>
<p>During this you will:</p>
<ol>
<li>Learn how Tock uses Rust's memory safety to provide isolation for free</li>
<li>Read the Tock boot sequence, seeing how Tock uses static allocation</li>
<li>Learn about Tock's event-driven programming</li>
<li>Write a new capsule that reads a humidity sensor and prints it over serial</li>
</ol>
<h2 id="read-the-tock-boot-sequence-20m"><a class="header" href="#read-the-tock-boot-sequence-20m">Read the Tock boot sequence (20m)</a></h2>
<p>Open <code>imix/src/main.rs</code> in your favorite editor. This file defines the
imix platform: how it boots, what capsules it uses, and what system calls it
supports for userland applications.</p>
<h3 id="how-is-everything-organized"><a class="header" href="#how-is-everything-organized">How is everything organized?</a></h3>
<p>Find the declaration of <code>struct Imix</code> (it's pretty early in the file).
This declares the structure representing the platform. It has many fields,
all of which are capsules. These are the capsules that make up the imix
platform. For the most part, these map directly to hardware peripherals,
but there are exceptions such as <code>IPC</code> (inter-process communication).</p>
<p>Recall the discussion about how everything in the kernel is statically
allocated? We can see that here. Every field in <code>struct Imix</code> is a reference to
an object with a static lifetime.</p>
<p>The capsules themselves take a lifetime as a parameter, which is currently
always <code> `static</code>.  The implementations of these capsules, however, do not
rely on this assumption.</p>
<p>The boot process is primarily the construction of this <code>Imix</code> structure. Once
everything is set up, the board will pass the constructed <code>imix</code> to
<code>kernel::kernel_loop</code> and we're off to the races.</p>
<h3 id="how-do-things-get-started"><a class="header" href="#how-do-things-get-started">How do things get started?</a></h3>
<p>The method <code>reset_handler</code> is invoked when the chip resets (i.e., boots).
It's pretty long because imix has a lot of drivers that need to be created
and initialized, and many of them depend on other, lower layer abstractions
that need to be created and initialized as well.</p>
<p>Take a look at the first few lines of the <code>reset_handler</code>. The boot sequence
initializes memory (copies initialized variables into RAM, clears the BSS),
sets up the system clocks, and configures the GPIO pins.</p>
<h3 id="how-do-capsules-get-created"><a class="header" href="#how-do-capsules-get-created">How do capsules get created?</a></h3>
<p>The next lines of <code>reset_handler</code> create and initialize the system console,
which is what turns calls to <code>println</code> into bytes sent to the USB serial port:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let uart_mux = static_init!(
    MuxUart&lt;'static&gt;,
    MuxUart::new(
        &amp;sam4l::usart::USART3,
        &amp;mut capsules::virtual_uart::RX_BUF,
        115200
    )
);
uart_mux.initialize();

hil::uart::Transmit::set_transmit_client(&amp;sam4l::usart::USART3, uart_mux);
hil::uart::Receive::set_receive_client(&amp;sam4l::usart::USART3, uart_mux);

let console = ConsoleComponent::new(board_kernel, uart_mux).finalize();
<span class="boring">}
</span></code></pre></pre>
<p>Eventually, once all of the capsules have been created, we will populate
a imix structure with them:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let imix = Imix {
    console: console,
    gpio: gpio,
    ...
<span class="boring">}
</span></code></pre></pre>
<p>The <code>static_init!</code> macro is simply an easy way to allocate a static
variable with a call to <code>new</code>. The first parameter is the type, the second
is the expression to produce an instance of the type. This call creates
a <code>Console</code> that uses serial port 3 (<code>USART3</code>) at 115200 bits per second.</p>
<blockquote>
<h4 id="a-brief-aside-on-buffers"><a class="header" href="#a-brief-aside-on-buffers">A brief aside on buffers:</a></h4>
<p>Notice that you have to pass a write buffer to the console for it to use:
this buffer has to have a <code> `static</code> lifetime. This is because low-level
hardware drivers, especially those that use DMA, require <code> `static</code> buffers.
Since Tock doesn't promise when a DMA operation will complete, and you
need to be able to promise that the buffer outlives the operation, the
one lifetime that is assured to be alive at the end of an operation is
<code> `static</code>. So that other code which has buffers
without a <code> `static</code> lifetime, such as userspace processes, can use the
<code>Console</code>, it copies them into its own internal <code> `static</code> buffer before
passing it to the serial port. So the buffer passing architecture looks like
this:</p>
<p><img src="../imgs/console.svg" alt="Console/UART buffer lifetimes" /></p>
<p>It's a little weird that Console's <code>new</code> method takes in a reference to
itself. This is an ergonomics tradeoff. The Console needs a mutable static
buffer to use internally, which the Console capsule declares. However writing
global statics is unsafe. To avoid the unsafe operation in the Console
capsule itself, we make it the responsibility of the instantiator to give the
Console a buffer to use, without burdening the instantiator with sizing the
buffer.</p>
</blockquote>
<h3 id="lets-make-an-imix"><a class="header" href="#lets-make-an-imix">Let's make an imix!</a></h3>
<p>The code continues on, creating all of the other capsules that are needed
by the imix platform. By the time we get down to around line 360, we've
created all of the capsules we need, and it's time to create the actual
imix platform structure (<code>let imix = Imix {...}</code>).</p>
<h3 id="capsule-initialization"><a class="header" href="#capsule-initialization">Capsule <em>initialization</em></a></h3>
<p>Up to this point we have been creating numerous structures and setting some
static configuration options and mappings, but nothing dynamic has occurred
(said another way, all methods invoked by <code>static_init!</code> must be <code>const fn</code>,
however Tock's <code>static_init!</code> macro predates stabilization of <code>const fn</code>'s.
A future iteration could possibly leverage these and obviate the need for the
macro).</p>
<p>Some capsules require <em>initialization</em>, some code that must be executed
before they can be used. For example, a few lines after creating the imix
struct, we initialize the console:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>imix.nrf51822.initialize();
<span class="boring">}
</span></code></pre></pre>
<p>This method is responsible for actually writing the hardware registers that
configure the associated UART peripheral for use as a text console
(8 data bits, 1 stop bit, no parity bit, no hardware flow control).</p>
<h3 id="inter-capsule-dependencies"><a class="header" href="#inter-capsule-dependencies">Inter-capsule dependencies</a></h3>
<p>Just after initializing the console capsule, we find this line:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>kernel::debug::assign_console_driver(Some(imix.console), kc);
<span class="boring">}
</span></code></pre></pre>
<p>This configures the kernel's <code>debug!</code> macro to print messages to this console
we've just created. The <code>debug!</code> mechanism can be very helpful during
development and testing. Today we're going to use it to print output from the
capsule you create.</p>
<p>Let's try it out really quick:</p>
<pre><code class="language-diff">--- a/boards/imix/src/main.rs
+++ b/boards/imix/src/main.rs
@@ -10,7 +10,7 @@
 extern crate capsules;
 extern crate cortexm4;
 extern crate compiler_builtins;
-#[macro_use(static_init)]
+#[macro_use(debug, static_init)]
 extern crate kernel;
 extern crate sam4l;

@@ -388,6 +388,8 @@ pub unsafe fn reset_handler() {
         capsules::console::App::default());
     kernel::debug::assign_console_driver(Some(imix.console), kc);

+    debug!(&quot;Testing 1, 2, 3...&quot;);
+
     imix.nrf51822.initialize();
</code></pre>
<p>Compile and flash the kernel (<code>make program</code>) then look at the output
(<code>tockloader listen</code>).</p>
<ul>
<li>What happens if you put the <code>debug!</code> before <code>assign_console_driver</code>?</li>
<li>What happens if you put <code>imix.console.initialize()</code> after
<code>assign_console_driver</code>?</li>
</ul>
<p>As you can see, sometimes there are dependencies between capsules, and board
authors must take care during initialization to ensure correctness.</p>
<blockquote>
<p><strong>Note:</strong> The <code>debug!</code> implementation is <em>asynchronous</em>. It copies messages
into a buffer and the console prints them via DMA as the UART peripheral is
available, interleaved with other console users (i.e. processes). You
shouldn't need to worry about the mechanics of this for now.</p>
</blockquote>
<h3 id="loading-processes"><a class="header" href="#loading-processes">Loading processes</a></h3>
<p>Once the platform is all set up, the board is responsible for loading processes
into memory:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>kernel::process::load_processes(&amp;_sapps as *const u8,
                                &amp;mut APP_MEMORY,
                                &amp;mut PROCESSES,
                                FAULT_RESPONSE);
<span class="boring">}
</span></code></pre></pre>
<p>A Tock process is represented by a <code>kernel::Process</code> struct. In principle, a
platform could load processes by any means. In practice, all existing platforms
write an array of Tock Binary Format (TBF) entries to flash. The kernel provides
the <code>load_processes</code> helper function that takes in a flash address and begins
iteratively parsing TBF entries and making <code>Process</code>es.</p>
<h3 id="starting-the-kernel"><a class="header" href="#starting-the-kernel">Starting the kernel</a></h3>
<p>Finally, the board passes a reference to the current platform, the chip the
platform is built on (used for interrupt and power handling), the processes to
run, and an IPC server instance to the main loop of the kernel:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>kernel::main(&amp;imix, &amp;mut chip, &amp;mut PROCESSES, &amp;imix.ipc);
<span class="boring">}
</span></code></pre></pre>
<p>From here, Tock is initialized, the kernel event loop takes over, and the
system enters steady state operation.</p>
<h3 id="create-a-hello-world-capsule"><a class="header" href="#create-a-hello-world-capsule">Create a &quot;Hello World&quot; capsule</a></h3>
<p>Now that you've seen how Tock initializes and uses capsules, you're going to
write a new one. At the end of this section, your capsule will sample the
humidity sensor once a second and print the results as serial output. But
you'll start with something simpler: printing &quot;Hello World&quot; to the debug
console once on boot.</p>
<p>The <code>imix</code> board configuration you've looked through has a capsule for the this
tutorial already set up. The capsule is a separate Rust crate located in
<code>exercises/capsule</code>. You'll complete this exercise by filling it in.</p>
<p>In addition to a constructor, Our capsule has <code>start</code> function defined that is
currently empty. The board configuration calls this function once it has
initialized the capsule.</p>
<p>Eventually, the <code>start</code> method will kick off a state machine for periodic
humidity readings, but for now, let's just print something to the debug console
and return:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>debug!(&quot;Hello from the kernel!&quot;);
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ cd [PATH_TO_BOOK]/imix
$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Hello from the kernel!
</code></pre>
<h2 id="extend-your-capsule-to-print-hello-world-every-second"><a class="header" href="#extend-your-capsule-to-print-hello-world-every-second">Extend your capsule to print &quot;Hello World&quot; every second</a></h2>
<p>In order for your capsule to keep track of time, it will need to depend on
another capsule that implements the Alarm interface. We'll have to do something
similar for reading the accelerometer, so this is good practice.</p>
<p>The Alarm HIL includes several traits, <code>Alarm</code>, <code>Client</code>, and <code>Frequency</code>, all
in the <code>kernel::hil::time</code> module. You'll use the <code>set_alarm</code> and <code>now</code> methods
from the <code>Alarm</code> trait to set an alarm for a particular value of the clock.
Note that both methods accept arguments in the alarm's native clock frequency,
which is available using the Alarm trait's associated <code>Frequency</code> type:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// native clock frequency in Herz
let frequency = &lt;A::Frequency&gt;::frequency();
<span class="boring">}
</span></code></pre></pre>
<p>Your capsule already implements the <code>alarm::Client</code> trait so it can receive
alarm events. The <code>alarm::Client</code> trait has a single method:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn fired(&amp;self)
<span class="boring">}
</span></code></pre></pre>
<p>Your capsule should now set an alarm in the <code>start</code> method, print the debug
message and set an alarm again when the alarm fires.</p>
<p>Compile and program your new kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
</code></pre>
<p><a href="https://gist.github.com/alevy/73fca7b0dddcb5449088cebcbfc035f1">Sample Solution</a></p>
<h2 id="extend-your-capsule-to-sample-the-humidity-once-a-second"><a class="header" href="#extend-your-capsule-to-sample-the-humidity-once-a-second">Extend your capsule to sample the humidity once a second</a></h2>
<p>The steps for reading an accelerometer from your capsule are similar to using
the alarm. You'll use a capsule that implements the humidity HIL, which
includes the <code>HumidityDriver</code> and <code>HumidityClient</code> traits, both in
<code>kernel::hil::sensors</code>.</p>
<p>The <code>HumidityDriver</code> trait includes the method <code>read_accelerometer</code> which
initiates an accelerometer reading. The <code>HumidityClient</code> trait has a single
method for receiving readings:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn callback(&amp;self, humidity: usize);
<span class="boring">}
</span></code></pre></pre>
<p>Implement logic to initiate a accelerometer reading every second and report the
results.</p>
<p><img src="../imgs/rustconf.svg" alt="Structure of rustconf capsule" /></p>
<p>Compile and program your kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Humidity 2731
Humidity 2732
</code></pre>
<p><a href="https://gist.github.com/alevy/798d11dbfa5409e0aa56d870b4b7afcf">Sample solution</a></p>
<h2 id="some-further-questions-and-directions-to-explore"><a class="header" href="#some-further-questions-and-directions-to-explore">Some further questions and directions to explore</a></h2>
<p>Your capsule used the si7021 and virtual alarm. Take a look at the
code behind each of these services:</p>
<ol>
<li>
<p>Is the humidity sensor on-chip or a separate chip connected over a bus?</p>
</li>
<li>
<p>What happens if you request two humidity sensors back-to-back?</p>
</li>
<li>
<p>Is there a limit on how many virtual alarms can be created?</p>
</li>
<li>
<p>How many virtual alarms does the imix boot sequence create?</p>
</li>
</ol>
<h3 id="extra-credit-write-a-virtualization-capsule-for-humidity-sensor-"><a class="header" href="#extra-credit-write-a-virtualization-capsule-for-humidity-sensor-"><strong>Extra credit</strong>: Write a virtualization capsule for humidity sensor (∞)</a></h3>
<p>If you have extra time, try writing a virtualization capsule for the <code>Humidity</code>
HIL that will allow multiple clients to use it. This is a fairly open ended
task, but you might find inspiration in the <code>virtua_alarm</code> and <code>virtual_i2c</code>
capsules.</p>
<h1 id="graduation"><a class="header" href="#graduation">Graduation</a></h1>
<p>Now that you have the basics of Tock down, we encourage you to continue to
explore and develop with Tock! This book includes a &quot;slimmed down&quot; version of
Tock to make it easy to get started, but you will likely want to get a more
complete development environment setup to continue. Luckily, this shouldn't be
too difficult since you have the tools installed already.</p>
<h2 id="using-the-latest-kernel"><a class="header" href="#using-the-latest-kernel">Using the latest kernel</a></h2>
<p>The Tock kernel is actively developed, and you likely want to build upon the
latest features. To do this, you should get the Tock source from the repository:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/tock
</code></pre>
<p>While the <code>master</code> branch tends to be relatively stable, you may want to use the
latest <a href="https://github.com/tock/tock/releases">release</a> instead. Tock is
thoroughly tested before a release, so this should be a reliable place to start.
To select a release, you should checkout the correct tag. For example, for the
1.4 release this looks like:</p>
<pre><code class="language-bash">$ cd tock
$ git checkout release-1.4
</code></pre>
<p>You should use the latest release. Check the <a href="https://github.com/tock/tock/releases">releases
page</a> for the name of the latest release.</p>
<p>Now, you can compile the board-specific kernel in the Tock repository. For
example, to compile the kernel for imix:</p>
<pre><code class="language-bash">$ cd boards/imix
$ make
</code></pre>
<p>All of the operations described in the course should work the same way on the
main repository.</p>
<h2 id="using-the-full-selection-of-apps"><a class="header" href="#using-the-full-selection-of-apps">Using the full selection of apps</a></h2>
<p>The book includes some very minimal apps, and many more can be found in the
<code>libtock-c</code> repository. To use this, you should start by cloning the repository:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/libtock-c
</code></pre>
<p>Now you can compile and run apps inside of the examples folder. For instance,
you can install the basic &quot;Hello World!&quot; app:</p>
<pre><code class="language-bash">$ cd libtock-c/examples/c_hello
$ make
$ tockloader install
</code></pre>
<p>With the <code>libtock-c</code> repository you have access to the full suite of Tock apps,
and additional libraries include BLE and Lua support.</p>
<h1 id="tock-mini-tutorials-1"><a class="header" href="#tock-mini-tutorials-1">Tock Mini Tutorials</a></h1>
<p>These tutorials walk through how to use some various features of Tock. They are
narrower in scope than the course, but try to explain in detail how various Tock
apps work.</p>
<p>You will need the <code>libtock-c</code> repository to run these tutorials. You should
check out a copy of <code>libtock-c</code> by running:</p>
<pre><code>$ git clone https://github.com/tock/libtock-c
</code></pre>
<p><code>libtock-c</code> contains many example Tock applications as well as the library
support code for running C and C++ apps on Tock. If you are looking to develop
Tock applications you will likely want to start with an existing app in
<code>libtock-c</code> and modify it.</p>
<h2 id="setup"><a class="header" href="#setup">Setup</a></h2>
<p>You need to be able to compile and load the Tock kernel and Tock applications.
See the <a href="tutorials/../prerequisites.html">prerequisites guide</a> on how to get setup.</p>
<p>You also need <a href="https://tockos.org/hardware">hardware</a> that supports Tock.</p>
<p>The tutorials assume you have a Tock kernel loaded on your hardware board. To
get a kernel installed, follow these steps.</p>
<ol>
<li>
<p><strong>Obtain the Tock Source</strong>. You can clone a copy of the Tock repository to
get the kernel source:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/tock
$ cd tock
</code></pre>
</li>
<li>
<p><strong>Compile Tock</strong>. In the root of the Tock directory, compile the kernel for
your hardware platform. You can find a list of boards by running <code>make list</code>.
For example if your board is <code>imix</code> then:</p>
<pre><code class="language-bash">$ make list
$ cd boards/imix
$ make
</code></pre>
<p>If you have another board just replace &quot;imix&quot; with <code>&lt;your-board&gt;</code></p>
<p>This will create binaries of the Tock kernel. Tock is compiled with Cargo, a
package manager for Rust applications. The first time Tock is built all of
the crates must be compiled. On subsequent builds, crates that haven't
changed will not have to be rebuilt and the compilation will be faster.</p>
</li>
<li>
<p><strong>Load the Tock Kernel</strong>. The next step is to program the Tock kernel onto
your hardware. Generally, two options are supported for loading the kernel:
<code>make program</code> and <code>make flash</code>. You should likely try <code>make program</code> first.
Alternatively, the README file for the board should show which options are
available. To load the kernel, run:</p>
<pre><code class="language-bash">$ make program  # Load code via bootloader
  -- or --      # Check the README in your board folder
$ make flash    # Load code via jtag
</code></pre>
<p>in the board directory. Now you have the kernel loaded onto the hardware.
The kernel configures the hardware and provides drivers for many hardware
resources, but does not actually include any application logic. For that, we
need to load an application.</p>
<p>Note, you only need to program the kernel once. Loading applications does
not alter the kernel, and applications can be re-programed without
re-programming the kernel.</p>
</li>
</ol>
<p>With the kernel setup, you are ready to try the mini tutorials.</p>
<h2 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h2>
<ol>
<li><strong><a href="tutorials/01_running_blink.html">Blink an LED</a></strong>: Get your first Tock app running.</li>
<li><strong><a href="tutorials/02_button_print.html">Button to Printf()</a></strong>: Print to terminal in response
to button presses.</li>
<li><strong><a href="tutorials/03_ble_scan.html">BLE Advertisement Scanning</a></strong>: Sense nearby BLE packets.</li>
<li><strong><a href="tutorials/04_sensors_and_drivers.html">Sample Sensors and Use Drivers</a></strong>: Use syscalls
to interact with kernel drivers.</li>
<li><strong><a href="tutorials/05_ipc.html">Inter-process Communication</a></strong>: Tock's IPC mechanism.</li>
</ol>
<h3 id="board-compatiblity-matrix"><a class="header" href="#board-compatiblity-matrix">Board compatiblity matrix</a></h3>
<table><thead><tr><th>Tutorial #</th><th>Supported boards</th></tr></thead><tbody>
<tr><td>1</td><td>All</td></tr>
<tr><td>2</td><td>All Cortex-M based boards</td></tr>
<tr><td>3</td><td>Hail and imix</td></tr>
<tr><td>4</td><td>Hail and imix</td></tr>
<tr><td>5</td><td>All that support IPC</td></tr>
</tbody></table>
<h1 id="blink-running-your-first-app"><a class="header" href="#blink-running-your-first-app">Blink: Running Your First App</a></h1>
<p>This guide will help you get the <code>blink</code> app running on top of Tock kernel.</p>
<h2 id="instructions"><a class="header" href="#instructions">Instructions</a></h2>
<ol>
<li>
<p><strong>Erase any existing applications</strong>. First, we need to remove any applications already
on the board. Note that Tockloader by default will install any application in
addition to whatever is already installed on the board.</p>
<pre><code class="language-bash">$ tockloader erase-apps
</code></pre>
</li>
<li>
<p><strong>Install Blink</strong>. Tock supports an &quot;app store&quot; of sorts. That is, tockloader
can install apps from a remote repository, including Blink. To do this:</p>
<pre><code class="language-bash">$ tockloader install blink
</code></pre>
<p>You will have to tell Tockloader that you are OK with fetching the app from
the Internet.</p>
<p>Your specific board may require additional arguments, please see the readme
in the <code>boards/</code> folder for more details.</p>
</li>
<li>
<p><strong>Compile and Install Blink</strong>. We can also compile the blink app and load our
compiled version. The basic C version of blink is located in the
<a href="https://github.com/tock/libtock-c">libtock-c</a> repository.</p>
<ol>
<li>
<p>Clone that repository:</p>
<pre><code class="language-bash">$ cd tock-book
$ git clone https://github.com/tock/libtock-c
</code></pre>
</li>
<li>
<p>Then navigate to <code>examples/blink</code>:</p>
<pre><code class="language-bash">$ cd libtock-c/examples/blink
</code></pre>
</li>
<li>
<p>From there, you should be able to compile it and install it by:</p>
<pre><code class="language-bash">$ make
$ tockloader install
</code></pre>
</li>
</ol>
<p>When the blink app is installed you should see the LEDs on the board
blinking. Congratulations! You have just programmed your first Tock
application.</p>
</li>
</ol>
<h1 id="say-hello-on-every-button-press"><a class="header" href="#say-hello-on-every-button-press">Say &quot;Hello!&quot; On Every Button Press</a></h1>
<p>This tutorial will walk you through calling <code>printf()</code> in response to a
button press.</p>
<ol>
<li>
<p><strong>Start a new application</strong>. A Tock application in C looks like a typical C
application. Lets start with the basics:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
  return 0;
}
</code></pre>
<p>You also need a makefile. Copying a makefile from an existing app is
the easiest way to get started.</p>
</li>
<li>
<p><strong>Setup a button callback handler</strong>. A button press in Tock is treated as an
interrupt, and in an application this translates to a function being called,
much like in any other event-driven system. To listen for button presses, we
first need to define a callback function, then tell the kernel that the
callback exists.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
}

int main(void) {
  button_subscribe(button_callback, NULL);

  return 0;
}
</code></pre>
<p>All callbacks from the kernel are passed four arguments, and the meaning of
the four arguments depends on the driver. The first three are integers,
and can be used to represent buffer lengths, pin numbers, button numbers,
and other simple data. The fourth argument is a pointer to user defined
object. This pointer is set in the subscribe call (in this example
it is set to <code>NULL</code>), and returned when the callback fires.</p>
</li>
<li>
<p><strong>Enable the button interrupts</strong>. By default, the interrupts for the buttons
are not enabled. To enable them, we make a syscall. Buttons, like other
drivers in Tock, follow the convention that applications can ask the kernel
how many there are. This is done by calling <code>button_count()</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
}

int main(void) {
  button_subscribe(button_callback, NULL);

  // Ensure there is a button to use.
  int count = button_count();
  if (count &lt; 1) {
    // There are no buttons on this platform.
    printf(&quot;Error! No buttons on this platform.&quot;);
  } else {
    // Enable an interrupt on the first button.
    button_enable_interrupt(0);
  }

  // Can just return here. The application will continue to execute.
  return 0;
}
</code></pre>
<p>The button count is checked, and the app only continues if there
exists at least one button. To enable the button interrupt,
<code>button_enable_interrupt()</code> is called with the index of the button
to use. In this example we just use the first button.</p>
</li>
<li>
<p><strong>Call <code>printf()</code> on button press</strong>. To print a message, we call <code>printf()</code>
in the callback.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
  // Only print on the down press.
  if (val == 1) {
    printf(&quot;Hello!\n&quot;);
  }
}

int main(void) {
  button_subscribe(button_callback, NULL);

  // Ensure there is a button to use.
  int count = button_count();
  if (count &lt; 1) {
    // There are no buttons on this platform.
    printf(&quot;Error! No buttons on this platform.\n&quot;);
  } else {
    // Enable an interrupt on the first button.
    button_enable_interrupt(0);
  }

  // Can just return here. The application will continue to execute.
  return 0;
}
</code></pre>
</li>
<li>
<p><strong>Run the application</strong>. To try this tutorial application, you can find it in
the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/02_button_print">tutorials app
folder</a>.
See the first tutorial for details on how to compile and install a C
application.</p>
<p>Once installed, when you press the button, you should see &quot;Hello!&quot; printed
to the terminal!</p>
</li>
</ol>
<h1 id="look-a-wild-ble-packet-appeared"><a class="header" href="#look-a-wild-ble-packet-appeared">Look! A Wild BLE Packet Appeared!</a></h1>
<blockquote>
<p>Note! This tutorial will only work on Hail and imix boards.</p>
</blockquote>
<p>This tutorial will walk you through getting an app running that scans
for BLE advertisements. Most BLE devices typically broadcast advertisements
periodically (usually once a second) to allow smartphones and other devices
to discover them. The advertisements typically contain the BLE device's ID
and name, as well as as which services the device provides, and sometimes
raw data as well.</p>
<p>To provide BLE connectivity, several Tock boards use the Nordic nRF51822
as a BLE co-processor. In this configuration, the nRF51822 runs all of
the BLE operations and exposes a command interface over a UART bus. Luckily for
us, Nordic has defined and implemented the entire interface. Better yet, they
made it interoperable with their nRF51 SDK. What this means is any BLE app
that would run on the nRF51822 directly can be compiled to run on a different
microcontroller, and any function calls that would have interacted with
the BLE hardware are instead packaged and sent to the nRF51822 co-processor.
Nordic calls this tool &quot;BLE Serialization&quot;, and Tock has a port of the
serialization libraries that Tock applications can use.</p>
<p>So, with that introduction, lets get going.</p>
<ol>
<li>
<p><strong>Initialize the BLE co-processor</strong>. The first step a BLE serialization app
must do is initialize the BLE stack on the co-processor. This can be done
with Nordic's SDK, but to simplify things Tock supports the <a href="https://github.com/lab11/nrf5x-base/tree/master/lib">Simple
BLE</a> library. The goal
of <code>simple_ble.c</code> is to wrap the details of the nRF5 SDK and the intricacies
of BLE in an easy-to-use library so you can get going with creating BLE
devices and not learning the entire spec.</p>
<pre><code class="language-c">#include &lt;simple_ble.h&gt;

// Intervals for advertising and connections.
// These are some basic settings for BLE devices. However, since we are
// only interesting in scanning, these are not particularly relevant.
simple_ble_config_t ble_config = {
  .platform_id       = 0x00, // used as 4th octet in device BLE address
  .device_id         = DEVICE_ID_DEFAULT,
  .adv_name          = &quot;Tock&quot;,
  .adv_interval      = MSEC_TO_UNITS(500, UNIT_0_625_MS),
  .min_conn_interval = MSEC_TO_UNITS(1000, UNIT_1_25_MS),
  .max_conn_interval = MSEC_TO_UNITS(1250, UNIT_1_25_MS)
};

int main () {
    printf(&quot;[Tutorial] BLE Scanning\n&quot;);

    // Setup BLE.
    simple_ble_init(&amp;ble_config);
}
</code></pre>
</li>
<li>
<p><strong>Scan for advertisements</strong>. With <code>simple_ble</code> this is pretty
straightforward.</p>
<pre><code class="language-c">int main () {
    printf(&quot;[Tutorial] BLE Scanning\n&quot;);

    // Setup BLE.
    simple_ble_init(&amp;ble_config);

    // Scan for advertisements.
    simple_ble_scan_start();
}
</code></pre>
</li>
<li>
<p><strong>Handle the advertisement received event</strong>. Just as the main Tock
microcontroller can send commands to the nRF co-processor, the co-processor
can send events back. When these occur, a variety of callbacks are generated
in <code>simple_ble</code> and then passed to users of the library. In this case, we
only care about <code>ble_evt_adv_report()</code> which is called on each advertisement
reception.</p>
<pre><code class="language-c">// Called when each advertisement is received.
void ble_evt_adv_report (ble_evt_t* p_ble_evt) {
  ble_gap_evt_adv_report_t* adv = (ble_gap_evt_adv_report_t*) &amp;p_ble_evt-&gt;evt.gap_evt.params.adv_report;
}
</code></pre>
<p>The <code>ble_evt_adv_report()</code> function is passed a pointer to a <code>ble_evt_t</code>
struct. This is a type from the Nordic nRF51 SDK, and more information
can be found in the SDK documentation.</p>
</li>
<li>
<p><strong>Display a message for each advertisement</strong>. Once we have the advertisement
callback, we can use <code>printf()</code> like normal.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;led.h&gt;

// Called when each advertisement is received.
void ble_evt_adv_report (ble_evt_t* p_ble_evt) {
  ble_gap_evt_adv_report_t* adv = (ble_gap_evt_adv_report_t*) &amp;p_ble_evt-&gt;evt.gap_evt.params.adv_report;

  // Print some details about the discovered advertisement.
  printf(&quot;Recv Advertisement: [%02x:%02x:%02x:%02x:%02x:%02x] RSSI: %d, Len: %d\n&quot;,
    adv-&gt;peer_addr.addr[5], adv-&gt;peer_addr.addr[4], adv-&gt;peer_addr.addr[3],
    adv-&gt;peer_addr.addr[2], adv-&gt;peer_addr.addr[1], adv-&gt;peer_addr.addr[0],
    adv-&gt;rssi, adv-&gt;dlen);

  // Also toggle the first LED.
  led_toggle(0);
}
</code></pre>
</li>
<li>
<p><strong>Handle some BLE annoyances</strong>. The last step to getting a working app is to
handle some annoyances using BLE serialization with the <code>simple_ble</code> library.
Typically errors generated by the nRF51 SDK are severe and mean there is a
significant bug in the code. With serialization, however, messages between
the two processors can be corrupted or misframed, causing parsing errors. We
can ignore these errors safely and just drop the corrupted packet.</p>
<p>Additionally, the <code>simple_ble</code> library makes it easy to set the address
of a BLE device. However, this functionality only works when running
on an actual nRF51822. To disable this, we override the weakly defined
<code>ble_address_set()</code> function with an empty function.</p>
<pre><code class="language-c">void app_error_fault_handler(uint32_t error_code, uint32_t line_num, uint32_t info) { }
void ble_address_set () { }
</code></pre>
</li>
<li>
<p><strong>Run the app and see the packets!</strong> To try this tutorial application, you
can find it in the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/03_ble_scan">tutorials app
folder</a>.</p>
<p>For any new applications, ensure that the following is in the makefile
so that the BLE serialization library is included.</p>
<pre><code> include $(TOCK_USERLAND_BASE_DIR)/libnrfserialization/Makefile.app
</code></pre>
</li>
</ol>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>This section contains a few notes about the specific versions of BLE
serialization used.</p>
<p>Tock currently supports the S130 softdevice version 2.0.0 and SDK 11.0.0.</p>
<h1 id="reading-sensors-from-scratch"><a class="header" href="#reading-sensors-from-scratch">Reading Sensors From Scratch</a></h1>
<blockquote>
<p>Note! This tutorial will only work on Hail and imix boards.</p>
</blockquote>
<p>In this tutorial we will cover how to use the syscall interface from
applications to kernel drivers, and guide things based on reading the
<a href="http://www.intersil.com/en/products/optoelectronics/ambient-light-sensors/light-to-digital-sensors/ISL29035.html">ISL29035</a>
digital light sensor and printing the readings over UART.</p>
<p>OK, lets get started.</p>
<ol>
<li>
<p><strong>Setup a generic app for handling asynchronous events</strong>. As with most
sensors, the ISL29035 is read asynchronously, and a callback is generated
from the kernel to userspace when the reading is ready. Therefore, to use
this sensor, our application needs to do two things: 1) setup a callback the
kernel driver can call when the reading is ready, and 2) instruct the kernel
driver to start the measurement. Lets first sketch this out:</p>
<pre><code class="language-c">#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {

}

int main() {
    // Tell the kernel about the callback.

    // Instruct the ISL29035 driver to begin a reading.

    // Wait until the reading is complete.

    // Print the resulting value.

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Fill in the application with syscalls</strong>. The standard <a href="tutorials/../Syscalls.html">Tock
syscalls</a> can be used to actually implement the sketch we
made above. We first use the <code>subscribe</code> syscall to inform the kernel about
the callback in our application. We then use the <code>command</code> syscall to start
the measurement. To wait, we use the <code>yield</code> call to wait for the callback to
actually fire. We do not need to use <code>allow</code> for this application, and
typically it is not required for reading sensors.</p>
<p>For all syscalls that interact with drivers, the major number is set by
the platform. In the case of the ISL29035, it is <code>0x60002</code>. The minor numbers
are set by the driver and are specific to the particular driver.</p>
<p>To save the value from the callback to use in the print statement, we will
store it in a global variable.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

static int isl29035_reading;

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {
    // Save the reading when the callback fires.
    isl29035_reading = intensity;
}

int main() {
    // Tell the kernel about the callback.
    subscribe(DRIVER_NUM, 0, isl29035_callback, NULL);

    // Instruct the ISL29035 driver to begin a reading.
    command(DRIVER_NUM, 1, 0);

    // Wait until the reading is complete.
    yield();

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Be smarter about waiting for the callback</strong>. While the above application
works, it's really relying on the fact that we are only sampling a single
sensor. In the current setup, if instead we had two sensors with outstanding
commands, the first callback that fired would trigger the <code>yield()</code> call to
return and then the <code>printf()</code> would execute. If, for example, sampling the
ISL29035 takes 100 ms, and the new sensor only needs 10 ms, the new sensor's
callback would fire first and the <code>printf()</code> would execute with an incorrect
value.</p>
<p>To handle this, we can instead use the <code>yield_for()</code> call, which takes
a flag and only returns when that flag has been set. We can then set this
flag in the callback to make sure that our <code>printf()</code> only occurs when
the light reading has completed.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

static int isl29035_reading;
static bool isl29035_done = false;

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {
    // Save the reading when the callback fires.
    isl29035_reading = intensity;

    // Mark our flag true so that the `yield_for()` returns.
    isl29035_done = true;
}

int main() {
    // Tell the kernel about the callback.
    subscribe(DRIVER_NUM, 0, isl29035_callback, NULL);

    // Instruct the ISL29035 driver to begin a reading.
    command(DRIVER_NUM, 1, 0);

    // Wait until the reading is complete.
    yield_for(&amp;isl29035_done);

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Use the <code>libtock</code> library functions</strong>. Normally, applications don't use the
bare <code>command</code> and <code>subscribe</code> syscalls. Typically, these are wrapped
together into helpful commands inside of <code>libtock</code> and come with a function
that hides the <code>yield_for()</code> to a make a synchronous function which is useful
for developing applications quickly. Lets port the ISL29035 sensing app to
use the Tock Standard Library:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;isl29035.h&gt;

int main() {
    // Take the ISL29035 measurement synchronously.
    int isl29035_reading = isl29035_read_light_intensity();

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Explore more sensors</strong>. This tutorial highlights only one sensor. See the
<a href="https://github.com/tock/libtock-c/tree/master/examples/sensors">sensors</a> app
for a more complete sensing application.</p>
</li>
</ol>
<h1 id="friendly-apps-share-data"><a class="header" href="#friendly-apps-share-data">Friendly Apps Share Data</a></h1>
<p>This tutorial covers how to use Tock's IPC mechanism to allow applications
to communicate and share memory.</p>
<h2 id="tock-ipc-basics"><a class="header" href="#tock-ipc-basics">Tock IPC Basics</a></h2>
<p>IPC in Tock uses a client-server model. Applications can provide a service by
telling the Tock kernel that they provide a service. Each application can only
provide a single service, and that service's name is set to the name of the
application. Other applications can then discover that service and explicitly
share a buffer with the server. Once a client shares a buffer, it can then
notify the server to instruct the server to somehow interact with the shared
buffer. The protocol for what the server should do with the buffer is service
specific and not specified by Tock. Servers can also notify clients, but when
and why servers notify clients is service specific.</p>
<h2 id="example-application"><a class="header" href="#example-application">Example Application</a></h2>
<p>To provide an overview of IPC, we will build an example system consisting of
three apps: a random number service, a LED control service, and a main
application that uses the two services. While simple, this example both
demonstrates the core aspects of the IPC mechanism and should run on any
hardware platform.</p>
<h3 id="led-service"><a class="header" href="#led-service">LED Service</a></h3>
<p>Lets start with the LED service. The goal of this service is to allow other
applications to use the shared buffer as a command message to instruct the
LED service on how to turn on or off the system's LEDs.</p>
<ol>
<li>
<p>We must tell the kernel that our app wishes to provide a service. All that we
have to do is call <code>ipc_register_svc()</code>.</p>
<pre><code class="language-c">#include &quot;ipc.h&quot;

int main(void) {
  ipc_register_svc(ipc_callback, NULL);
  return 0;
}
</code></pre>
</li>
<li>
<p>We also need that callback (<code>ipc_callback</code>) to handle IPC requests from other
applications. This callback will be called when the client app notifies the
service.</p>
<pre><code class="language-c">static void ipc_callback(int pid, int len, int buf, void* ud) {
  // pid: An identifier for the app that notified us.
  // len: How long the buffer is that the client shared with us.
  // buf: Pointer to the shared buffer.
}
</code></pre>
</li>
<li>
<p>Now lets fill in the callback for the LED application. This is a simplified
version for illustration. The full example can be found in the
<code>examples/tutorials</code> folder.</p>
<pre><code class="language-c">#include &quot;led.h&quot;

static void ipc_callback(int pid, int len, int buf, void* ud) {
  uint8_t* buffer = (uint8_t*) buf;

  // First byte is the command, second byte is the LED index to set,
  // and the third byte is whether the LED should be on or off.
  uint8_t command = buffer[0];
  if (command == 1) {
      uint8_t led_id = buffer[1];
      uint8_t led_state = buffer[2] &gt; 0;

      if (led_state == 0) {
        led_off(led_id);
      } else {
        led_on(led_id);
      }

      // Tell the client that we have finished setting the specified LED.
      ipc_notify_client(pid);
      break;
  }
}
</code></pre>
</li>
</ol>
<h3 id="rng-service"><a class="header" href="#rng-service">RNG Service</a></h3>
<p>The RNG service returns the requested number of random bytes in the shared
folder.</p>
<ol>
<li>
<p>Again, register that this service exists.</p>
<pre><code class="language-c">int main(void) {
  ipc_register_svc(ipc_callback, NULL);
  return 0;
}
</code></pre>
</li>
<li>
<p>Also need a callback function for when the client signals the service. The
client specifies how many random bytes it wants by setting the first byte of
the shared buffer before calling notify.</p>
<pre><code class="language-c">#include &lt;rng.h&gt;

static void ipc_callback(int pid, int len, int buf, void* ud) {
  uint8_t* buffer = (uint8_t*) buf;
  uint8_t rng[len];

  uint8_t number_of_bytes = buffer[0];

  // Fill the buffer with random bytes.
  int number_of_bytes_received = rng_sync(rng, len, number_of_bytes);
  memcpy(buffer, rng, number_of_bytes_received);

  // Signal the client that we have the number of random bytes requested.
  ipc_notify_client(pid);
}
</code></pre>
<p>This is again not a complete example but illustrates the key aspects.</p>
</li>
</ol>
<h3 id="main-logic-client-application"><a class="header" href="#main-logic-client-application">Main Logic Client Application</a></h3>
<p>The third application uses the two services to randomly control the LEDs on
the board. This application is not a server but instead is a client of the
two service applications.</p>
<ol>
<li>
<p>When using an IPC service, the first step is to discover the service and
record its identifier. This will allow the application to share memory with
it and notify it. Services are discovered by the name of the application that
provides them. Currently these are set in the application Makefile or by
default based on the folder name of the application. The examples in Tock
commonly use a Java style naming format.</p>
<pre><code class="language-c">int main(void) {
  int led_service = ipc_discover(&quot;org.tockos.tutorials.ipc.led&quot;);
  int rng_service = ipc_discover(&quot;org.tockos.tutorials.ipc.rng&quot;);

  return 0;
}
</code></pre>
<p>If the services requested are valid and exist the return value from
<code> ipc_discover</code> is the identifier of the found service. If the service
cannot be found an error is returned.</p>
</li>
<li>
<p>Next we must share a buffer with each service (the buffer is the only way to
share between processes), and setup a callback that is called when the server
notifies us as a client. Once shared, the kernel will permit both
applications to read/modify that memory.</p>
<pre><code class="language-c">char led_buf[64] __attribute__((aligned(64)));
char rng_buf[64] __attribute__((aligned(64)));

int main(void) {
  int led_service = ipc_discover(&quot;org.tockos.tutorials.ipc.led&quot;);
  int rng_service = ipc_discover(&quot;org.tockos.tutorials.ipc.rng&quot;);

  // Setup IPC for LED service
  ipc_register_client_cb(led_service, ipc_callback, NULL);
  ipc_share(led_service, led_buf, 64);

  // Setup IPC for RNG service
  ipc_register_client_cb(rng_service, ipc_callback, NULL);
  ipc_share(rng_service, rng_buf, 64);

  return 0;
}
</code></pre>
</li>
<li>
<p>We of course need the callback too. For this app we use the <code>yield_for</code>
function to implement the logical synchronously, so all the callback needs to
do is set a flag to signal the end of the <code>yield_for</code>.</p>
<pre><code class="language-c">bool done = false;

static void ipc_callback(int pid, int len, int arg2, void* ud) {
  done = true;
}
</code></pre>
</li>
<li>
<p>Now we use the two services to implement our application.</p>
<pre><code class="language-c">#include &lt;timer.h&gt;

void app() {
  while (1) {
    // Get two random bytes from the RNG service
    done = false;
    rng_buf[0] = 2; // Request two bytes.
    ipc_notify_svc(rng_service);
    yield_for(&amp;done);

    // Control the LEDs based on those two bytes.
    done = false;
    led_buf[0] = 1;                     // Control LED command.
    led_buf[1] = rng_buf[0] % NUM_LEDS; // Choose the LED index.
    led_buf[2] = rng_buf[1] &amp; 0x01;     // On or off.
    ipc_notify_svc(led_service);        // Notify to signal LED service.
    yield_for(&amp;done);

    delay_ms(500);
  }
}
</code></pre>
</li>
</ol>
<h2 id="try-it-out"><a class="header" href="#try-it-out">Try It Out</a></h2>
<p>To test this out, see the complete apps in the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/05_ipc">IPC tutorial
example</a>
folder.</p>
<p>To install all of the apps on a board:</p>
<pre><code>$ cd examples/tutorials/05_ipc
$ tockloader erase-apps
$ pushd led &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
$ pushd rng &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
$ pushd logic &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
</code></pre>
<p>You should see the LEDs randomly turning on and off!</p>
<h1 id="kernel-development-guides"><a class="header" href="#kernel-development-guides">Kernel Development Guides</a></h1>
<p>These guides provide walkthroughs for specific kernel development tasks. For
example, there is a guide on how to add a new syscall interface for userspace
applications. The guides are intended to be general and provide high-level
instructions which will have to be adapted for the specific functionality to be
added.</p>
<p>Overtime, these guides will inevitably become out-of-date in that the specific
code examples will fail to compile. However, the general design aspects and
considerations should still be relevant even if the specific code details have
changed. You are encourage to use these guides as just that, a general guide,
and to copy from up-to-date examples contained in the Tock repository.</p>
<h1 id="implementing-a-chip-peripheral-driver"><a class="header" href="#implementing-a-chip-peripheral-driver">Implementing a Chip Peripheral Driver</a></h1>
<p>This guide covers how to implement a peripheral driver for a particular
microcontroller (MCU). For example, if you wanted to add an analog to digital
converter (ADC) driver for the Nordic nRF52840 MCU, you would follow the general
steps described in this guide.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The general steps you will follow are:</p>
<ol>
<li>Determine the HIL you will implement.</li>
<li>Create a register mapping for the peripheral.</li>
<li>Create a struct for the peripheral.</li>
<li>Implement the HIL interface for the peripheral.</li>
<li>Create the peripheral driver object and cast the registers to the correct
memory location.</li>
</ol>
<p>The guide will walk through how to do each of these steps.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>Implementing a chip peripheral driver increases Tock's support for a particular
microcontroller and allows capsules and userspace apps to take more advantage of
the hardware provided by the MCU. Peripheral drivers for an MCU are generally
implemented on an as-needed basis to support a particular use case, and as such
the chips in Tock generally do not have all of the peripheral drivers
implemented already.</p>
<p>Peripheral drivers are included in Tock as &quot;trusted code&quot; in the kernel. This
means that they can use the <code>unsafe</code> keyword (in fact, they must). However, it
also means more care must be taken to ensure they are correct. The use of
<code>unsafe</code> should be kept to an absolute minimum and only used where absolutely
necessary. This guide explains the one use of <code>unsafe</code> that is required. All
other uses of <code>unsafe</code> in a peripheral driver will likely be very scrutinized
during the pull request review period.</p>
<h2 id="step-by-step-guide"><a class="header" href="#step-by-step-guide">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Determine the HIL you will implement.</strong></p>
<p>The HILs in Tock are the contract between the MCU-specific hardware and the
more generic capsules which use the hardware resources. They provide a
common interface that is consistent between different microcontrollers,
enabling code higher in the stack to use the interfaces without needing to
know any details about the underlying hardware. This common interface also
allows the same higher-level code to be portable across different
microcontrollers. HILs are implemented as
<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">traits</a> in Rust.</p>
<p>All HILs are defined in the <code>kernel/src/hil</code> directory. You should find a
HIL that exposes the interface the peripheral you are writing a driver for
can provide. There should only be one HIL that matches your peripheral.</p>
<blockquote>
<p>Note: As of Dec 2019, the <code>hil</code> directory also contains interfaces that
are only provided by capsules for other capsules. For example, the ambient
light HIL interface is likely not something an MCU would implement.</p>
</blockquote>
<p>It is possible Tock does not currently include a HIL that matches the
peripheral you are implementing a driver for. In that case you will also
need to create a HIL, which is explained in a different development guide.</p>
<p><strong>Checkpoint</strong>: You have identified the HIL your driver will implement.</p>
</li>
<li>
<p><strong>Create a register mapping for the peripheral.</strong></p>
<p>To start implementing the peripheral driver, you must create a new source
file within the MCU-specific directory inside of <code>chips/src</code> directory. The
name of this file generally should match the name of the peripheral in the
the MCU's datasheet.</p>
<p>Include the name of this file inside of the <code>lib.rs</code> (or potentially
<code>mod.rs</code>) file inside the same directory. This should look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod ast;
<span class="boring">}
</span></code></pre></pre>
<p>Inside of the new file, you will first need to define the memory-mapped
input/output (MMIO) registers that correspond to the peripheral. Different
embedded code ecosystems have devised different methods for doing this, and
Tock is no different. Tock has a special library and set of Rust macros to
make defining the register map straightforward and using the registers
intuitive.</p>
<p>The full register library is
<a href="https://github.com/tock/tock/tree/master/libraries/tock-register-interface">here</a>,
but to get started, you will first create a structure like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tock_registers::registers::{ReadOnly, ReadWrite, WriteOnly};

register_structs! {
    XyzPeripheralRegisters {
        /// Control register.
        /// The 'Control' parameter constrains this register to only use
        /// fields from a certain group (defined below in the bitfields
        /// section).
        (0x000 =&gt; cr: ReadWrite&lt;u32, Control::Register&gt;),
        // Status register.
        (0x004 =&gt; s: ReadOnly&lt;u8, Status::Register&gt;),
        /// spacing between registers in memory
        (0x008 =&gt; _reserved),
        /// Another register with no meaningful fields.
        (0x014 =&gt; word: ReadWrite&lt;u32&gt;),

        // Etc.

        // The end of the struct is marked as follows.
        (0x100 =&gt; @END),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You should replace <code>XyzPeripheral</code> with the name of the peripheral you are
writing a driver for. Then, for each register defined in the datasheet, you
must specify an entry in the macro. For example, a register is defined like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>(0x000 =&gt; cr: ReadWrite&lt;u32, Control::Register&gt;),
<span class="boring">}
</span></code></pre></pre>
<p>where:</p>
<ul>
<li><code>0x000</code> is the offset (in bytes) of the register from the beginning of the
register map.</li>
<li><code>cr</code> is the name of the register in the datasheet.</li>
<li><code>ReadWrite</code> is the access control of the register as defined in the
datasheet.</li>
<li><code>u32</code> is the size of the register.</li>
<li><code>Control::Register</code> maps to the actual bitfields used in the register. You
will create this type for this particular peripheral, so you can name this
whatever makes sense at this point. Note that it will always end with
<code>::Register</code> due to how Rust macros work. If it doesn't make sense to
define the specific bitfields in this register, you can omit this field.
For example, an esoteric field in the register map that the implementation
does not use likely does not need its bitfields mapped.</li>
</ul>
<p>Once the register map is defined, you must specify the bitfields for any
registers that you gave a specific type to. This looks like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>register_bitfields! [
    // First parameter is the register width for the bitfields. Can be u8,
    // u16, u32, or u64.
    u32,

    // Each subsequent parameter is a register abbreviation, its descriptive
    // name, and its associated bitfields. The descriptive name defines this
    // 'group' of bitfields. Only registers defined as
    // ReadWrite&lt;_, Control::Register&gt; can use these bitfields.
    Control [
        // Bitfields are defined as:
        // name OFFSET(shift) NUMBITS(num) [ /* optional values */ ]

        // This is a two-bit field which includes bits 4 and 5
        RANGE OFFSET(4) NUMBITS(3) [
            // Each of these defines a name for a value that the bitfield
            // can be written with or matched against. Note that this set is
            // not exclusive--the field can still be written with arbitrary
            // constants.
            VeryHigh = 0,
            High = 1,
            Low = 2
        ],

        // A common case is single-bit bitfields, which usually just mean
        // 'enable' or 'disable' something.
        EN  OFFSET(3) NUMBITS(1) [],
        INT OFFSET(2) NUMBITS(1) []
    ],

    // Another example:
    // Status register
    Status [
        TXCOMPLETE  OFFSET(0) NUMBITS(1) [],
        TXINTERRUPT OFFSET(1) NUMBITS(1) [],
        RXCOMPLETE  OFFSET(2) NUMBITS(1) [],
        RXINTERRUPT OFFSET(3) NUMBITS(1) [],
        MODE        OFFSET(4) NUMBITS(3) [
            FullDuplex = 0,
            HalfDuplex = 1,
            Loopback = 2,
            Disabled = 3
        ],
        ERRORCOUNT OFFSET(6) NUMBITS(3) []
    ],
]
<span class="boring">}
</span></code></pre></pre>
<p>The name in each entry of the <code>register_bitfields! []</code> list must match the
register type provided in the register map declaration. Each register that
is used in the driver implementation should have its bitfields declared.</p>
<p><strong>Checkpoint</strong>: The register map is correctly described in the driver source
file.</p>
</li>
<li>
<p><strong>Create a struct for the peripheral.</strong></p>
<p>Each peripheral driver is implemented with a struct which is later used to
create an object that can be passed to code that will use this peripheral
driver. The actual fields of the struct are very peripheral specific, but
should contain any state that the driver needs to correctly function.</p>
<p>An example struct looks for a timer peripheral called the AST by the MCU
datasheet looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ast&lt;'a&gt; {
    registers: StaticRef&lt;AstRegisters&gt;,
    callback: OptionalCell&lt;&amp;'a dyn hil::time::AlarmClient&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The struct should contain a reference to the registers defined above (we
will explain the <code>StaticRef</code> later). Typically, many drivers respond to
certain events (like in this case a timer firing) and therefore need a
reference to a client to notify when that event occurs. Notice that the type
of the callback handler is specified in the HIL interface.</p>
<p>Peripheral structs typically need a lifetime for references like the
callback client reference. By convention Tock peripheral structs use <code>'a</code>
for this lifetime, and you likely want to copy that as well.</p>
<p>Think of what state your driver might need to keep around. This could
include a direct memory access (DMA) reference, some configuration flags
like the baud rate, or buffer indices. See other Tock peripheral drivers for
more examples.</p>
<blockquote>
<p>Note: you will most likely need to update this struct as you implement the
driver, so to start with this just has to be a best guess.</p>
</blockquote>
<blockquote>
<p>Hint: you should avoid keeping any state in the peripheral driver struct
that is already stored by the hardware itself. For example, if there is an
&quot;enabled&quot; bit in a register, then you do not need an &quot;enabled&quot; flag in the
struct. Replicating this state leads to bugs when those values get out of
sync, and makes it difficult to update the driver in the future.</p>
</blockquote>
<p>Peripheral driver structs make extensive use of different &quot;cell&quot; types to
hold references to various shared state. The general wisdom is that if the
value will ever need to be updated, then it needs to be contained in a cell.
See the Tock cell documentation for more details on the cell types and when
to use which one. In this example, the callback is stored in an
<code>OptionalCell</code>, which can contain a value or not (if the callback is not
set), and can be updated if the callback needs to change.</p>
<p>With the struct defined, you should next create a <code>new()</code> function for that
struct. This will look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ast {
    const fn new(registers: StaticRef&lt;AstRegisters&gt;) -&gt; Ast {
        Ast {
            registers: registers,
            callback: OptionalCell::empty(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Checkpoint</strong>: There is a struct for the peripheral that can be created.</p>
</li>
<li>
<p><strong>Implement the HIL interface for the peripheral.</strong></p>
<p>With the peripheral driver struct created, now the main work begins. You can
now write the actual logic for the peripheral driver that implements the HIL
interface you identified earlier. Implementing the HIL interface is done
just like implementing a trait in Rust. For example, to implement the <code>Time</code>
HIL for the AST:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl hil::time::Time for Ast&lt;'a&gt; {
    type Frequency = Freq16KHz;

    fn now(&amp;self) -&gt; u32 {
        self.get_counter()
    }

    fn max_tics(&amp;self) -&gt; u32 {
        core::u32::MAX
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>You should include all of the functions from the HIL and decide how to
implement them.</p>
<p>Some operations will be shared among multiple HIL functions. These should be
implemented as functions for the original struct. For example, in the <code>Ast</code>
example the HIL function <code>now()</code> uses the <code>get_counter()</code> function. This should be
implemented on the main <code>Ast</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ast {
    const fn new(registers: StaticRef&lt;AstRegisters&gt;) -&gt; Ast {
        Ast {
            registers: registers,
            callback: OptionalCell::empty(),
        }
    }

    fn get_counter(&amp;self) -&gt; u32 {
        let regs = &amp;*self.registers;
        while self.busy() {}
        regs.cv.read(Value::VALUE)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Note the <code>get_counter()</code> function also illustrates how to use the register
reference and the Tock register library. The <a href="https://github.com/tock/tock/tree/master/libraries/tock-register-interface">register
library</a>
includes much more detail on the various register operations enabled by the
library.</p>
<p><strong>Checkpoint</strong>: All of the functions in the HIL interface have MCU
peripheral-specific implementations.</p>
</li>
<li>
<p><strong>Create the peripheral driver object and cast the registers to the correct
memory location.</strong></p>
<p>The last step is to actually create the object so that the peripheral driver
can be used by other code. Start by casting the register map to the correct
memory address where the registers are actually mapped to. For example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use kernel::common::StaticRef;

const AST_BASE: StaticRef&lt;AstRegisters&gt; =
    unsafe { StaticRef::new(0x400F0800 as *const AstRegisters) };
<span class="boring">}
</span></code></pre></pre>
<p><code>StaticRef</code> is a type in Tock designed explicitly for this operation of
casting register maps to the correct location in memory. The <code>0x400F0800</code> is
the address in memory of the start of the registers and this location will
be specified by the datasheet.</p>
<blockquote>
<p>Note that creating the <code>StaticRef</code> requires using the <code>unsafe</code> keyword.
This is because doing this cast is a fundamentally memory-unsafe
operation: this allows whatever is at that address in memory to be
accessed through the register interface (which is exposed as a safe
interface). In the normal case where the correct memory address is
provided there is no concern for system safety as the register interface
faithfully represents the underlying hardware. However, suppose an
incorrect address was used, and that address actually points to live
memory used by the Tock kernel. Now kernel data structures could be
altered through the register interface, and this would violate memory
safety.</p>
</blockquote>
<p>With the address reference created, we can now create the actual driver
object:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub static mut AST: Ast = Ast::new(AST_BASE);
<span class="boring">}
</span></code></pre></pre>
<p>This object will be used by a board's main.rs file to pass, in this case,
the driver for the timer hardware to various capsules and other code that
needs the underlying timer hardware.</p>
</li>
</ol>
<h2 id="wrap-up"><a class="header" href="#wrap-up">Wrap-Up</a></h2>
<p>Congratulations! You have implemented a peripheral driver for a microcontroller
in Tock! We encourage you to submit a pull request to upstream this to the Tock
repository.</p>
<h1 id="implementing-a-sensor-driver"><a class="header" href="#implementing-a-sensor-driver">Implementing a Sensor Driver</a></h1>
<p>This guide describes the steps necessary to implement a capsule in Tock that
interfaces with an external IC, like a sensor, memory chip, or display. These
are devices which are not part of the same chip as the main microcontroller
(MCU), but are on the same board and connected via some physical connection.</p>
<blockquote>
<p>Note: to attempt to be generic, this guide will use the term &quot;IC&quot; to refer to
the device the driver is for.</p>
</blockquote>
<blockquote>
<p>Note: &quot;driver&quot; is a bit of an overloaded term in Tock. In this guide, &quot;driver&quot;
is used in the generic sense to mean code that interfaces with the external
IC.</p>
</blockquote>
<p>To illustrate the steps, this guide will use a generic light sensor as the
running example. You will need to adapt the generic steps for your particular
use case.</p>
<p>Often the goal of an IC driver is to expose an interface to that sensor or other
IC to userspace applications. This guide does not cover creating that userspace
interface as that is covered in a different guide.</p>
<h2 id="background-1"><a class="header" href="#background-1">Background</a></h2>
<p>As mentioned, this guide describes creating a capsule. Capsules in Tock are
units of Rust code that extend the kernel to add interesting features, like
interfacing with new sensors. Capsules are &quot;untrusted&quot;, meaning they cannot call
unsafe code in Rust and cannot use the <code>unsafe</code> keyword.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Create a struct for the IC driver.</li>
<li>Implement the logic to interface with the IC.</li>
</ol>
<p>Optional:</p>
<ol>
<li>Provide a HIL interface for the IC driver.</li>
<li>Provide a userspace interface for the IC driver.</li>
</ol>
<h2 id="step-by-step-guide-1"><a class="header" href="#step-by-step-guide-1">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Create a struct for the IC driver.</strong></p>
<p>The driver will be implemented as a capsule, so the first step is to create
a new file in the <code>capsules/src</code> directory. The name of this file should be
<code>[chipname].rs</code> where <code>[chipname]</code> is the part number of the IC you are
writing the driver for. There are several other examples in the capsules
folder.</p>
<p>For our example we will assume the part number is <code>ls1234</code>.</p>
<p>You then need to add the filename to <code>capsules/src/lib.rs</code> like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod ls1234;
<span class="boring">}
</span></code></pre></pre>
<p>Now inside of the new file you should create a struct with the fields
necessary to implement the driver for the IC. In our example we will assume
the IC is connected to the MCU with an I2C bus. Your IC might use SPI, UART,
or some other standard interface. You will need to adjust how you create the
struct based on the interface. You should be able to find examples in the
capsules directory to copy from.</p>
<p>The struct will look something like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Ls1234 {
    i2c: &amp;'a dyn I2CDevice,
    state: Cell&lt;State&gt;,
    buffer: TakeCell&lt;'static, [u8]&gt;,
    client: OptionalCell&lt;&amp;'a dyn Ls1234Client&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>You can see the resources this driver requires to successfully interface
with the light sensor:</p>
<ul>
<li>
<p><code>i2c</code>: This is a reference to the I2C bus that the driver will use to
communicate with the IC. Notice in Tock the type is <code>I2CDevice</code>, and no
address is provided. This is because the <code>I2CDevice</code> type wraps the
address in internally, so that the driver code can <em>only</em> communicate with
the correct address.</p>
</li>
<li>
<p><code>state</code>: Often drivers will iterate through various states as they
communicate with the IC, and it is common for drivers to keep some state
variable to manage this. Our <code>State</code> is defined as an enum, like so:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Copy, Clone, PartialEq)]
enum State {
    Disabled,
    Enabling,
    ReadingLight,
}
<span class="boring">}
</span></code></pre></pre>
<p>Also note that the <code>state</code> variable uses a <code>Cell</code>. This is so that the
driver can update the state.</p>
</li>
<li>
<p><code>buffer</code>: This holds a reference to a buffer of memory the driver will use
to send messages over the I2C bus. By convention, these buffers are
defined statically in the same file as the driver, but then passed to the
driver when the board boots. This provides the board flexibility on the
buffer to use, while still allowing the driver to hint at the size
required for successful operation. In our case the static buffer is
defined as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub static mut BUF: [u8; 3] = [0; 3];
<span class="boring">}
</span></code></pre></pre>
<p>Note the buffer is wrapped in a <code>TakeCell</code> such that it can be passed
to the I2C hardware when necessary, and re-stored in the driver struct
when the I2C code returns the buffer.</p>
</li>
<li>
<p><code>client</code>: This is the callback that will be called after the driver has
received a reading from the sensor. All execution is event-based in Tock,
so the caller will not block waiting for a sample, but instead will expect
a callback via the client when the same is ready. The driver has to define
the type of the callback by defining the <code>Ls1234Client</code> trait in this
case:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Ls1234Client {
	 fn callback(light_reading: usize);
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the client is stored in an <code>OptionalCell</code>. This allows the
callback to not be set initially, and configured at bootup.</p>
</li>
</ul>
<p>Your driver may require other state to be stored as well. You can update
this struct as needed to for state required to successfully implement the
driver. Note that if the state needs to be updated at runtime it will need
to be stored in a cell type. See the cell documentation for more information
on the various cell types in Tock.</p>
<blockquote>
<p>Note: your driver should not keep any state in the struct that is also
stored by the hardware. This easily leads to bugs when that state becomes
out of sync, and makes further development on the driver difficult.</p>
</blockquote>
<p>The last step is to write a function that enables creating an instance of
your driver. By convention, the function is called <code>new()</code> and looks
something like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ls1234&lt;'a&gt; {
    pub fn new(i2c: &amp;'a dyn I2CDevice, buffer: &amp;'static mut [u8]) -&gt; Ls1234&lt;'a&gt; {
        Ls1234 {
            i2c: i2c,
            alarm: alarm,
            state: Cell::new(State::Disabled),
            client: OptionalCell::empty(),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This function will get called by the board's <code>main.rs</code> file when the driver
is instantiated. All of the static objects or configuration that the driver
requires must be passed in here. In this example, a reference to the I2C
device and the static buffer for passing messages must be provided.</p>
<p><strong>Checkpoint</strong>: You have defined the struct which will become the driver for
the IC.</p>
</li>
<li>
<p><strong>Implement the logic to interface with the IC.</strong></p>
<p>Now, you will actually write the code that interfaces with the IC. This
requires extending the <code>impl</code> of the driver struct with additional functions
appropriate for your particular IC.</p>
<p>With our light sensor example, we likely want to write a sample function for
reading a light sensor value:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ls1234&lt;'a&gt; {
    pub fn new(...) -&gt; Ls1234&lt;'a&gt; {...}

    pub fn start_light_reading(&amp;self) {...}
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that the function name is &quot;start light reading&quot;, which is appropriate
because of the event-driven, non-blocking nature of the Tock kernel.
Actually communicating with the sensor will take some time, and likely
requires multiple messages to be sent to and received from the sensor.
Therefore, our sample function will not be able to return the result
directly. Instead, the reading will be provided in the callback function
described earlier.</p>
<p>The start reading function will likely prepare the message buffer in a way
that is IC-specific, then send the command to the IC. A rough example of
that operation looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Ls1234&lt;'a&gt; {
    pub fn new(...) -&gt; Ls1234&lt;'a&gt; {...}

    pub fn start_light_reading(&amp;self) {
        if self.state.get() == State::Disabled {
            self.buffer.take().map(|buf| {
                self.i2c.enable();

                // Set the first byte of the buffer to the &quot;on&quot; command.
                // This is IC-specific and will be described in the IC
                // datasheet.
                buf[0] = 0b10100000;

                // Send the command to the chip and update our state
                // variable.
                self.i2c.write(buf, 1);
                self.state.set(State::Enabling);
            });
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>start_light_reading()</code> function kicks off reading the light value from
the IC and updates our internal state machine state to mark that we are
waiting for the IC to turn on. Now the <code>Ls1234</code> code is finished for the
time being and we now wait for the I2C message to finish being sent. We will
know when this has completed based on a callback from the I2C hardware.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], error: Error) {
        // Handle what happens with the I2C send is complete here.
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In our example, we have to send a new command after turning on the light
sensor to actually read a sampled value. We use our state machine here to
organize the code as in this example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: Error) {
        match self.state.get() {
            State::Enabling =&gt; {
                // Put the read command in the buffer and send it back to
                // the sensor.
                buffer[0] = 0b10100001;
                self.i2c.write_read(buf, 1, 2);
                // Update our state machine state.
                self.state.set(State::ReadingLight);
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This will send another command to the sensor to read the actual light
measurement. We also update our <code>self.state</code> variable because when this I2C
transaction finishes the exact same <code>command_complete</code> callback will be
called, and we must be able to remember where we are in the process of
communicating with the sensor.</p>
<p>When the read finishes, the <code>command_complete()</code> callback will fire again,
and we must handle the result. Since we now have the reading we can call our
client's callback after updating out state machine.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: Error) {
        match self.state.get() {
            State::Enabling =&gt; {
                // Put the read command in the buffer and send it back to
                // the sensor.
                buffer[0] = 0b10100001;
                self.i2c.write_read(buf, 1, 2);
                // Update our state machine state.
                self.state.set(State::ReadingLight);
            }
            State::ReadingLight =&gt; {
                // Extract the light reading value.
                let mut reading: u16 = buffer[0] as 16;
                reading |= (buffer[1] as u16) &lt;&lt; 8;

                // Update our state machine state.
                self.state.set(State::Disabled);

                // Trigger our callback with the result.
                self.client.map(|client| client.callback(reading));
            }
            _ =&gt; {}
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: likely the sensor would need to be disabled and returned to a low
power state.</p>
</blockquote>
<p>At this point your driver can read the IC and return the information from
the IC. For your IC you will likely need to expand on this general template.
You can add additional functions to the main struct implementation, and then
expand the state machine to implement those functions. You may also need
additional resources, like GPIO pins or timer alarms to implement the state
machine for the IC. There are examples in the <code>capsules/src</code> folder with
drivers that need different resources.</p>
</li>
</ol>
<h2 id="optional-steps"><a class="header" href="#optional-steps">Optional Steps</a></h2>
<ol>
<li>
<p><strong>Provide a HIL interface for the IC driver.</strong></p>
<p>The driver so far has a very IC-specific interface. That is, any code that
uses the driver must be written specifically with that IC in mind. In some
cases that may be reasonable, for example if the IC is very unusual or has a
very unique set of features. However, many ICs provide similar
functionality, and higher-level code can be written without knowing what
specific IC is being used on a particular hardware platform.</p>
<p>To enable this, some IC types have HILs in the <code>kernel/src/hil</code> folder in
the <code>sensors.rs</code> file. Drivers can implement one of these HILs and then
higher-level code can use the HIL interface rather than a specific IC.</p>
<p>To implement the HIL, you must implement the HIL trait functions:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl AmbientLight for Ls1234&lt;'a&gt; {
    fn set_client(&amp;self, client: &amp;'static dyn AmbientLightClient) {

    }

    fn read_light_intensity(&amp;self) -&gt; ReturnCode {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The user of the <code>AmbientLight</code> HIL will implement the <code>AmbientLightClient</code>
and provide the client through the <code>set_client()</code> function.</p>
</li>
<li>
<p><strong>Provide a userspace interface for the IC driver.</strong></p>
<p>Sometimes the IC is needed by userspace, and therefore needs a syscall
interface so that userspace applications can use the IC. Please refer to a
separate guide on how to implement a userspace interface for a capsule.</p>
</li>
</ol>
<h2 id="wrap-up-1"><a class="header" href="#wrap-up-1">Wrap-Up</a></h2>
<p>Congratulations! You have implemented an IC driver as a capsule in Tock! We
encourage you to submit a pull request to upstream this to the Tock repository.
Tock is happy to accept capsule drivers even if no boards in the Tock repository
currently use the driver.</p>
<h1 id="implementing-a-system-call-interface-for-userspace"><a class="header" href="#implementing-a-system-call-interface-for-userspace">Implementing a System Call Interface for Userspace</a></h1>
<p>This guide provides an overview and walkthrough on how to add a system call
interface for userspace applications in Tock. The system call interface exposes
some kernel functionality to applications. For example, this could be the
ability to sample a new sensor, or use some service like doing AES encryption.</p>
<p>In this guide we will use a running example of providing a userspace interface
for a hypothetical water level sensor (the &quot;WS00123&quot; water level sensor). This
interface will allow applications to query the current water level, as well as
get notified when the water level exceeds a certain threshold.</p>
<h2 id="setup-1"><a class="header" href="#setup-1">Setup</a></h2>
<p>This guide assumes you already have existing kernel code that needs a
userspace interface. Likely that means there is already a capsule implemented.
Please see the other guides if you also need to implement the capsule.</p>
<p>We will assume there is a <code>struct WS00123 {...}</code> object already implemented
that includes all of the logic needed to interface with this particular water sensor.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Decide on the interface to expose to userspace.</li>
<li>Map the interface to the existing syscalls in Tock.</li>
<li>Create grant space for the application.</li>
<li>Implement the <code>Driver</code> trait.</li>
<li>Document the interface.</li>
<li>Expose the interface to userspace.</li>
<li>Implement the syscall library in userspace.</li>
</ol>
<h2 id="step-by-step-guide-2"><a class="header" href="#step-by-step-guide-2">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Decide on the interface to expose to userspace.</strong></p>
<p>Creating the interface for userspace means making design decisions on how
applications should be able to interface with the kernel capsule. This can
have a lasting impact, and is worth spending some time on up-front to avoid
implementing an interface that is difficult to use or does not match the
needs of applications.</p>
<p>While there is not a fixed algorithm on how to create such an interface,
there are a couple tips that can help with creating the interface:</p>
<ul>
<li>Consider the interface for the same or similar functionality in other
systems (e.g. Linux, Contiki, TinyOS, RIOT, etc.). These may have iterated
on the design and include useful features.</li>
<li>Ignore the specific details of the capsule that exists or how the
particular sensor the syscall interface is for works, and instead consider
what a user of that capsule might want. That is, if you were writing an
application, how would you expect to use the interface? This might be
different from how the sensor or other hardware exposes features.</li>
<li>Consider other chips that provide similar functionality to the specific
one you have. For example, imagine there is a competing water level sensor
the &quot;OWlS789&quot;. What features do both provide? How would a single interface
be usable if a hardware board swapped one out for the other?</li>
</ul>
<p>The interface should include both actions (called &quot;commands&quot; in Tock) that
the application can take (for example, &quot;sample this sensor now&quot;), as well as
events (called subscribe upcalls in Tock) that the kernel can trigger
inside of an application (for example, when the sensed value is ready).</p>
<p>The interface can also include memory sharing between the application and
the kernel. For example, if the application wants to receive a number of
samples at once, or if the kernel needs to operate on many bytes (say for
example encrypting a buffer), then the interface should allow the
application to share some of its memory with the kernel to enable that
functionality.</p>
</li>
<li>
<p><strong>Map the interface to the existing syscalls in Tock.</strong></p>
<p>With a sketch of the interface created, the next step is to map that
interface to the specific syscalls that the Tock kernel supports. Tock has
three main relevant syscall operations that applications can use when
interfacing with the kernel:</p>
<ol>
<li>
<p><code>allow_readwrite</code>: This lets an application share some of its memory with the
kernel, which the kernel can read or write to.</p>
</li>
<li>
<p><code>allow_readonly</code>: This lets an application share some of its memory with the
kernel, which the kernel can only read.</p>
</li>
<li>
<p><code>subscribe</code>: This provides a function pointer that the kernel
can use to invoke an upcall on the application.</p>
</li>
<li>
<p><code>command</code>: This enables the application to direct the kernel to take some
action.</p>
</li>
</ol>
<p>All four also include a couple other parameters to differentiate different
commands, subscriptions, or allows. Refer to the more detailed documentation
on the Tock syscalls for more information.</p>
<p>As the Tock kernel only supports these syscalls, each feature in the design
you created in the first step must be mapped to one or more of them.
To help, consider these hypothetical interfaces that
an application might have for our water sensor:</p>
<ul>
<li><em>What is the maximum water level?</em> This can be a simple command, where the
return value of the command is the maximum water level.</li>
<li><em>What is the current water level?</em> This will require two steps. First,
there needs to be a subscribe call where the application can setup a
callback function. The kernel will call this when the water level value
has been acquired. Second, there will need to be a command to instruct the
kernel to take the water level reading.</li>
<li><em>Take ten water level samples.</em> This will require three steps. First, the
application must use an allow syscall to share a buffer with the kernel
large enough to hold 10 water level readings. Then it must setup a
subscribe callback that the kernel will call when the 10 readings are
ready (note this callback function can be the same as in the single sample
case). Finally it will use a command to tell the kernel to start sampling.</li>
<li><em>Notify me when the water level exceeds a threshold.</em> A likely way to
implement this would be to first require a subscribe syscall for the
application to set the function that will get called when the high water
level event occurs. Then the application will need to use a command to
enable the high water level detection and to optionally set the threshold.</li>
</ul>
<p>As you do this, remember that kernel operations, and the above system calls,
cannot execute for a long period of time. All of the four system calls are 
non-blocking. Long-running operations should involve an application starting
the operation with a command, then having the kernel signal completion with
an upcall.</p>
<p><strong>Checkpoint</strong>: You have defined how many allow, subscribe, and command
syscalls you need, and what each will do.</p>
</li>
<li>
<p><strong>Create grant space for the application.</strong></p>
<p>Grants are regions in a process's memory space that are shared with the
kernel. The kernel uses these to store state on behalf of the process. To
provide our syscall interface for the water level sensor, we need to setup a
grant so that we can store state for all of the requests we may get from
processes that want to use the sensor. In particular, we will need to be
able to store the callback that a process registers with us.</p>
<p>The first step to do this is to create a struct that contains fields for all
of the state we want to store for each process that uses our syscall interface. By convention in Tock, this struct is named <code>App</code>, but it could
have a different name. We will need to keep two values, the callback and the
high water alert threshold:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct App {
    callback: Callback,
    threshold: usize,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have the type we want to store in the grant region we can create
the grant type for it by extending our <code>WS00123</code> struct:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct WS00123 {
	...
    apps: Grant&lt;App&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>We will also need the grant region to be created by the board and passed in
to us by adding it to the capsules <code>new()</code> function:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl WS00123 {
    pub fn new(
        ...
        grant: Grant&lt;App&gt;,
    ) -&gt; WS00123 {
        WS00123 {
            ...,
            apps: grant,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we have somewhere to store values on a per-process basis.</p>
</li>
<li>
<p><strong>Implement the <code>Driver</code> trait.</strong></p>
<p>The <code>Driver</code> trait is how a capsule provides implementations for the various
syscalls an application might call. The basic framework looks like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Driver for WS00123 {
	fn allow_readwrite(
	    &amp;self,
	    appid: AppId,
	    which, usize,
	    slice: ReadWriteAppSlice,
	) -&gt; Result&lt;ReadWriteAppSlice, (ReadWriteAppSlice, ErrorCode)&gt; { }
	
    fn allow_readonly(
        &amp;self,
        app: AppId,
        which: usize,
        slice: ReadOnlyAppSlice,
    ) -&gt; Result&lt;ReadOnlyAppSlice, (ReadOnlyAppSlice, ErrorCode)&gt; { }
	
    fn subscribe(
        &amp;self,
        subscribe_identifier: usize,
        callback: Callback,
        app_id: AppId,
    ) -&gt; Result&lt;Callback, (Callback, ErrorCode)&gt; { }

    fn command(
        &amp;self, 
	    which: usize, 
		r2: usize, 
		r3: usize, 
		caller_id: AppId) -&gt; CommandReturn { }
}
<span class="boring">}
</span></code></pre></pre>
<p>For details on exactly how these methods work and their return values, 
[TRD104]((https://github.com/tock/tock/blob/master/doc/reference/trd104-syscalls.md)
is their reference document.</p>
<p>Note: there are default implementations for each of these, so in our water
level sensor case we can simply omit the <code>allow</code> call.</p>
<p>By Tock convention, every syscall interface must at least support the
command call with <code>which == 0</code>. This allows applications to check if
the syscall interface is supported on the current platform. The command must
return a <code>CommandReturn::success()</code>. If the command is not present, then the
kernel automatically has it return a failure with an error code of <code>ErrorCode::NOSUPPORT</code>.
For our example, we use
the simple case:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Driver for WS00123 {
    fn command(
        &amp;self, 
        which: usize, 
        r2: usize, 
		r3: usize, 
		caller_id: AppId) -&gt; CommandReturn { 
			match command_num {
				0 =&gt; CommandReturn::success(),
				_ =&gt; CommandReturn::failure(ErrorCode::NOSUPPORT)
			}
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's handle the subscribe call where the app can setup the callback we
should use. For this capsule, we will use a single callback for both when a
measurement is ready and for when a high water alert is triggered, but with
different arguments passed into the callback.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Driver for WS00123 {
    /// Setup callbacks.
    ///
    /// ### `subscribe_num`
    ///
    /// - `0`: Setup the main callback to be used when samples are ready
    ///        and when any alerts are triggered.
    fn subscribe(
        &amp;self,
        subscribe_identifier: usize,
		mut callback: Callback,
        app_id: AppId,
    ) -&gt; Result&lt;Callback, (Callback, ErrorCode)&gt; {
        let res = self.apps
            .enter(app_id, |app, _| {
                match subscribe_num {
                    0 =&gt; {
					    // Swap the old and new callback
					    mem::swap(&amp;mut app.callback, &amp;mut callback);
						Ok(())
					},
                    _ =&gt; Err(ErrorCode:NOSUPPORT)
            }).map_err(ErrorCode::from); // Turn a grant error to an ErrorCode
		// We always return a callback
        if let Err(e) = res {
		    Err((callback, e))
	    } else {
		    Ok(callback)
	 	}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, we use the <code>enter()</code> function to &quot;enter&quot; the grant region of
the specific requesting app <code>app_id</code>. This performs checks like ensuring the
grant region exists and that the application is valid. If <code>enter()</code> succeeds
then we can update the <code>App</code> state like normal. Here we only need to save
the callback.</p>
<p>Next we can implement more commands so that the application can direct our
capsule as to what the application wants us to do. We need two commands, one
to sample and one to enable the alert. In both cases the commands must
return a <code>ReturnCode</code>, and call functions that likely already exist in the
original implementation of the <code>WS00123</code> sensor. If the functions don't
quite exist, then they will need to be added as well.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Driver for WS00123 {
	/// Command interface.
	///
	/// ### `command_num`
	///
	/// - `0`: Return SUCCESS if this driver is included on the platform.
	/// - `1`: Start a water level measurement.
	/// - `2`: Enable the water level detection alert. `data` is used as the
	///        height to set as the the threshold for detection.
    fn command(
        &amp;self, 
        which: usize, 
        r2: usize, 
		r3: usize, 
		caller_id: AppId) -&gt; CommandReturn { 
  	    match command_num {
			0 =&gt; CommandReturn::success(),
			1 =&gt; self.start_measurement(app),
			2 =&gt; {
				// Save the threshold for this app.
				self.apps
				    .enter(app_id, |app, _| {
				        app.threshold = data;
				        CommandReturn::success()
				    })
				    .map_or_else(
				    	|err| CommandReturn::failure(ErrorCode::from),
				    	|ok| self.set_high_level_detection()
				    )
			},

			_ =&gt; CommandReturn::failure(ErrorCode::NOSUPPORT),
		}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The last item that needs to be added is to actually use the callback when
the sensor has been sampled or the alert has been triggered. Actually
issuing the callback will need to be added to the existing implementation of
the capsule. As an example, if our water sensor was attached to the board
over I2C, then we might trigger the callback in response to a finished I2C
command:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl i2c::I2CClient for WS00123 {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: i2c::Error) {
    	...
    	let app_id = &lt;get saved appid for the app that issued the command&gt;;
    	let measurement = &lt;calculate water level based on returned I2C data&gt;;

    	self.apps.enter(app_id, |app, _| {
    	    app.callback.schedule(0, measurement, 0));
    	});
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There may be other cleanup code required to reset state or prepare the
sensor for another sample by a different application, but these are the
essential elements for implementing the syscall interface.</p>
<p>Finally, we need to assign our new <code>Driver</code> implementation a number so that
the kernel (and userspace apps) can differentiate this syscall interface
from all others that a board supports. By convention this is specified by
a global value at the top of the capsule file:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub const DRIVER_NUM: usize = 0x80000A;
<span class="boring">}
</span></code></pre></pre>
<p>The value cannot conflict with other capsules in use, but can be set
arbitrarily, particularly for testing. Tock has a procedure for assigning
numbers, and you may need to change this number if the capsule is to merged
into the main Tock repository.</p>
<p><strong>Checkpoint</strong>: You have the syscall interface translated from a design to
code that can run inside the Tock kernel.</p>
</li>
<li>
<p><strong>Document the interface.</strong></p>
<p>A syscall interface is a contract between the kernel and any number of
userspace processes, and processes should be able to be developed
independently of the kernel. Therefore, it is helpful to document the new
syscall interface you made so applications know how to use the various
command, subscribe, and allow calls.</p>
<p>An example markdown file documenting our water level syscall interface is
as follows:</p>
<pre><code class="language-md">---
driver number: 0x80000A
---

# Water Level Sensor WS00123

## Overview

The WS00123 water level sensor can sample the depth of water as well as
trigger an event if the water level gets too high.

## Command

  * ### Command number: `0`

    **Description**: Does the driver exist?

    **Argument 1**: unused

    **Argument 2**: unused

    **Returns**: SUCCESS if it exists, otherwise ENODEVICE

  * ### Command number: `1`

    **Description**: Initiate a sensor reading.  When a reading is ready, a
    callback will be delivered if the process has `subscribed`.

    **Argument 1**: unused

    **Argument 2**: unused

    **Returns**: `EBUSY` if a reading is already pending, `ENOMEM` if there
    isn't sufficient grant memory available, or `SUCCESS` if the sensor
    reading was initiated successfully.

  * ### Command number: `2`

    **Description**: Enable the high water detection. THe callback will the
    alert will be delivered if the process has `subscribed`.

    **Argument 1**: The water depth to alert for.

    **Argument 2**: unused

    **Returns**: `EBUSY` if a reading is already pending, `ENOMEM` if there
    isn't sufficient grant memory available, or `SUCCESS` if the sensor
    reading was initiated successfully.

## Subscribe

  * ### Subscribe number: `0`

    **Description**: Subscribe a callback for sensor readings and alerts.

    **Callback signature**: The callback's first argument is `0` if this is
    a measurement, and `1` if the callback is an alert. If it is a
    measurement the second value will be the water level.

    **Returns**: SUCCESS if the subscribe was successful or ENOMEM if the
    driver failed to allocate memory to store the callback.
</code></pre>
<p>This file should be named <code>&lt;driver_num&gt;_&lt;sensor&gt;.md</code>, or in this case:
<code>80000A_ws00123.md</code>.</p>
</li>
<li>
<p><strong>Expose the interface to userspace.</strong></p>
<p>The last kernel implementation step is to let the main kernel know about
this new syscall interface so that if an application tries to use it the
kernel knows which implementation of <code>Driver</code> to call. In each board's
<code>main.rs</code> file (e.g. <code>boards/hail/src/main.rs</code>) there is a implementation of
the <code>Platform</code> trait where the board can setup which syscall interfaces it
supports. To enable our water sensor interface we add a new entry to the
match statement there:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Platform for Hail {
    fn with_driver&lt;F, R&gt;(&amp;self, driver_num: usize, f: F) -&gt; R
    where
        F: FnOnce(Option&lt;&amp;dyn kernel::Driver&gt;) -&gt; R,
    {
        match driver_num {
        	...
            capsules::ws00123::DRIVER_NUM =&gt; f(Some(self.ws00123)),
            ...
            _ =&gt; f(None),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><strong>Implement the syscall library in userspace.</strong></p>
<p>At this point userspace applications can use our new syscall interface and
interact with the water sensor. However, applications would have to call all
of the syscalls directly, and that is fairly difficult to get right and not
user friendly. Therefore, we typically implement a small library layer in
userspace to make using the interface easier.</p>
<p>In this guide we will be setting up a C library, and to do so we will create
<code>libtock-c/libtock/ws00123.h</code> and <code>libtock-c/libtock/ws00123.c</code>, both of
which will be added to the libtock-c repository. The .h file defines the
public interface and constants:</p>
<pre><code class="language-c">#pragma once

#include &quot;tock.h&quot;

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

#define DRIVER_NUM_WS00123 0x80000A

int ws00123_set_callback(subscribe_cb callback, void* callback_args);
int ws00123_read_water_level();
int ws00123_enable_alerts(uint32_t threshold);

#ifdef __cplusplus
}
#endif
</code></pre>
<p>While the .c file provides the implementations:</p>
<pre><code class="language-c">#include &quot;ws00123.h&quot;
#include &quot;tock.h&quot;

int ws00123_set_callback(subscribe_cb callback, void* callback_args) {
  return subscribe(DRIVER_NUM_WS00123, 0, callback, callback_args);
}

int ws00123_read_water_level() {
  return command(DRIVER_NUM_WS00123, 1, 0, 0);
}

int ws00123_enable_alerts(uint32_t threshold) {
  return command(DRIVER_NUM_WS00123, 2, threshold, 0);
}
</code></pre>
<p>This is a very basic implementation of the interface, but it provides some
more readable names to the numbers that make up the syscall interface. See
other examples in libtock for how to make synchronous versions of
asynchronous operations (like reading the sensor).</p>
</li>
</ol>
<h2 id="wrap-up-2"><a class="header" href="#wrap-up-2">Wrap-Up</a></h2>
<p>Congratulations! You have added a new API for userspace applications using the
Tock syscall interface! We encourage you to submit a pull request to upstream
this to the Tock repository.</p>
<h1 id="implementing-a-hil-interface"><a class="header" href="#implementing-a-hil-interface">Implementing a HIL Interface</a></h1>
<p>This guide describes the process of creating a new HIL interface in Tock. &quot;HIL&quot;s
are one or more Rust traits that provide a standard and shared interface between
pieces of the Tock kernel.</p>
<h2 id="background-2"><a class="header" href="#background-2">Background</a></h2>
<p>The most canonical use for a HIL is to provide an interface to hardware
peripherals to capsules. For example, a HIL for SPI provides an interface
between the SPI hardware peripheral in a microcontroller and a capsule that
needs a SPI bus for its operation. The HIL is a generic interface, so that same
capsule can work on different microcontrollers, as long as each microcontroller
implements the SPI HIL.</p>
<p>HILs are also used for other generic kernel interfaces that are relevant to
capsules. For example, Tock defines a HIL for a &quot;temperature sensor&quot;. While a
temperature sensor is not generally a hardware peripheral, a capsule may want to
use a generic temperature sensor interface and not be restricted to using a
particular temperature sensor driver. Having a HIL allows the capsule to use a
generic interface. For consistency, these HILs are also specified in the kernel
crate.</p>
<blockquote>
<p>Note: In the future Tock will likely split these interface types into separate
groups.</p>
</blockquote>
<p>HIL development often significantly differs from other development in Tock. In
particular, HILs can often be written quickly, but tend to take numerous
iterations over relatively long periods of time to refine. This happens for
three general reasons:</p>
<ol>
<li>HILs are intended to be generic, and therefore implementable by a range of
different hardware platforms. Designing an interface that works for a range
of different hardware takes time and experience with various MCUs, and often
incompatibilities aren't discovered until an implementation proves to be
difficult (or impossible).</li>
<li>HILs are Rust traits, and Rust traits are reasonably complex and offer a fair
bit of flexibility. Balancing both leveraging the flexibility Rust provides
and avoiding undue complexity takes time. Again, often trial-and-error is
required to settle on how traits should be composed to best capture the
interface.</li>
<li>HILs are intended to be generic, and therefore will be used in a variety of
different use cases. Ensuring that the HIL is expressive enough for a diverse
set of uses takes time. Again, often the set of uses is not known initially,
and HILs often have to be revised as new use cases are discovered.</li>
</ol>
<p>Therefore, we consider HILs to be evolving interfaces.</p>
<h2 id="tips-on-hil-development"><a class="header" href="#tips-on-hil-development">Tips on HIL Development</a></h2>
<p>As getting a HIL interface &quot;correct&quot; is difficult, Tock tends to prefer starting
with simple HIL interfaces that are typically inspired by the hardware used when
the HIL is initially created. Trying to generalize a HIL too early can lead to
complexity that is never actually warranted, or complexity that didn't actually
address a problem.</p>
<p>Also, Tock prefers to only include code (or in this case HIL interface
functions) that are actually in use by the Tock code base. This ensures that
there is at least some method of using or testing various components of Tock.
This also suggests that initial HIL development should only focus on an interface
that is needed by the initial use case.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Determine that a new HIL interface is needed.</li>
<li>Create the new HIL in the kernel crate.</li>
<li>Ensure the HIL file includes sufficient documentation.</li>
</ol>
<h2 id="step-by-step-guide-3"><a class="header" href="#step-by-step-guide-3">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Determine that a new HIL interface is needed.</strong></p>
<p>Tock includes a number of existing HIL interfaces, and modifying an existing
HIL is preferred to creating a new HIL that is similar to an existing
interface. Therefore, you should start by verifying an existing HIL does not
already meet your need or could be modified to meet your need.</p>
<p>This may seem to be a straightforward step, but it can be complicated by
microcontrollers calling similar functionality by different names, and the
existing HIL using a standard name or a different name from another
microcontroller.</p>
<p>Also, you can reach out via the email list or slack if you have questions
about whether a new HIL is needed or an existing one should suffice.</p>
</li>
<li>
<p><strong>Create the new HIL in the kernel crate.</strong></p>
<p>Once you have determined a new HIL is required, you should create
the appropriate file in <code>kernel/src/hil</code>. Often the best way to start is
to copy an existing HIL that is similar in nature to the interface you are
trying to create.</p>
<p>As noted above, HILs evolve over time, and HILs will be periodically updated
as issues are discovered or best practices for HIL design are learned.
Unfortunately, this means that copying an existing HIL might lead to
&quot;mistakes&quot; that must be remedied before the new HIL can be merged.</p>
<p>Likely, it is helpful to open a pull request relatively early in the HIL
creation process so that any substantial issues can be detected and
corrected quickly.</p>
<p>While Tock does not have a full guide to writing a HIL (although perhaps
that could be created eventually), there are some guidelines that HILs
generally follow:</p>
<ul>
<li>Avoid <code>initialize()</code> or <code>start()</code> or <code>on()</code> functions in HIL interfaces.
While these types of methods are intuitive when implementing a HIL, they
are often not intuitive for users of that HIL. For example, when should
<code>initialize()</code> be called? Once when the board boots? Or before every use?
What if there are multiple users of the peripheral? In general, it is
better to require that the implementation track the state of the
underlying hardware and configure it as needed.</li>
<li>Avoid using <code>'static</code> lifetimes in HILs. This limits flexibility, and Tock
prefers to use a generic <code>'a</code> lifetime instead. Also, unless there is a
clear reason not to, only a single lifetime should be used.</li>
<li>Include the <code>set_client()</code> function in the HIL if needed. Not all HILs
require split-phase operation and need a client interface, but for those
that do the <code>set_client()</code> function should be included in the HIL. This
makes writing generic components for boards possible.</li>
</ul>
<p>Tock only uses <strong>non-blocking</strong> interfaces in the kernel, and HILs should
reflect that as well. Therefore, for any operation that will take more than
a couple cycles to complete, or would require waiting on a hardware flag,
a split interface design should be used with a <code>Client</code> trait that receives
a callback when the operation has completed.</p>
</li>
<li>
<p><strong>Ensure the HIL file includes sufficient documentation.</strong></p>
<p>HIL files should be well commented with Rustdoc style (i.e. <code>///</code>) comments.
These comments are the main source of documentation for HILs.</p>
<p>As HILs grow in complexity or stability, they will be documented separately
to fully explain their design and intended use cases.</p>
</li>
</ol>
<h2 id="wrap-up-3"><a class="header" href="#wrap-up-3">Wrap-Up</a></h2>
<p>Congratulations! You have implemented a new HIL in Tock! We encourage you to
submit a pull request to upstream this to the Tock repository.</p>
<h1 id="implementing-an-in-kernel-virtualization-layer"><a class="header" href="#implementing-an-in-kernel-virtualization-layer">Implementing an in-kernel Virtualization Layer</a></h1>
<p>This guide provides an overview and walkthrough on how to add an in-kernel virtualization
layer, such that a given hardware interface can be used simultaneously by multiple
kernel capsules, or used simultaneously by a single kernel capsule and userspace.
Ideally, virtual interfaces will be available for all hardware interfaces in Tock. 
Some example interfaces which have already been virtualized include Alarm, SPI, Flash,
UART, I2C, ADC, and others.</p>
<p>In this guide we will use a running example of virtualizing a single hardware SPI peripheral
and bus for use as a SPI Master.</p>
<h2 id="setup-2"><a class="header" href="#setup-2">Setup</a></h2>
<p>This guide assumes you already have existing kernel code that needs to be virtualized.
There should be an existing HIL for the resource you are virtualizing.</p>
<p>We will assume there is a <code>trait SpiMaster {...}</code> already defined and implemented
that includes all of the logic needed to interface with the underlying SPI.
We also assume there is a <code>trait SpiMasterClient</code> that determines the interface a client
of the SPI exposes to the underlying resource. In most cases, equivalent traits will
represent a necessary precursor to virtualization.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Create a capsule file for your virtualizer</li>
<li>Determine what portions of this interface should be virtualized.</li>
<li>Create a <code>MuxXXX</code> struct, which will serve as the lone client of the underlying resource.</li>
<li>Create a <code>VirtualXXXDevice</code> which will implement the underlying HIL trait, allowing for the appearance
of multiple of the lone resource.</li>
<li>Implement the logic for queuing requests from capsules.</li>
<li>Implement the logic for dispatching callbacks from the underlying resource to the appropriate client.</li>
<li>Document the interface.</li>
<li>(Optional) Write tests for the virtualization logic.</li>
</ol>
<p><img src="development/../imgs/virtual.svg" alt="" /></p>
<h2 id="step-by-step-guide-4"><a class="header" href="#step-by-step-guide-4">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Create a capsule file for your virtualizer</strong></p>
<p>This step is easy. Navigate to the <code>capsules/src/</code> directory and create a new file
named <code>virtual_xxx</code>, where <code>xxx</code> is the name of the underlying resource being virtualized.
All of the code you will write while following this guide belongs in that file.
Additionally, open <code>capsules/src/lib.rs</code> and add <code>pub mod virtual_xxx;</code> to the list
of modules.</p>
</li>
<li>
<p><strong>Determine what portions of this interface should be virtualized</strong></p>
<p>Generally, this step requires looking at the HIL being virtualized, and
determining what portions of the HIL require additional logic to handle
multiple concurrent clients. Lets take a look at the SPIMaster HIL:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait SpiMaster {
    fn set_client(&amp;self, client: &amp;'static dyn SpiMasterClient);

    fn init(&amp;self);
    fn is_busy(&amp;self) -&gt; bool;

    /// Perform an asynchronous read/write operation, whose
    /// completion is signaled by invoking SpiMasterClient on
    /// the initialized client.
    fn read_write_bytes(
        &amp;self,
        write_buffer: &amp;'static mut [u8],
        read_buffer: Option&lt;&amp;'static mut [u8]&gt;,
        len: usize,
    ) -&gt; ReturnCode;
    fn write_byte(&amp;self, val: u8);
    fn read_byte(&amp;self) -&gt; u8;
    fn read_write_byte(&amp;self, val: u8) -&gt; u8;

    /// Tell the SPI peripheral what to use as a chip select pin.
    fn specify_chip_select(&amp;self, cs: Self::ChipSelect);

    /// Returns the actual rate set
    fn set_rate(&amp;self, rate: u32) -&gt; u32;
    fn get_rate(&amp;self) -&gt; u32;
    fn set_clock(&amp;self, polarity: ClockPolarity);
    fn get_clock(&amp;self) -&gt; ClockPolarity;
    fn set_phase(&amp;self, phase: ClockPhase);
    fn get_phase(&amp;self) -&gt; ClockPhase;

    // These two functions determine what happens to the chip
    // select line between transfers. If hold_low() is called,
    // then the chip select line is held low after transfers
    // complete. If release_low() is called, then the chip select
    // line is brought high after a transfer completes. A &quot;transfer&quot;
    // is any of the read/read_write calls. These functions
    // allow an application to manually control when the
    // CS line is high or low, such that it can issue multi-byte
    // requests with single byte operations.
    fn hold_low(&amp;self);
    fn release_low(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p>For some of these functions, it is clear that no virtualization is required.
For example, <code>get_rate()</code>, <code>get_phase()</code> and <code>get_polarity()</code> simply request
information on the current configuration of the underlying hardware. Implementations
of these can simply pass the call straight through the mux.</p>
<p>Some other functions are not appropriate to expose to virtual clients at all.
For example, <code>hold_low()</code>, <code>release_low()</code>, and <code>specify_chip_select()</code> are
not suitable for use when the underlying bus is shared. <code>init()</code> does not make sense
when it is unclear which client should call it. The mux should queue operations,
so clients should not need access to <code>is_busy()</code>.</p>
<p>For other functions, it is clear that virtualization <em>is</em> necessary. For example,
it is clear that if multiple clients are using the Mux, they cannot all be allowed
set the rate of the underlying hardware at arbitrary times, as doing so could
break an ongoing operation initiated by an underlying client. However, it is
important to expose this functionality to clients. Thus <code>set_rate()</code>, <code>set_clock()</code>
and <code>set_phase()</code> need to be virtualized, and provided to virtual clients.
<code>set_client()</code> needs to be adapted to support multiple simultaneous clients.</p>
<p>Finally, virtual clients need a way to send and receive on the bus. Single byte
writes and reads are typically only used under the assumption that a single client
is going to make multiple single byte reads/writes consecutively, and thus are inappropriate to
virtualize. Instead, the virtual interface should only include <code>read_write_bytes()</code>,
as that encapsulates the entire transaction that would be desired by a virtual client.</p>
<p>Given that not all parts of the original HIL trait (<code>SpiMaster</code>) are appropriate for
virtualization, we should create a new trait in the SPI HIL that will represent the
interface provided to clients of the Virtual SPI:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! kernel/src/hil/spi.rs
...
/// SPIMasterDevice provides a chip-specific interface to the SPI Master
/// hardware. The interface wraps the chip select line so that chip drivers
/// cannot communicate with different SPI devices.
pub trait SpiMasterDevice {
    /// Perform an asynchronous read/write operation, whose
    /// completion is signaled by invoking SpiMasterClient.read_write_done on
    /// the provided client.
    fn read_write_bytes(
        &amp;self,
        write_buffer: &amp;'static mut [u8],
        read_buffer: Option&lt;&amp;'static mut [u8]&gt;,
        len: usize,
    ) -&gt; ReturnCode;

    /// Helper function to set polarity, clock phase, and rate all at once.
    fn configure(&amp;self, cpol: ClockPolarity, cpal: ClockPhase, rate: u32);
    fn set_polarity(&amp;self, cpol: ClockPolarity);
    fn set_phase(&amp;self, cpal: ClockPhase);
    fn set_rate(&amp;self, rate: u32);

    fn get_polarity(&amp;self) -&gt; ClockPolarity;
    fn get_phase(&amp;self) -&gt; ClockPhase;
    fn get_rate(&amp;self) -&gt; u32;
}
<span class="boring">}
</span></code></pre></pre>
<p>Not all virtualizers will require a new trait to provide virtualization! For example,
<code>VirtualMuxDigest</code> exposes the same <code>Digest</code> HIL as the underlying hardware. Same for
<code>VirtualAlarm</code>, <code>VirtualUart</code>, and <code>MuxFlash</code>. <code>VirtualI2C</code> does use a different trait, similarly
to SPI, and <code>VirtualADC</code> introduces an <code>AdcChannel</code> trait to enable virtualization that
is not possible with the ADC interface implemented by hardware.</p>
<p>There is no fixed algorithm for deciding exactly how to virtualize a given interface,
and doing so will require thinking carefully about the requirements of the clients and
nature of the underlying resource. Tock's <a href="https://github.com/tock/tock/tree/master/doc/threat_model">threat model</a>
describes several requirements for virtualizers in its <a href="https://github.com/tock/tock/blob/master/doc/threat_model/Virtualization.md">virtualization section</a>.</p>
<blockquote>
<p>Note: You should read these requirements!! They discuss things
like the confidentiality and fairness requirements for virtualizers.</p>
</blockquote>
<p>Beyond the threat model, you should think carefully about how virtual clients will use
the interface, the overhead (in cycles / code size / RAM use) of different approaches,
and how the interface will work in the face of multiple concurrent requests. It is also
important to consider the potential for two layers of virtualization, when one of the
clients of the virtualization capsule is a userspace driver that will also be virtualizing
that same resource. In some cases (see: UDP port reservations) special casing the userspace
driver may be valuable.</p>
<p>Frequently the best approach will involve looking for an already virtualized resource that
is qualitatively similar to the resource you are working with, and using its virtualization
as a template.</p>
</li>
<li>
<p><strong>Create a <code>MuxXXX</code> struct, which will serve as the lone client of the underlying resource.</strong></p>
<p>In order to virtualize a hardware resource, we need to create some object that has
a reference to the underlying hardware resource and that will hold the multiple &quot;virtual&quot;
devices which clients will interact with. For the SPI interface, we call this struct
<code>MuxSpiMaster</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// The Mux struct manages multiple Spi clients. Each client may have
/// at most one outstanding Spi request.
pub struct MuxSpiMaster&lt;'a, Spi: hil::spi::SpiMaster&gt; {
    // The underlying resource being virtualized
    spi: &amp;'a Spi,

    // A list of virtual devices which clients will interact with.
    // (See next step for details)
    devices: List&lt;'a, VirtualSpiMasterDevice&lt;'a, Spi&gt;&gt;,

    // Additional data storage needed to implement virtualization logic
    inflight: OptionalCell&lt;&amp;'a VirtualSpiMasterDevice&lt;'a, Spi&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we use Tock's built-in <code>List</code> type, which is a LinkedList of statically
allocated structures that implement a given trait. This type is required because
Tock does not allow heap allocation in the Kernel.</p>
<p>Typically, this struct will implement some number of private helper functions used
as part of virtualization, and provide a public constructor. For now we will just
implement the constructor:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a, Spi: hil::spi::SpiMaster&gt; MuxSpiMaster&lt;'a, Spi&gt; {
    pub const fn new(spi: &amp;'a Spi) -&gt; MuxSpiMaster&lt;'a, Spi&gt; {
        MuxSpiMaster {
            spi: spi,
            devices: List::new(),
            inflight: OptionalCell::empty(),
        }
    }

    // TODO: Implement virtualization logic helper functions
}
<span class="boring">}
</span></code></pre></pre>
</li>
<li>
<p><strong>Create a <code>VirtualXXXDevice</code> which will implement the underlying HIL trait</strong></p>
<p>In the previous step you probably noticed the list of virtual devices referencing a
<code>VirtualSpiMasterDevice</code>, which we had not created yet. We will define and implement that
struct here. In practice, both must be defined simultaneously because each type references
the other. The <code>VirtualSpiMasterDevice</code> should have a reference to the mux, a <code>ListLink</code>
field (required so that lists of <code>VirtualSpiMasterDevice</code>s can be constructed),
and other fields for data that needs to be stored <em>for each client</em> of the virtualizer.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct VirtualSpiMasterDevice&lt;'a, Spi: hil::spi::SpiMaster&gt; {
    //reference to the mux
    mux: &amp;'a MuxSpiMaster&lt;'a, Spi&gt;,

    // Pointer to next element in the list of devices
    next: ListLink&lt;'a, VirtualSpiMasterDevice&lt;'a, Spi&gt;&gt;,

    // Per client data that must be stored across calls
    chip_select: Cell&lt;Spi::ChipSelect&gt;,
    txbuffer: TakeCell&lt;'static, [u8]&gt;,
    rxbuffer: TakeCell&lt;'static, [u8]&gt;,
    operation: Cell&lt;Op&gt;,
    client: OptionalCell&lt;&amp;'a dyn hil::spi::SpiMasterClient&gt;,
}

impl&lt;'a, Spi: hil::spi::SpiMaster&gt; VirtualSpiMasterDevice&lt;'a, Spi&gt; {
    pub const fn new(
        mux: &amp;'a MuxSpiMaster&lt;'a, Spi&gt;,
        chip_select: Spi::ChipSelect,
    ) -&gt; VirtualSpiMasterDevice&lt;'a, Spi&gt; {
        VirtualSpiMasterDevice {
            mux: mux,
            chip_select: Cell::new(chip_select),
            txbuffer: TakeCell::empty(),
            rxbuffer: TakeCell::empty(),
            operation: Cell::new(Op::Idle),
            next: ListLink::empty(),
            client: OptionalCell::empty(),
        }
    }

    // Most virtualizers will use a set_client method that looks exactly like this
    pub fn set_client(&amp;'a self, client: &amp;'a dyn hil::spi::SpiMasterClient) {
        self.mux.devices.push_head(self);
        self.client.set(client);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the struct that will implement whatever HIL trait we decided on in step 1.
In our case, this is the <code>SpiMasterDevice</code> trait:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Given that there are multiple types of operations we might need to queue,
// create an enum that can represent each operation and the data that operation
// needs to store.
#[derive(Copy, Clone, PartialEq)]
enum Op {
    Idle,
    Configure(hil::spi::ClockPolarity, hil::spi::ClockPhase, u32),
    ReadWriteBytes(usize),
    SetPolarity(hil::spi::ClockPolarity),
    SetPhase(hil::spi::ClockPhase),
    SetRate(u32),
}

impl&lt;Spi: hil::spi::SpiMaster&gt; hil::spi::SpiMasterDevice for VirtualSpiMasterDevice&lt;'_, Spi&gt; {
    fn configure(&amp;self, cpol: hil::spi::ClockPolarity, cpal: hil::spi::ClockPhase, rate: u32) {
        self.operation.set(Op::Configure(cpol, cpal, rate));
        self.mux.do_next_op();
    }

    fn read_write_bytes(
        &amp;self,
        write_buffer: &amp;'static mut [u8],
        read_buffer: Option&lt;&amp;'static mut [u8]&gt;,
        len: usize,
    ) -&gt; ReturnCode {
        self.txbuffer.replace(write_buffer);
        self.rxbuffer.put(read_buffer);
        self.operation.set(Op::ReadWriteBytes(len));
        self.mux.do_next_op();
        ReturnCode::SUCCESS
    }

    fn set_polarity(&amp;self, cpol: hil::spi::ClockPolarity) {
        self.operation.set(Op::SetPolarity(cpol));
        self.mux.do_next_op();
    }

    fn set_phase(&amp;self, cpal: hil::spi::ClockPhase) {
        self.operation.set(Op::SetPhase(cpal));
        self.mux.do_next_op();
    }

    fn set_rate(&amp;self, rate: u32) {
        self.operation.set(Op::SetRate(rate));
        self.mux.do_next_op();
    }

    fn get_polarity(&amp;self) -&gt; hil::spi::ClockPolarity {
        self.mux.spi.get_clock()
    }

    fn get_phase(&amp;self) -&gt; hil::spi::ClockPhase {
        self.mux.spi.get_phase()
    }

    fn get_rate(&amp;self) -&gt; u32 {
        self.mux.spi.get_rate()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can begin to see the virtualization logic. Each <code>get_x()</code> method just forwards calls
directly to the underlying hardware driver, as these operations are synchronous and non-blocking.
But the <code>set()</code> calls and the read/write calls
are queued as operations. Each client can have only a single outstanding operation (a common
requirement for virtualizers in Tock given the lack of dynamic allocation). These operations
are &quot;queued&quot; by each client simply setting the operation field of its <code>VirtualSpiMasterDevice</code>
to whatever operation it would like to perform next. The Mux can iterate through the list
of devices to choose a pending operation. Clients learn about the completion of operations
via callbacks, informing them that they can begin new operations.</p>
</li>
<li>
<p><strong>Implement the logic for queuing requests from capsules.</strong></p>
<p>So far, we have sketched out a skelton for how we will queue requests from capsules, but
not yet implemented the <code>do_next_op()</code> function that will handle the order in which operations
are performed, or how operations are translated into calls by the actual hardware driver.</p>
<p>We know that all operations in Tock are asynchronous, so it is always possible that
the underlying hardware device is busy when <code>do_next_op()</code> is called -- accordingly,
we need some mechanism for tracking if the underlying device is currently busy. We also
need to restore the state expected by the device performing a given operaion (e.g. the chip
select pin in use). Beyond that, we just forward calls to the hardware driver:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn do_next_op(&amp;self) {
    if self.inflight.is_none() {
        let mnode = self
            .devices
            .iter()
            .find(|node| node.operation.get() != Op::Idle);
        mnode.map(|node| {
            self.spi.specify_chip_select(node.chip_select.get());
            let op = node.operation.get();
            // Need to set idle here in case callback changes state
            node.operation.set(Op::Idle);
            match op {
                Op::Configure(cpol, cpal, rate) =&gt; {
                    // The `chip_select` type will be correct based on
                    // what implemented `SpiMaster`.
                    self.spi.set_clock(cpol);
                    self.spi.set_phase(cpal);
                    self.spi.set_rate(rate);
                }
                Op::ReadWriteBytes(len) =&gt; {
                    // Only async operations want to block by setting
                    // the devices as inflight.
                    self.inflight.set(node);
                    node.txbuffer.take().map(|txbuffer| {
                        let rxbuffer = node.rxbuffer.take();
                        self.spi.read_write_bytes(txbuffer, rxbuffer, len);
                    });
                }
                Op::SetPolarity(pol) =&gt; {
                    self.spi.set_clock(pol);
                }
                Op::SetPhase(pal) =&gt; {
                    self.spi.set_phase(pal);
                }
                Op::SetRate(rate) =&gt; {
                    self.spi.set_rate(rate);
                }
                Op::Idle =&gt; {} // Can't get here...
            }
        });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Notably, the SPI driver does not implement any fairness schemes, despite the requirements of
the threat model. As of this writing, the threat model is still aspirational, and not followed
for all virtualizers. Eventually, this driver should be updated to use round robin queueing of
clients, rather than always giving priority to whichever client was added to the List first.</p>
</li>
<li>
<p><strong>Implement the logic for dispatching callbacks from the underlying resource to the appropriate client.</strong></p>
<p>We are getting close! At this point, we have a mechanism for adding clients to the virtualizer,
and for queueing and making calls. However, we have not yet addressed how to handle callbacks
from the underlying resource (usually used to forward interrupts up to the appropriate client).
Additionally, our queueing logic is still incomplete, as we have not yet seen when subsequent
operations are triggered if an operation is requested while the underlying device is in use.</p>
<p>Handling callbacks in virtualizers requires two layers of handling. First, the <code>MuxXXX</code> device
must implement the appropriate <code>XXXClient</code> trait such that it can subscribe to callbacks
from the underlying resource, and dispatch them to the appropriate <code>VirtualXXXDevice</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Spi: hil::spi::SpiMaster&gt; hil::spi::SpiMasterClient for MuxSpiMaster&lt;'_, Spi&gt; {
    fn read_write_done(
        &amp;self,
        write_buffer: &amp;'static mut [u8],
        read_buffer: Option&lt;&amp;'static mut [u8]&gt;,
        len: usize,
    ) {
        self.inflight.take().map(move |device| {
            self.do_next_op();
            device.read_write_done(write_buffer, read_buffer, len);
        });
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This takes advantage of the fact that we stored a reference to device that initiated
the inflight operation, so we can dispatch the callback directly to that device.
One thing to note is that the call to <code>take()</code> sets <code>inflight</code> to <code>None</code>, and then 
the callback calls <code>do_next_op()</code>, triggering any still queued operations. This ensures that
all queued operations will take place.
This all requires that the device also has implemented the callback:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;Spi: hil::spi::SpiMaster&gt; hil::spi::SpiMasterClient for VirtualSpiMasterDevice&lt;'_, Spi&gt; {
fn read_write_done(
    &amp;self,
    write_buffer: &amp;'static mut [u8],
    read_buffer: Option&lt;&amp;'static mut [u8]&gt;,
    len: usize,
) {
    self.client.map(move |client| {
        client.read_write_done(write_buffer, read_buffer, len);
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, we have dispatched the callback all the way up to the client of the virtualizer,
completing the round trip process.</p>
</li>
<li>
<p><strong>Document the interface.</strong></p>
<p>Finally, you need to document the interface. Do so by placing a comment at the top
of the file describing what the file does:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Virtualize a SPI master bus to enable multiple users of the SPI bus.

<span class="boring">}
</span></code></pre></pre>
<p>and add doc comments (<code>/// doc comment example</code>) to any new traits created in <code>kernel/src/hil</code>.</p>
</li>
<li>
<p><strong>(Optional) Write tests for the virtualization logic.</strong></p>
<p>Some virtualizers provide additional stress tests of virtualization logic, which can be run on
hardware to perform correct operation in edge cases. For examples of such tests, look at
<code>capsules/src/test/virtual_uart.rs</code> or <code>capsules/src/test/random_alarm.rs</code>.</p>
</li>
</ol>
<h2 id="wrap-up-4"><a class="header" href="#wrap-up-4">Wrap-Up</a></h2>
<p>Congratulations! You have virtualized a resource in the Tock kernel!
We encourage you to submit a pull request to upstream
this to the Tock repository.</p>
<h1 id="implementing-a-kernel-test"><a class="header" href="#implementing-a-kernel-test">Implementing a Kernel Test</a></h1>
<p>This guide covers how to write in-kernel tests of hardware functionality.
For example, if you have implemented a chip peripheral, you may want to write
in-kernel tests of that peripheral to test peripheral-specific functionality
that will not be exposed via the HIL for that peripheral. This guide
outlines the general steps for implementing kernel tests.</p>
<h2 id="setup-3"><a class="header" href="#setup-3">Setup</a></h2>
<p>This guide assumes you have existing chip, board, or architecture specific code
that you wish to test from within the kernel.</p>
<blockquote>
<p>Note: If you wish to test kernel code with no hardware dependencies at all, such as
a ring buffer implementation, you can use cargo's test framework instead. These
tests can be run by simply calling <code>cargo test</code> within the crate that the test
is located, and will be executed during CI for all tests merged into upstream Tock.
An example of this approach can be found in <code>kernel/src/common/ring_buffer.rs</code>.</p>
</blockquote>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>The general steps you will follow are:</p>
<ol>
<li>Determine the board(s) you want to run your tests on</li>
<li>Add a test file in <code>boards/{board}/src/</code></li>
<li>Determine where to write actual tests -- in the test file or a capsule test</li>
<li>Write your tests</li>
<li>Call the test from <code>main.rs</code></li>
<li>Document the expected output from the test at the top of the test file</li>
</ol>
<p>This guide will walk through how to do each of these steps.</p>
<h2 id="background-3"><a class="header" href="#background-3">Background</a></h2>
<p>Kernel tests allow for testing of hardware-specific functionality
that is not exposed to userspace, and allows for fail-fast tests
at boot that otherwise would not be exposed until apps are loaded. Kernel
tests can be useful to test chip peripherals prior to exposing these peripherals
outside the Kernel. Kernel tests can also be included as required tests run prior to releases,
to ensure there have been no regressions for a particular component. Additionally,
kernel tests can be useful for testing capsule functionality from within the
kernel, such as when <code>unsafe</code> is required to verify the results of tests,
or for testing virtualization capsules in a controlled environment.</p>
<p>Kernel tests are generally implemented on an as-needed basis, and are not required
for all chip peripherals in Tock. In general, they are not expected to be run in
the default case, though they should always be included from <code>main.rs</code> so they
are compiled. These tests are allowed to use <code>unsafe</code> as needed, and are
permitted to conflict with normal operation, by stealing callbacks from
drivers or modifying global state.</p>
<p>Notably, your specific use case may differ some from the one outline here.
It is always recommended to attempt to copy from existing Tock code when
developing your own solutions. A good collection of kernel tests can be
found in <code>boards/imix/src/tests/</code> for that purpose.</p>
<h2 id="step-by-step-guide-5"><a class="header" href="#step-by-step-guide-5">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Determine the board(s) you want to run your test on.</strong></p>
<p>If you are testing chip or architecture specific functionality, you simply
need to choose a board that uses that chip or architecture. For board specific
functionality you of course need to choose that board.
If you are testing a virtualization capsule, then any board that implements
the underlying resource being virtualized is acceptable. Currently,
most kernel tests are implemented for the Imix platform, and can be
found in <code>boards/imix/src/tests/</code></p>
<p><strong>Checkpoint</strong>: You have identified the board you will implement your test for.</p>
</li>
<li>
<p><strong>Add a test file in <code>boards/{board}/src/</code></strong></p>
<p>To start implementing the test, you should create a new source
file inside the <code>boards/{board}/src</code> directory. For boards with lots of tests,
like the Imix board, there may be a <code>tests</code> subdirectory -- if so, the test should
go in <code>tests</code> instead, and be added to the <code>tests/mod.rs</code> file.
The name of this test file generally should indicate the functionality being tested.</p>
<blockquote>
<p>Note: If the board you select is one of the nrf52dk variants (nrf52840_dongle,
nrf52840dk, or nrf52dk), tests should be moved into the <code>nrf52dk_base/src/</code> folder,
and called from <code>lib.rs</code>.</p>
</blockquote>
<p><strong>Checkpoint</strong>: You have chosen a board for your test and created a test file.</p>
</li>
<li>
<p><strong>Determine where to write actual tests -- in the test file or a capsule test.</strong></p>
<p>Depending on what you are testing, it may be best practice to write a capsule test
that you call from the test file you created in the previous step.</p>
<p>Writing a capsule test is best practice if your test meets the following criteria:</p>
<ol>
<li>Test does not require <code>unsafe</code></li>
<li>The test is for a peripheral available on multiple boards</li>
<li>A HIL or capsule exists for that peripheral, so it is accessible from the <code>capsules</code> crate</li>
<li>The test relies only on functionality exposed via the HIL or a capsule</li>
<li>You care about being able to call this test from multiple boards</li>
</ol>
<p>Examples:</p>
<ul>
<li>UART Virtualization (all boards support UART, there is a HIL for UART devices and a capsule
for the <code>virtual_uart</code>)</li>
<li>Alarm test (all boards will have some form of hardware alarm, there is an Alarm HIL)</li>
<li>Other examples: see <code>capsules/src/test</code></li>
</ul>
<p>If your test meets the criteria for writing a capsule test, follow these steps:</p>
<p>Add a file in <code>capsules/src/test/</code>, and then add the filename to
<code>capsules/src/mod.rs</code> like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub mod virtual_uart;
<span class="boring">}
</span></code></pre></pre>
<p>Next, create a test struct in this file that can be instantiated by any board
using this test capsule. This struct should implement a <code>new()</code> function so it
can be instantiated from the test file in <code>boards</code>, and a <code>run()</code> function that
will run the actual tests. An example for UART follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! capsules/src/test/virtual_uart.rs

pub struct TestVirtualUartReceive {
    device: &amp;'static UartDevice&lt;'static&gt;,
    buffer: TakeCell&lt;'static, [u8]&gt;,
}

impl TestVirtualUartReceive {
    pub fn new(device: &amp;'static UartDevice&lt;'static&gt;, buffer: &amp;'static mut [u8]) -&gt; Self {
        TestVirtualUartReceive {
            device: device,
            buffer: TakeCell::new(buffer),
        }
    }

    pub fn run(&amp;self) {
        // TODO: See Next Step
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If your test does not meet the above requirements, you can simply implement your tests in the file
that you created in step 2.
This can involve creating a test structure with test methods. The UDP test file takes this approach,
by definining a number of self-contained tests. One such example follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! boards/imix/src/test/udp_lowpan_test.rs

pub struct LowpanTest {
    port_table: &amp;'static UdpPortManager,
    // ...
}

impl LowpanTest {

    // This test ensures that an app and capsule cant bind to the same port
    // but can bind to different ports
    fn bind_test(&amp;self) {
        let create_cap = create_capability!(NetworkCapabilityCreationCapability);
        let net_cap = unsafe {
            static_init!(
                NetworkCapability,
                NetworkCapability::new(AddrRange::Any, PortRange::Any, PortRange::Any, &amp;create_cap)
            )
        };
        let mut socket1 = self.port_table.create_socket().unwrap();
        // Attempt to bind to a port that has already been bound by an app.
        let result = self.port_table.bind(socket1, 1000, net_cap);
        assert!(result.is_err());
        socket1 = result.unwrap_err(); // Get the socket back

        //now bind to an open port
        let (_send_bind, _recv_bind) = self
            .port_table
            .bind(socket1, 1001, net_cap)
            .expect(&quot;UDP Bind fail&quot;);

        debug!(&quot;bind_test passed&quot;);
    }
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Checkpoint</strong>: There is a test capsule with <code>new()</code> and <code>run()</code> implementations.</p>
</li>
<li>
<p><strong>Write your tests</strong></p>
<p>The first part of this step takes place in the test file you just created -- writing
the actual tests. This part is highly dependent on the funcitonality being verified.
If you are writing your tests in test capsule, this should all be  triggered from the <code>run()</code>
function.</p>
<p>Depending on the specifics of your test, you may need to implement additional functions
or traits in this file to make your test functional. One example is implementing a client
trait on the test struct so that the test can receive the results of asynchronous operations.
Our UART example requires implementing the <code>uart::RecieveClient</code> on the test struct.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! boards/imix/src/test/virtual_uart_rx_test.rs

impl TestVirtualUartReceive {
    // ...

    pub fn run(&amp;self) {
        let buf = self.buffer.take().unwrap();
        let len = buf.len();
        debug!(&quot;Starting receive of length {}&quot;, len);
        let (err, _opt) = self.device.receive_buffer(buf, len);
        if err != ReturnCode::SUCCESS {
            panic!(
                &quot;Calling receive_buffer() in virtual_uart test failed: {:?}&quot;,
                err
            );
        }
    }
}

impl uart::ReceiveClient for TestVirtualUartReceive {
    fn received_buffer(
        &amp;self,
        rx_buffer: &amp;'static mut [u8],
        rx_len: usize,
        rcode: ReturnCode,
        _error: uart::Error,
    ) {
        debug!(&quot;Virtual uart read complete: {:?}: &quot;, rcode);
        for i in 0..rx_len {
            debug!(&quot;{:02x} &quot;, rx_buffer[i]);
        }
        debug!(&quot;Starting receive of length {}&quot;, rx_len);
        let (err, _opt) = self.device.receive_buffer(rx_buffer, rx_len);
        if err != ReturnCode::SUCCESS {
            panic!(
                &quot;Calling receive_buffer() in virtual_uart test failed: {:?}&quot;,
                err
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note that the above test calls <code>panic!()</code> in the case of failure. This pattern,
or the similar use of <code>assert!()</code> statements, is the preferred way to communicate
test failures. If communicating errors in this way is not possible, tests
can indicate success/failure by printing different results to the console
in each case and asking users to verify the actual output matches the expected output.</p>
</blockquote>
<p>The next step in this process is determining all of the parameters that need to be passed to
the test. It is preferred that all logically related tests be called from a single
<code>pub unsafe fn run(/* optional args */)</code> to maintain convention. This ensures that all tests can be run
by adding a single line to <code>main.rs</code>. Many tests require a reference to an alarm
in order to seperate tests in time, or a reference to a virtualization capsule that
is being tested. Notably, the <code>run()</code> function should initialize any components itself that
would not have already been created in <code>main.rs</code>.
As an example, the below function is a starting point for the
<code>virtual_uart_receive</code> test for Imix:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn run_virtual_uart_receive(mux: &amp;'static MuxUart&lt;'static&gt;) {
    debug!(&quot;Starting virtual reads.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Next, a test function should initialize any objects required to run tests.
This is best split out into subfunctions, like the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn static_init_test_receive_small(
    mux: &amp;'static MuxUart&lt;'static&gt;,
) -&gt; &amp;'static TestVirtualUartReceive {
    static mut SMALL: [u8; 3] = [0; 3];
    let device = static_init!(UartDevice&lt;'static&gt;, UartDevice::new(mux, true));
    device.setup();
    let test = static_init!(
        TestVirtualUartReceive,
        TestVirtualUartReceive::new(device, &amp;mut SMALL)
    );
    device.set_receive_client(test);
    test
}
<span class="boring">}
</span></code></pre></pre>
<p>This initializes an instance of the test capsule we constructed earlier. Simpler tests
(such as those not relying on capsule tests)
might simply use <code>static_init!()</code> to initialize normal capsules directly and test them.
The log test does this, for example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! boards/imix/src/test/log_test.rs

pub unsafe fn run(
    mux_alarm: &amp;'static MuxAlarm&lt;'static, Ast&gt;,
    deferred_caller: &amp;'static DynamicDeferredCall,
) {
    // Set up flash controller.
    flashcalw::FLASH_CONTROLLER.configure();
    static mut PAGEBUFFER: flashcalw::Sam4lPage = flashcalw::Sam4lPage::new();

    // Create actual log storage abstraction on top of flash.
    let log = static_init!(
        Log,
        log::Log::new(
            &amp;TEST_LOG,
            &amp;mut flashcalw::FLASH_CONTROLLER,
            &amp;mut PAGEBUFFER,
            deferred_caller,
            true
        )
    );
    flash::HasClient::set_client(&amp;flashcalw::FLASH_CONTROLLER, log);
    log.initialize_callback_handle(
        deferred_caller
            .register(log)
            .expect(&quot;no deferred call slot available for log storage&quot;),
    );

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, your <code>run()</code> function should call the actual tests. This may involve simply
calling a <code>run()</code> function on a capsule test, or may involve calling test functions
written in the board specific test file. The virtual UART test <code>run()</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub unsafe fn run_virtual_uart_receive(mux: &amp;'static MuxUart&lt;'static&gt;) {
    debug!(&quot;Starting virtual reads.&quot;);
    let small = static_init_test_receive_small(mux);
    let large = static_init_test_receive_large(mux);
    small.run();
    large.run();
}
<span class="boring">}
</span></code></pre></pre>
<p>As you develop your kernel tests, you may not immediately know what functions are required
in your test capsule -- this is okay! It is often easiest to start with a basic test and expand
this file to test additional functionality once basic tests are working.</p>
<p><strong>Checkpoint</strong>: Your tests are written, and can be called from a single <code>run()</code> function.</p>
</li>
<li>
<p><strong>Call the test from <code>main.rs</code>, and iterate on it until it works</strong></p>
<p>Next, you should run your test by calling it from the <code>reset_handler()</code> in <code>main.rs</code>.
In order to do so, you will also need it import it into the file by adding a line like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
mod virtual_uart_test;
<span class="boring">}
</span></code></pre></pre>
<p>However, if your test is located inside a <code>test</code> module this is not needed -- your test will
already be included.</p>
<p>Typically, tests are called after completing setup of the board, immediately before
the call to <code>load_processes()</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>virtual_uart_rx_test::run_virtual_uart_receive(uart_mux);
debug!(&quot;Initialization complete. Entering main loop&quot;);

extern &quot;C&quot; {
    /// Beginning of the ROM region containing app images.
    static _sapps: u8;

    /// End of the ROM region containing app images.
    ///
    /// This symbol is defined in the linker script.
    static _eapps: u8;
}
kernel::procs::load_processes(
  // ...
<span class="boring">}
</span></code></pre></pre>
<p>Observe your results, and tune or add tests as needed.</p>
<p>Before you submit a PR including any kernel tests, however, please remove or comment out
any lines of code that call these tests.</p>
<p><strong>Checkpoint</strong>: You have a functional test that can be called in a single line from <code>main.rs</code></p>
</li>
<li>
<p><strong>Document the expected output from the test at the top of the test file</strong></p>
<p>For tests that will be merged to upstream, it is good practice to document how to
run a test and what the expected output of a test is. This is best done using<br />
document level coments (<code>//!</code>) at the top of the test file. The documentation
for the virtual UART test follows:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Test reception on the virtualized UART by creating two readers that
//! read in parallel. To add this test, include the line
//! ```
//!    virtual_uart_rx_test::run_virtual_uart_receive(uart_mux);
//! ```
//! to the imix boot sequence, where `uart_mux` is a
//! `capsules::virtual_uart::MuxUart`.  There is a 3-byte and a 7-byte
//! read running in parallel. Test that they are both working by typing
//! and seeing that they both get all characters. If you repeatedly
//! type 'a', for example (0x61), you should see something like:
//! ```
//! Starting receive of length 3
//! Virtual uart read complete: CommandComplete:
//! 61
//! 61
//! 61
//! 61
//! 61
//! 61
//! 61
//! Starting receive of length 7
//! Virtual uart read complete: CommandComplete:
//! 61
//! 61
//! 61
//! ```
<span class="boring">}
</span></code></pre></pre>
<p><strong>Checkpoint</strong>: You have documented your tests</p>
</li>
</ol>
<h2 id="wrap-up-5"><a class="header" href="#wrap-up-5">Wrap-Up</a></h2>
<p>Congratulations! You have written a kernel test for Tock!
We encourage you to submit a pull request to upstream this to the Tock
repository.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
