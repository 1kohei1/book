<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tock Tutorial</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li class="affix"><a href="prerequisites.html">Prerequisites</a></li><li><a href="capsule.html"><strong aria-hidden="true">1.</strong> Tock Course</a></li><li><ol class="section"><li><a href="environment.html"><strong aria-hidden="true">1.1.</strong> Environment</a></li><li><a href="application.html"><strong aria-hidden="true">1.2.</strong> Application</a></li><li><a href="capsule.html"><strong aria-hidden="true">1.3.</strong> Capsule</a></li></ol></li><li><a href="tutorials/tutorials.html"><strong aria-hidden="true">2.</strong> Mini Tutorials</a></li><li><ol class="section"><li><a href="tutorials/01_running_blink.html"><strong aria-hidden="true">2.1.</strong> Blink an LED</a></li><li><a href="tutorials/02_button_print.html"><strong aria-hidden="true">2.2.</strong> Button to Printf()</a></li><li><a href="tutorials/03_ble_scan.html"><strong aria-hidden="true">2.3.</strong> BLE Advertisement Scanning</a></li><li><a href="tutorials/04_sensors_and_drivers.html"><strong aria-hidden="true">2.4.</strong> Sample Sensors and Use Drivers</a></li><li><a href="tutorials/05_ipc.html"><strong aria-hidden="true">2.5.</strong> Inter-process Communication</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Tock Tutorial</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#tock-os-book" id="tock-os-book">Tock OS Book</a></h1>
<p>This book introduces you to Tock, a secure embedded operating system for sensor
networks and the Internet of Things. Tock is the first operating system to allow
multiple untrusted applications to run concurrently on a microcontroller-based
computer. The Tock kernel is written in Rust, a memory-safe systems language
that does not rely on a garbage collector. Userspace applications are run in
single-threaded processes that can be written in any language.</p>
<p>The book is divided into two sections: the course and a series of mini
tutorials. The course is a good place to start, and provides a structured
introduction to Tock that should take a few hours to complete (it was designed
for a half day workshop). The tutorials are smaller examples that highlight
specific features.</p>
<h2><a class="header" href="#tock-course" id="tock-course">Tock Course</a></h2>
<p>In this hands-on guide, we will look at some of the high-level services provided
by Tock.  We will start with an understanding of the OS and its programming
environment.  Then we'll look at how a process management application can help
afford remote debugging, diagnosing and fixing a resource-intensive app over the
network.  The last part of the tutorial is a bit more free-form, inviting
attendees to further explore the networking and application features of Tock or
to dig into the kernel a bit and explore how to enhance and extend the kernel.</p>
<p>This course assumes some experience programming embedded devices and fluency in
C. It assumes no knowledge of Rust, although knowing Rust will allow you to be
more creative during the kernel exploration at the end.</p>
<h3><a class="header" href="#course-outline" id="course-outline">Course Outline</a></h3>
<p>You should first make sure you have the <a href="prerequisites.html">requisite</a>
hardware and software to complete the guide.</p>
<p>The guide is divided into sections, each with an brief introduction to
introduce concepts, followed by hands-on excercises.</p>
<ol>
<li>
<p><a href="environment.html">Environment Setup</a>: Get familiar with the Tock tools
and getting a board setup.</p>
</li>
<li>
<p><a href="application.html">Userland programming</a>: write a basic sensing application in C.</p>
</li>
<li>
<p><a href="capsule.html">Kernel programming</a>: understand the kernel's boot sequence and
write a simple driver in Rust.</p>
</li>
</ol>
<h2><a class="header" href="#tock-mini-tutorials" id="tock-mini-tutorials">Tock Mini Tutorials</a></h2>
<p>These <a href="./tutorials/tutorials.html">tutorials</a> feature specific examples of Tock
applications. They can be completed after the course to learn about different
capabilities of Tock apps.</p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<p>We will go over setting up a development environment during the course and help
out with possible problems you run into. You must ensure you have the proper
hardware before you begin---an development board and a workstation---and
software development environment.</p>
<h2><a class="header" href="#hardware" id="hardware">Hardware</a></h2>
<p>To complete the hands-on exercises in this guide, you'll need an <em>imix</em>
hardware platform (pictured below), a workstation running either Linux or OS X
(you can also work in a <a href="prerequisites.html#virtual-machine">Virtual Machine</a>), and a micro-USB
cable to connect your imix to your workstation.</p>
<p>To complete the 6LoWPAN networking portion of this guide, you'll need an
additional <em>imix</em> to act as a hub, but multiple participants can use the same
hub <em>imix</em>.</p>
<p><img src="../imgs/imix.svg" alt="" /></p>
<h2><a class="header" href="#software" id="software">Software</a></h2>
<p>You can either download a <a href="prerequisites.html#virtual-machine">virtual machine</a> with all
development environment pre-installed (<strong>RECOMMENDED</strong>), or, if you have a Linux or OS X
workstation, you may install the development environment
<a href="prerequisites.html#native-installation">natively</a>. Using a virtual machine is quicker and easier
to set up, while installing natively will yield the most comfortable
development environment and is better for long term use.</p>
<h3><a class="header" href="#virtual-machine" id="virtual-machine">Virtual Machine</a></h3>
<p>If you're comfortable working inside a Debian virtual machine, you can download
an image with all of the dependencies already installed
<a href="https://cesar.cs.princeton.edu/Tock.ova">here</a> or
<a href="https://www.cs.virginia.edu/%7Ebjc8c/archive/Tock.ova">here</a>. Using <code>curl</code> to
download the image is recommended, but your browser should be able to download
it as well:</p>
<pre><code>$ curl -O &lt;url&gt;
</code></pre>
<p>With the virtual machine image downloaded, you can run it with VirtualBox or
VMWare:</p>
<ul>
<li>VirtualBox users: <a href="https://docs.oracle.com/cd/E26217_01/E26796/html/qs-import-vm.html">File → Import Appliance...</a>,</li>
<li>VMWare users: <a href="https://pubs.vmware.com/workstation-9/index.jsp?topic=%2Fcom.vmware.ws.using.doc%2FGUID-DDCBE9C0-0EC9-4D09-8042-18436DA62F7A.html">File → Open...</a></li>
</ul>
<p>The VM account is &quot;tock&quot; with password &quot;tock&quot;. Feel free to customize it with
whichever editors, window managers, etc. you like before the training starts.</p>
<blockquote>
<p>If the Host OS is Linux, you may need to add your user to the <code>vboxusers</code>
group on your machine in order to connect the hardware boards to the virtual
machine.</p>
</blockquote>
<h3><a class="header" href="#native-installation" id="native-installation">Native Installation</a></h3>
<p>If you choose to install the development environment natively on an existing
operating system install, you will need the following software:</p>
<ol>
<li>
<p>Command line utilities: <code>curl</code>, <code>make</code>, and <code>git</code>.</p>
</li>
<li>
<p>Python 3 and <code>pip3</code></p>
</li>
<li>
<p>A local clone of this book source, containing the exercises</p>
<pre><code> $ git clone https://github.com/tock/book.git tock-book
</code></pre>
</li>
<li>
<p><a href="http://rustup.rs/">rustup</a>. This tool helps manage installations of the
Rust compiler and related tools.</p>
<pre><code> $ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>and the Rust core libraries for the Cortex-M4:</p>
<pre><code> $ rustup target add thumbv7em-none-eabi
</code></pre>
</li>
<li>
<p><a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">arm-none-eabi toolchain</a> (version &gt;= 5.2)</p>
<pre><code> # mac
 $ brew tap ARMmbed/homebrew-formulae &amp;&amp; brew update &amp;&amp; brew install arm-none-eabi-gcc

 # linux
 $ sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa &amp;&amp; sudo apt update &amp;&amp; sudo apt install gcc-arm-embedded
</code></pre>
<p>OS-specific installation instructions can be found
<a href="https://github.com/tock/tock/blob/master/doc/Getting_Started.md#arm-none-eabi-toolchain">here</a></p>
</li>
<li>
<p><a href="https://crates.io/crates/elf2tab/">elf2tab</a></p>
<pre><code> $ cargo install elf2tab
</code></pre>
</li>
<li>
<p><a href="https://github.com/tock/tockloader">tockloader</a></p>
<pre><code> $ pip3 install -U --user tockloader
</code></pre>
<blockquote>
<p>Note: On MacOS, you may need to add <code>tockloader</code> to your path. If you
cannot run it after installation, run the following:</p>
</blockquote>
<pre><code> $ export PATH=$HOME/Library/Python/3.6/bin/:$PATH
</code></pre>
<blockquote>
<p>Similarly, on Linux distributions, this will typically install to
<code>$HOME/.local/bin</code>, and you may need to add that to your <code>$PATH</code> if not
already present:</p>
</blockquote>
<pre><code> $ PATH=$HOME/.local/bin:$PATH
</code></pre>
</li>
</ol>
<h3><a class="header" href="#testing" id="testing">Testing</a></h3>
<p>To test if your environment is working, go to the <code>tock/boards/imix</code> directory
and type <code>make program</code>. This should compile the kernel for the default board,
Imix, and try to program it over a USB serial connection. It may need to compile
several supporting libraries first (so may take 30 seconds or so the first
time). You should see output like this:</p>
<pre><code>$ make program
   Compiling tock-registers v0.2.0 (file:///Users/bradjc/git/tock/libraries/tock-register-interface)
   Compiling tock-cells v0.1.0 (file:///Users/bradjc/git/tock/libraries/tock-cells)
   Compiling enum_primitive v0.1.0 (file:///Users/bradjc/git/tock/libraries/enum_primitive)
   Compiling imix v0.1.0 (file:///Users/bradjc/git/tock/boards/imix)
   Compiling kernel v0.1.0 (file:///Users/bradjc/git/tock/kernel)
   Compiling cortexm v0.1.0 (file:///Users/bradjc/git/tock/arch/cortex-m)
   Compiling capsules v0.1.0 (file:///Users/bradjc/git/tock/capsules)
   Compiling cortexm4 v0.1.0 (file:///Users/bradjc/git/tock/arch/cortex-m4)
   Compiling sam4l v0.1.0 (file:///Users/bradjc/git/tock/chips/sam4l)
    Finished release [optimized + debuginfo] target(s) in 23.89s
   text    data     bss     dec     hex filename
 148192    5988   34968  189148   2e2dc target/thumbv7em-none-eabi/release/imix
tockloader  flash --address 0x10000 target/thumbv7em-none-eabi/release/imix.bin
No device name specified. Using default &quot;tock&quot;
No serial ports found. Is the board connected?

make: *** [program] Error 1
</code></pre>
<p>That is, since you don't yet have a board plugged in it can't program it. But
the above output indicates that it can compile correctly and invoke <code>tockloader</code>
to program a board.</p>
<h1><a class="header" href="#capsule" id="capsule">Capsule</a></h1>
<p>The goal of this part of the course is to make you comfortable with the
Tock kernel and writing code for it. By the end of this part, you'll have
written a new capsule that reads a humidity sensor and outputs its readings
over the serial port.</p>
<p>During this you will:</p>
<ol>
<li>Learn how Tock uses Rust's memory safety to provide isolation for free</li>
<li>Read the Tock boot sequence, seeing how Tock uses static allocation</li>
<li>Learn about Tock's event-driven programming</li>
<li>Write a new capsule that reads a humidity sensor and prints it over serial</li>
</ol>
<h2><a class="header" href="#read-the-tock-boot-sequence-20m" id="read-the-tock-boot-sequence-20m">Read the Tock boot sequence (20m)</a></h2>
<p>Open <code>imix/src/main.rs</code> in your favorite editor. This file defines the
imix platform: how it boots, what capsules it uses, and what system calls it
supports for userland applications.</p>
<h3><a class="header" href="#how-is-everything-organized" id="how-is-everything-organized">How is everything organized?</a></h3>
<p>Find the declaration of <code>struct Imix</code> (it's pretty early in the file).
This declares the structure representing the platform. It has many fields,
all of which are capsules. These are the capsules that make up the imix
platform. For the most part, these map directly to hardware peripherals,
but there are exceptions such as <code>IPC</code> (inter-process communication).</p>
<p>Recall the discussion about how everything in the kernel is statically
allocated? We can see that here. Every field in <code>struct Imix</code> is a reference to
an object with a static lifetime.</p>
<p>The capsules themselves take a lifetime as a parameter, which is currently
always <code> `static</code>.  The implementations of these capsules, however, do not
rely on this assumption.</p>
<p>The boot process is primarily the construction of this <code>Imix</code> structure. Once
everything is set up, the board will pass the constructed <code>imix</code> to
<code>kernel::kernel_loop</code> and we're off to the races.</p>
<h3><a class="header" href="#how-do-things-get-started" id="how-do-things-get-started">How do things get started?</a></h3>
<p>The method <code>reset_handler</code> is invoked when the chip resets (i.e., boots).
It's pretty long because imix has a lot of drivers that need to be created
and initialized, and many of them depend on other, lower layer abstractions
that need to be created and initialized as well.</p>
<p>Take a look at the first few lines of the <code>reset_handler</code>. The boot sequence
initializes memory (copies initialized variables into RAM, clears the BSS),
sets up the system clocks, and configures the GPIO pins.</p>
<h3><a class="header" href="#how-do-capsules-get-created" id="how-do-capsules-get-created">How do capsules get created?</a></h3>
<p>The next lines of <code>reset_handler</code> create and initialize the system console,
which is what turns calls to <code>println</code> into bytes sent to the USB serial port:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let uart_mux = static_init!(
    MuxUart&lt;'static&gt;,
    MuxUart::new(
        &amp;sam4l::usart::USART3,
        &amp;mut capsules::virtual_uart::RX_BUF,
        115200
    )
);
uart_mux.initialize();

hil::uart::Transmit::set_transmit_client(&amp;sam4l::usart::USART3, uart_mux);
hil::uart::Receive::set_receive_client(&amp;sam4l::usart::USART3, uart_mux);

let console = ConsoleComponent::new(board_kernel, uart_mux).finalize();
#}</code></pre></pre>
<p>Eventually, once all of the capsules have been created, we will populate
a imix structure with them:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let imix = Imix {
    console: console,
    gpio: gpio,
    ...
#}</code></pre></pre>
<p>The <code>static_init!</code> macro is simply an easy way to allocate a static
variable with a call to <code>new</code>. The first parameter is the type, the second
is the expression to produce an instance of the type. This call creates
a <code>Console</code> that uses serial port 3 (<code>USART3</code>) at 115200 bits per second.</p>
<blockquote>
<h4><a class="header" href="#a-brief-aside-on-buffers" id="a-brief-aside-on-buffers">A brief aside on buffers:</a></h4>
<p>Notice that you have to pass a write buffer to the console for it to use:
this buffer has to have a <code> `static</code> lifetime. This is because low-level
hardware drivers, especially those that use DMA, require <code> `static</code> buffers.
Since Tock doesn't promise when a DMA operation will complete, and you
need to be able to promise that the buffer outlives the operation, the
one lifetime that is assured to be alive at the end of an operation is
<code> `static</code>. So that other code which has buffers
without a <code> `static</code> lifetime, such as userspace processes, can use the
<code>Console</code>, it copies them into its own internal <code> `static</code> buffer before
passing it to the serial port. So the buffer passing architecture looks like
this:</p>
<p><img src="console.png" alt="Console/UART buffer lifetimes" /></p>
<p>It's a little weird that Console's <code>new</code> method takes in a reference to
itself. This is an ergonomics tradeoff. The Console needs a mutable static
buffer to use internally, which the Console capsule declares. However writing
global statics is unsafe. To avoid the unsafe operation in the Console
capsule itself, we make it the responsibility of the instantiator to give the
Console a buffer to use, without burdening the instantiator with sizing the
buffer.</p>
</blockquote>
<h3><a class="header" href="#lets-make-an-imix" id="lets-make-an-imix">Let's make an imix!</a></h3>
<p>The code continues on, creating all of the other capsules that are needed
by the imix platform. By the time we get down to around line 360, we've
created all of the capsules we need, and it's time to create the actual
imix platform structure (<code>let imix = Imix {</code> ...).</p>
<h3><a class="header" href="#capsule-initialization" id="capsule-initialization">Capsule <em>initialization</em></a></h3>
<p>Up to this point we have been creating numerous structures and setting some
static configuration options and mappings, but nothing dynamic has occurred
(said another way, all methods invoked by <code>static_init!</code> must be <code>const fn</code>,
however Tock's <code>static_init!</code> macro predates stabilization of <code>const fn</code>'s.
A future iteration could possibly leverage these and obviate the need for the
macro).</p>
<p>Some capsules require <em>initialization</em>, some code that must be executed
before they can be used. For example, a few lines after creating the imix
struct, we initialize the console:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
imix.nrf51822.initialize();
#}</code></pre></pre>
<p>This method is responsible for actually writing the hardware registers that
configure the associated UART peripheral for use as a text console
(8 data bits, 1 stop bit, no parity bit, no hardware flow control).</p>
<h3><a class="header" href="#inter-capsule-dependencies" id="inter-capsule-dependencies">Inter-capsule dependencies</a></h3>
<p>Just after initializing the console capsule, we find this line:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::debug::assign_console_driver(Some(imix.console), kc);
#}</code></pre></pre>
<p>This configures the kernel's <code>debug!</code> macro to print messages to this console
we've just created. The <code>debug!</code> mechanism can be very helpful during
development and testing. Today we're going to use it to print output from the
capsule you create.</p>
<p>Let's try it out really quick:</p>
<pre><code class="language-diff">--- a/boards/imix/src/main.rs
+++ b/boards/imix/src/main.rs
@@ -10,7 +10,7 @@
 extern crate capsules;
 extern crate cortexm4;
 extern crate compiler_builtins;
-#[macro_use(static_init)]
+#[macro_use(debug, static_init)]
 extern crate kernel;
 extern crate sam4l;

@@ -388,6 +388,8 @@ pub unsafe fn reset_handler() {
         capsules::console::App::default());
     kernel::debug::assign_console_driver(Some(imix.console), kc);

+    debug!(&quot;Testing 1, 2, 3...&quot;);
+
     imix.nrf51822.initialize();
</code></pre>
<p>Compile and flash the kernel (<code>make program</code>) then look at the output
(<code>tockloader listen</code>).</p>
<ul>
<li>What happens if you put the <code>debug!</code> before <code>assign_console_driver</code>?</li>
<li>What happens if you put <code>imix.console.initialize()</code> after
<code>assign_console_driver</code>?</li>
</ul>
<p>As you can see, sometimes there are dependencies between capsules, and board
authors must take care during initialization to ensure correctness.</p>
<blockquote>
<p><strong>Note:</strong> The <code>debug!</code> implementation is <em>asynchronous</em>. It copies messages
into a buffer and the console prints them via DMA as the UART peripheral is
available, interleaved with other console users (i.e. processes). You
shouldn't need to worry about the mechanics of this for now.</p>
</blockquote>
<h3><a class="header" href="#loading-processes" id="loading-processes">Loading processes</a></h3>
<p>Once the platform is all set up, the board is responsible for loading processes
into memory:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::process::load_processes(&amp;_sapps as *const u8,
                                &amp;mut APP_MEMORY,
                                &amp;mut PROCESSES,
                                FAULT_RESPONSE);
#}</code></pre></pre>
<p>A Tock process is represented by a <code>kernel::Process</code> struct. In principle, a
platform could load processes by any means. In practice, all existing platforms
write an array of Tock Binary Format (TBF) entries to flash. The kernel provides
the <code>load_processes</code> helper function that takes in a flash address and begins
iteratively parsing TBF entries and making <code>Process</code>es.</p>
<h3><a class="header" href="#starting-the-kernel" id="starting-the-kernel">Starting the kernel</a></h3>
<p>Finally, the board passes a reference to the current platform, the chip the
platform is built on (used for interrupt and power handling), the processes to
run, and an IPC server instance to the main loop of the kernel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::main(&amp;imix, &amp;mut chip, &amp;mut PROCESSES, &amp;imix.ipc);
#}</code></pre></pre>
<p>From here, Tock is initialized, the kernel event loop takes over, and the
system enters steady state operation.</p>
<h3><a class="header" href="#create-a-hello-world-capsule" id="create-a-hello-world-capsule">Create a &quot;Hello World&quot; capsule</a></h3>
<p>Now that you've seen how Tock initializes and uses capsules, you're going to
write a new one. At the end of this section, your capsule will sample the
humidity sensor once a second and print the results as serial output. But
you'll start with something simpler: printing &quot;Hello World&quot; to the debug
console once on boot.</p>
<p>The <code>imix</code> board configuration you've looked through has a capsule for the this
tutorial already set up. The capsule is a separate Rust crate located in
<code>excercises/capsule</code>. You'll complete this excercise by filling it in.</p>
<p>In addition to a constructor, Our capsule has <code>start</code> function defined that is
currently empty. The board configuration calls this function once it has
initialized the capsule.</p>
<p>Eventually, the <code>start</code> method will kick off a state machine for periodic
humidity readings, but for now, let's just print something to the debug console
and return:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
debug!(&quot;Hello from the kernel!&quot;);
#}</code></pre></pre>
<pre><code class="language-bash">$ cd [PATH_TO_BOOK]/imix
$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Hello from the kernel!
</code></pre>
<h2><a class="header" href="#extend-your-capsule-to-print-hello-world-every-second" id="extend-your-capsule-to-print-hello-world-every-second">Extend your capsule to print &quot;Hello World&quot; every second</a></h2>
<p>In order for your capsule to keep track of time, it will need to depend on
another capsule that implements the Alarm interface. We'll have to do something
similar for reading the accelerometer, so this is good practice.</p>
<p>The Alarm HIL includes several traits, <code>Alarm</code>, <code>Client</code>, and <code>Frequency</code>, all
in the <code>kernel::hil::time</code> module. You'll use the <code>set_alarm</code> and <code>now</code> methods
from the <code>Alarm</code> trait to set an alarm for a particular value of the clock.
Note that both methods accept arguments in the alarm's native clock frequency,
which is available using the Alarm trait's associated <code>Frequency</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// native clock frequency in Herz
let frequency = &lt;A::Frequency&gt;::frequency();
#}</code></pre></pre>
<p>Your capsule already implements the <code>alarm::Client</code> trait so it can receive
alarm events. The <code>alarm::Client</code> trait has a single method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fired(&amp;self)
#}</code></pre></pre>
<p>Your capsule should now set an alarm in the <code>start</code> method, print the debug
message and set an alarm again when the alarm fires.</p>
<p>Compile and program your new kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
</code></pre>
<p><a href="https://gist.github.com/alevy/73fca7b0dddcb5449088cebcbfc035f1">Sample Solution</a></p>
<h2><a class="header" href="#extend-your-capsule-to-sample-the-humidity-once-a-second" id="extend-your-capsule-to-sample-the-humidity-once-a-second">Extend your capsule to sample the humidity once a second</a></h2>
<p>The steps for reading an accelerometer from your capsule are similar to using
the alarm. You'll use a capsule that implements the humidity HIL, which
includes the <code>HumidityDriver</code> and <code>HumidityClient</code> traits, both in
<code>kernel::hil::sensors</code>.</p>
<p>The <code>HumidityDriver</code> trait includes the method <code>read_accelerometer</code> which
initiates an accelerometer reading. The <code>HumidityClient</code> trait has a single
method for receiving readings:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn callback(&amp;self, humidity: usize);
#}</code></pre></pre>
<p>Implement logic to initiate a accelerometer reading every second and report the
results.</p>
<p><img src="rustconf.png" alt="Structure of rustconf capsule" /></p>
<p>Compile and program your kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Humidity 2731
Humidity 2732
</code></pre>
<p><a href="https://gist.github.com/alevy/798d11dbfa5409e0aa56d870b4b7afcf">Sample solution</a></p>
<h2><a class="header" href="#some-further-questions-and-directions-to-explore" id="some-further-questions-and-directions-to-explore">Some further questions and directions to explore</a></h2>
<p>Your capsule used the si7021 and virtual alarm. Take a look at the
code behind each of these services:</p>
<ol>
<li>
<p>Is the humidity sensor on-chip or a separate chip connected over a bus?</p>
</li>
<li>
<p>What happens if you request two humidity sensors back-to-back?</p>
</li>
<li>
<p>Is there a limit on how many virtual alarms can be created?</p>
</li>
<li>
<p>How many virtual alarms does the imix boot sequence create?</p>
</li>
</ol>
<h3><a class="header" href="#extra-credit-write-a-virtualization-capsule-for-humidity-sensor-" id="extra-credit-write-a-virtualization-capsule-for-humidity-sensor-"><strong>Extra credit</strong>: Write a virtualization capsule for humidity sensor (∞)</a></h3>
<p>If you have extra time, try writing a virtualization capsule for the <code>Humidity</code>
HIL that will allow multiple clients to use it. This is a fairly open ended
task, but you might find inspiration in the <code>virtua_alarm</code> and <code>virtual_i2c</code>
capsules.</p>
<h1><a class="header" href="#environment" id="environment">Environment</a></h1>
<p>The goal of this part of the course is to make sure you have a working
development environment for Tock.</p>
<p>During this portion of the course you will:</p>
<ul>
<li>Get a high-level overview of how Tock works.</li>
<li>Learn how to compile and flash the kernel onto an Imix board.</li>
</ul>
<h2><a class="header" href="#compile-and-program-the-kernel" id="compile-and-program-the-kernel">Compile and program the kernel</a></h2>
<p>All of the hands-on excercises will be done within the source code for this
book. So pop open a terminal, and navigate to the repository. If you're using
the VM, that'll be:</p>
<pre><code>$ cd ~/book
</code></pre>
<h3><a class="header" href="#make-sure-your-tock-repository-is-up-to-date" id="make-sure-your-tock-repository-is-up-to-date">Make sure your Tock repository is up to date</a></h3>
<pre><code>$ git pull
</code></pre>
<h3><a class="header" href="#build-the-kernel" id="build-the-kernel">Build the kernel</a></h3>
<p>To build the kernel, just type make in the <code>imix/</code> subdirectory.</p>
<pre><code>$ cd imix/
$ make
</code></pre>
<p>If this is the first time you are trying to make the kernel, the build system
will use cargo and rustup to install various Tock dependencies.</p>
<p>If this is your first time building a Tock kernel for this particular
architecture, you may get an error complaining that you don't have the proper
the <code>cargo</code> target installed. We can use <code>rustup</code> to fix that:</p>
<pre><code>$ rustup target add thumbv7em-none-eabi 
</code></pre>
<blockquote>
<p><code>imix</code> is based around an ARM Cortex-M4 microcontroller, which uses the
thumbv7em instruction set. The rustup command above just downloads Rust core
libraries for this architecture.</p>
</blockquote>
<h3><a class="header" href="#connect-to-an-imix-board" id="connect-to-an-imix-board">Connect to an imix board</a></h3>
<blockquote>
<h4><a class="header" href="#one-time-fixups" id="one-time-fixups">One-Time Fixups</a></h4>
<ul>
<li>
<p>On Linux, you might need to give your user access to the imix's serial port.
If you are using the VM, this is already done for you.
You can do this by adding a udev rule:</p>
<pre><code>$ sudo bash -c &quot;echo 'ATTRS{idVendor}==\&quot;0403\&quot;, ATTRS{idProduct}==\&quot;6015\&quot;, MODE=\&quot;0666\&quot;' &gt; /etc/udev/rules.d/99-imix&quot;
</code></pre>
<p>Afterwards, detach and re-attach the imix to reload the rule.</p>
</li>
<li>
<p>With the virtual machine, you might need to attach the USB device to the
VM. To do so, after plugging in imix, select in the VirtualBox/VMWare menu bar:</p>
<pre><code>Devices -&gt; USB Devices -&gt; imix IoT Module - TockOS
</code></pre>
<p>If this generates an error, often unplugging/replugging fixes it. You can also
create a rule in the VM USB settings which will auto-attach the imix to the VM.</p>
</li>
</ul>
</blockquote>
<p>To connect your development machine to the imix, connect them with a micro-USB
cable. Any cable will do, but notice that there are two USB ports on the imix.
Make sure you connect to the micro-USB port labeled 'debug' on the imix.</p>
<p>The imix board should appear as a regular serial device (e.g.
<code>/dev/tty.usbserial-c098e5130006</code> on my Mac and <code>/dev/ttyUSB0</code> on my Linux box).
While you can connect with any standard serial program (set to 115200 baud),
tockloader makes this easier. Tockloader can read attributes from connected
serial devices, and will automatically find your connected imix. Simply run:</p>
<pre><code>$ tockloader listen
No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/ttyUSB0 - Imix - TockOS&quot;

Listening for serial output.
Initialization complete. Entering main loop
Hello World!
</code></pre>
<h3><a class="header" href="#flash-the-kernel" id="flash-the-kernel">Flash the kernel</a></h3>
<p>Now that the imix board is connected and you have verified that the kernel
compiles, we can flash the imix board with the latest Tock kernel:</p>
<pre><code>$ cd imix/
$ make program
</code></pre>
<p>This command will compile the kernel if needed, and then use <code>tockloader</code> to
flash it onto the imix.</p>
<h3><a class="header" href="#install-some-applications" id="install-some-applications">Install some applications</a></h3>
<p>We have the kernel flashed, but the kernel doesn't actually <em>do</em> anything.
Applications do! We're going to install some pre-built applications, but first,
let's make sure we're in a clean state, in case your imix already had some
applications installed.</p>
<pre><code>$ tockloader erase-apps
</code></pre>
<p>This command removes any processes that may have already been installed.</p>
<p>Now, let's install two pre-compiled example apps.</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/blink.tab
</code></pre>
<p>The board should restart and the user LED should start blinking. Let's also
install a simple &quot;Hello World&quot; application:</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/c_hello.tab
</code></pre>
<blockquote>
<p>The <code>install</code> subcommand takes a path or URL to an TAB (Tock Application Binary) file to install.</p>
</blockquote>
<h3><a class="header" href="#clear-out-the-applications-and-re-flash-the-test-app" id="clear-out-the-applications-and-re-flash-the-test-app">Clear out the applications and re-flash the test app.</a></h3>
<p>Lets check what's on the board right now:</p>
<pre><code>$ tockloader list
...
[App 0]
  Name:                  blink
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes

[App 1]
  Name:                  c_hello
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   1024 bytes
</code></pre>
<p>As you can see, the old apps are still installed on the board.
This also nicely demonstrates that user applications are isolated from the
kernel: it is possible to update one independently of the other.
We can remove apps with the following command:</p>
<pre><code>$ tockloader uninstall
</code></pre>
<p>Following the prompt, if you remove the <code>blink</code> app, the LED will stop
blinking, however the console will still print <code>Hello World</code>.</p>
<p>Now let's try adding a more interesting app:</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/sensors.tab
</code></pre>
<p>The <code>sensors</code> app will automatically discover all available sensors,
sample them once a second, and print the results.</p>
<pre><code>Listening for serial output.
Starting process console
Initialization complete. Entering main loop
[Sensors] Starting Sensors App.
Hello World!
[Sensors] All available sensors on the platform will be sampled.
ISL29035:   Light Intensity: 453
Temperature:                 24 deg C
Humidity:                    63%

ISL29035:   Light Intensity: 453
Temperature:                 24 deg C
Humidity:                    63%
</code></pre>
<h2><a class="header" href="#familiarize-yourself-with-tockloader-commands" id="familiarize-yourself-with-tockloader-commands">Familiarize yourself with <code>tockloader</code> commands</a></h2>
<p>The <code>tockloader</code> tool is a useful and versatile tool for managing and installing
applications on Tock. It supports a number of commands, and a more complete
list can be found in the tockloader repository, located at
<a href="https://github.com/tock/tockloader#usage">github.com/tock/tockloader</a>.
Below is a list of the more useful and important commands for programming and
querying a board.</p>
<h3><a class="header" href="#tockloader-install" id="tockloader-install"><code>tockloader install</code></a></h3>
<p>This is the main tockloader command, used to load Tock applications onto a
board.  By default, <code>tockloader install</code> adds the new application, but does not
erase any others, replacing any already existing application with the same
name.  Use the <code>--no-replace</code> flag to install multiple copies of the same app.
In order to install an app, either specify the <code>tab</code> file as an argument, or
navigate to the app's source directory, build it (probably using <code>make</code>), then
issue the install command:</p>
<pre><code>$ tockloader install
</code></pre>
<blockquote>
<p><em>Tip:</em> You can add the <code>--make</code> flag to have tockloader automatically
run make before installing, i.e. <code>tockloader install --make</code></p>
</blockquote>
<blockquote>
<p><em>Tip:</em> You can add the <code>--erase</code> flag to have tockloader automatically
remove other applications when installing a new one.</p>
</blockquote>
<h3><a class="header" href="#tockloader-uninstall-application-names" id="tockloader-uninstall-application-names"><code>tockloader uninstall [application name(s)]</code></a></h3>
<p>Removes one or more applications from the board by name.</p>
<h3><a class="header" href="#tockloader-erase-apps" id="tockloader-erase-apps"><code>tockloader erase-apps</code></a></h3>
<p>Removes all applications from the board.</p>
<h3><a class="header" href="#tockloader-list" id="tockloader-list"><code>tockloader list</code></a></h3>
<p>Prints basic information about the apps currently loaded onto the board.</p>
<h3><a class="header" href="#tockloader-info" id="tockloader-info"><code>tockloader info</code></a></h3>
<p>Shows all properties of the board, including information about currently
loaded applications, their sizes and versions, and any set attributes.</p>
<h3><a class="header" href="#tockloader-listen" id="tockloader-listen"><code>tockloader listen</code></a></h3>
<p>This command prints output from Tock apps to the terminal. It listens via UART,
and will print out anything written to stdout/stderr from a board.</p>
<blockquote>
<p><em>Tip:</em> As a long-running command, <code>listen</code> interacts with other tockloader
sessions. You can leave a terminal window open and listening. If another
tockloader process needs access to the board (e.g. to install an app update),
tockloader will automatically pause and resume listening.</p>
</blockquote>
<h3><a class="header" href="#tockloader-flash" id="tockloader-flash"><code>tockloader flash</code></a></h3>
<p>Loads binaries onto hardware platforms that are running a compatible bootloader.
This is used by the Tock Make system when kernel binaries are programmed to the
board with <code>make program</code>.</p>
<h2><a class="header" href="#explore-other-example-applications" id="explore-other-example-applications">Explore other example applications</a></h2>
<p>Other applications can be found in the <code>examples</code> subdirectory of the libtock-c repository:</p>
<pre><code>$ git clone https://github.com/tock/libtock-c
</code></pre>
<p>Try loading them on your imix and then try modifying them. By default,
<code>tockloader install</code> adds the new application, but does not erase any others.
Be aware, not all applications will work well together if they need the same
resources (Tock is in active development to add virtualization to all resources
to remove this issue!).</p>
<p><strong>Note:</strong> By default, the imix platform is limited to only running four
concurrent processes at once. Tockloader is (currently) unaware of this
limitation, and will allow to you to load additional apps. However the kernel
will only load the first four apps. One option for the free-form section at the
end of the tutorial will be to explore this limitation and allow more apps.</p>
<h1><a class="header" href="#write-an-environment-sensing-application" id="write-an-environment-sensing-application">Write an environment sensing application</a></h1>
<h2><a class="header" href="#process-overview-relocation-model-and-system-call-api" id="process-overview-relocation-model-and-system-call-api">Process overview, relocation model and system call API</a></h2>
<p>In this section, we're going to learn about processes (a.k.a applications) in
Tock, and build our own applications in C.</p>
<h2><a class="header" href="#get-a-c-application-running-on-your-board" id="get-a-c-application-running-on-your-board">Get a C application running on your board</a></h2>
<p>You'll find the outline of a C application in the directory
<code>exercises/app</code>.</p>
<p>Take a look at the code in <code>main.c</code>. So far, this application merely prints
&quot;Hello, World!&quot;.</p>
<p>The code uses the standard C library routine <code>printf</code> to compose a message
using a format string and print it to the console. Let's break down what the
code layers are here:</p>
<ol>
<li>
<p><code>printf</code> is provided by the C standard library (implemented by
<a href="https://sourceware.org/newlib/">newlib</a>). It takes the format string and
arguments, and generates an output string from them. To actually write the
string to standard out, <code>printf</code> calls <code>_write</code>.</p>
</li>
<li>
<p><code>_write</code> (in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/sys.c"><code>sys.c</code></a>) is a
wrapper for actually writing to output streams (in this case, standard out
a.k.a. the console). It calls the Tock-specific console writing function
<code>putnstr</code>.</p>
</li>
<li>
<p><code>putnstr</code>(in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/console.c"><code>console.c</code></a>)
is a buffers data to be written, calls <code>putnstr_async</code>, and acts as a
synchronous wrapper, yielding until the operation is complete.</p>
</li>
<li>
<p>Finally, <code>putnstr_async</code> (in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/console.c"><code>console.c</code></a>)
performs the actual system calls, calling to <code>allow</code>, <code>subscribe</code>, and
<code>command</code> to enable the kernel to access the buffer, request a callback when
the write is complete, and begin the write operation respectively.</p>
</li>
</ol>
<p>The application could accomplish all of this by invoking Tock system calls
directly, but using libraries makes for a much cleaner interface and allows
users to not need to know the inner workings of the OS.</p>
<h3><a class="header" href="#loading-an-application" id="loading-an-application">Loading an application</a></h3>
<p>Okay, let's build and load this simple program.</p>
<ol>
<li>
<p>Erase all other applications from the development board:</p>
<pre><code> $ tockloader erase-apps
</code></pre>
</li>
<li>
<p>Build the application and load it (Note: <code>tockloader install</code> automatically searches the
current working directory and its subdirectories for Tock binaries.)</p>
<pre><code> $ tockloader install --make
</code></pre>
</li>
<li>
<p>Check that it worked:</p>
<pre><code> $ tockloader listen
</code></pre>
</li>
</ol>
<p>The output should look something like:</p>
<pre><code>$ tockloader listen
No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/cu.usbserial-c098e5130012 - Hail IoT Module - TockOS&quot;

Listening for serial output.
Hello, World!
</code></pre>
<h2><a class="header" href="#creating-your-own-application" id="creating-your-own-application">Creating your own application</a></h2>
<p>Now that you've got a basic app working, modify it so that it continuously
prints out <code>Hello World</code> twice per second.  You'll want to use the user
library's timer facilities to manage this:</p>
<h3><a class="header" href="#timer" id="timer">Timer</a></h3>
<p>You'll find the interface for timers in <code>libtock/timer.h</code>. The
function you'll find useful today is:</p>
<pre><code class="language-c">#include &lt;timer.h&gt;
void delay_ms(uint32_t ms);
</code></pre>
<p>This function sleeps until the specified number of milliseconds have passed, and
then returns.  So we call this function &quot;synchronous&quot;: no further code will run
until the delay is complete.</p>
<h2><a class="header" href="#write-an-app-that-periodically-samples-the-on-board-sensors" id="write-an-app-that-periodically-samples-the-on-board-sensors">Write an app that periodically samples the on-board sensors</a></h2>
<p>Now that we have the ability to write applications, let's do something a little
more complex. The development board you are using has several sensors on it.
These sensors include a light sensor, a humidity sensor, and a temperature
sensor. Each sensing medium can be accessed separately via the Tock user
library. We'll just be using the light and temperature for this excercise.</p>
<h4><a class="header" href="#light" id="light">Light</a></h4>
<p>The interface in <code>libtock/ambient_light.h</code> is used to measure ambient
light conditions in <a href="https://en.wikipedia.org/wiki/Lux">lux</a>. imix uses the
<a href="https://www.intersil.com/en/products/optoelectronics/ambient-light-sensors/light-to-digital-sensors/ISL29035.html">ISL29035</a>
sensor, but the userland library is abstracted from the details of particular
sensors.  It contains the function:</p>
<pre><code class="language-c">#include &lt;ambient_light.h&gt;
int ambient_light_read_intensity_sync(int* lux);
</code></pre>
<p>Note that the light reading is written to the location passed as an
argument, and the function returns non-zero in the case of an error.</p>
<h4><a class="header" href="#temperature" id="temperature">Temperature</a></h4>
<p>The interface in <code>libtock/temperature.h</code> is used to measure ambient
temperature in degrees Celsius, times 100. imix uses the
<a href="https://www.silabs.com/products/sensors/humidity-sensors/Pages/si7013-20-21.aspx">SI7021</a>
sensor. It contains the function:</p>
<pre><code class="language-c">#include &lt;temperature.h&gt;
int temperature_read_sync(int* temperature);
</code></pre>
<p>Again, this function returns non-zero in the case of an error.</p>
<h3><a class="header" href="#read-sensors-in-a-tock-application" id="read-sensors-in-a-tock-application">Read sensors in a Tock application</a></h3>
<p>Using the example program you're working on, write an application that reads
all of the sensors on your development board and reports their readings over
the serial port.</p>
<p>As a bonus, experiment with toggling an LED when readings are above or below a
certain threshold:</p>
<h4><a class="header" href="#led" id="led">LED</a></h4>
<p>The interface in <code>libtock/led.h</code> is used to control lights on Tock boards. On the Hail
board, there are three LEDs which can be controlled: Red, Blue, and Green. The
functions in the LED module are:</p>
<pre><code class="language-c">#include &lt;led.h&gt;
int led_count(void);
</code></pre>
<p>Which returns the number of LEDs available on the board.</p>
<pre><code class="language-c">int led_on(int led_num);
</code></pre>
<p>Which turns an LED on, accessed by its number.</p>
<pre><code class="language-c">int led_off(int led_num);
</code></pre>
<p>Which turns an LED off, accessed by its number.</p>
<pre><code class="language-c">int led_toggle(int led_num);
</code></pre>
<p>Which toggles the state of an LED, accessed by its number.</p>
<h1><a class="header" href="#capsule-1" id="capsule-1">Capsule</a></h1>
<p>The goal of this part of the course is to make you comfortable with the
Tock kernel and writing code for it. By the end of this part, you'll have
written a new capsule that reads a humidity sensor and outputs its readings
over the serial port.</p>
<p>During this you will:</p>
<ol>
<li>Learn how Tock uses Rust's memory safety to provide isolation for free</li>
<li>Read the Tock boot sequence, seeing how Tock uses static allocation</li>
<li>Learn about Tock's event-driven programming</li>
<li>Write a new capsule that reads a humidity sensor and prints it over serial</li>
</ol>
<h2><a class="header" href="#read-the-tock-boot-sequence-20m-1" id="read-the-tock-boot-sequence-20m-1">Read the Tock boot sequence (20m)</a></h2>
<p>Open <code>imix/src/main.rs</code> in your favorite editor. This file defines the
imix platform: how it boots, what capsules it uses, and what system calls it
supports for userland applications.</p>
<h3><a class="header" href="#how-is-everything-organized-1" id="how-is-everything-organized-1">How is everything organized?</a></h3>
<p>Find the declaration of <code>struct Imix</code> (it's pretty early in the file).
This declares the structure representing the platform. It has many fields,
all of which are capsules. These are the capsules that make up the imix
platform. For the most part, these map directly to hardware peripherals,
but there are exceptions such as <code>IPC</code> (inter-process communication).</p>
<p>Recall the discussion about how everything in the kernel is statically
allocated? We can see that here. Every field in <code>struct Imix</code> is a reference to
an object with a static lifetime.</p>
<p>The capsules themselves take a lifetime as a parameter, which is currently
always <code> `static</code>.  The implementations of these capsules, however, do not
rely on this assumption.</p>
<p>The boot process is primarily the construction of this <code>Imix</code> structure. Once
everything is set up, the board will pass the constructed <code>imix</code> to
<code>kernel::kernel_loop</code> and we're off to the races.</p>
<h3><a class="header" href="#how-do-things-get-started-1" id="how-do-things-get-started-1">How do things get started?</a></h3>
<p>The method <code>reset_handler</code> is invoked when the chip resets (i.e., boots).
It's pretty long because imix has a lot of drivers that need to be created
and initialized, and many of them depend on other, lower layer abstractions
that need to be created and initialized as well.</p>
<p>Take a look at the first few lines of the <code>reset_handler</code>. The boot sequence
initializes memory (copies initialized variables into RAM, clears the BSS),
sets up the system clocks, and configures the GPIO pins.</p>
<h3><a class="header" href="#how-do-capsules-get-created-1" id="how-do-capsules-get-created-1">How do capsules get created?</a></h3>
<p>The next lines of <code>reset_handler</code> create and initialize the system console,
which is what turns calls to <code>println</code> into bytes sent to the USB serial port:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let uart_mux = static_init!(
    MuxUart&lt;'static&gt;,
    MuxUart::new(
        &amp;sam4l::usart::USART3,
        &amp;mut capsules::virtual_uart::RX_BUF,
        115200
    )
);
uart_mux.initialize();

hil::uart::Transmit::set_transmit_client(&amp;sam4l::usart::USART3, uart_mux);
hil::uart::Receive::set_receive_client(&amp;sam4l::usart::USART3, uart_mux);

let console = ConsoleComponent::new(board_kernel, uart_mux).finalize();
#}</code></pre></pre>
<p>Eventually, once all of the capsules have been created, we will populate
a imix structure with them:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let imix = Imix {
    console: console,
    gpio: gpio,
    ...
#}</code></pre></pre>
<p>The <code>static_init!</code> macro is simply an easy way to allocate a static
variable with a call to <code>new</code>. The first parameter is the type, the second
is the expression to produce an instance of the type. This call creates
a <code>Console</code> that uses serial port 3 (<code>USART3</code>) at 115200 bits per second.</p>
<blockquote>
<h4><a class="header" href="#a-brief-aside-on-buffers-1" id="a-brief-aside-on-buffers-1">A brief aside on buffers:</a></h4>
<p>Notice that you have to pass a write buffer to the console for it to use:
this buffer has to have a <code> `static</code> lifetime. This is because low-level
hardware drivers, especially those that use DMA, require <code> `static</code> buffers.
Since Tock doesn't promise when a DMA operation will complete, and you
need to be able to promise that the buffer outlives the operation, the
one lifetime that is assured to be alive at the end of an operation is
<code> `static</code>. So that other code which has buffers
without a <code> `static</code> lifetime, such as userspace processes, can use the
<code>Console</code>, it copies them into its own internal <code> `static</code> buffer before
passing it to the serial port. So the buffer passing architecture looks like
this:</p>
<p><img src="console.png" alt="Console/UART buffer lifetimes" /></p>
<p>It's a little weird that Console's <code>new</code> method takes in a reference to
itself. This is an ergonomics tradeoff. The Console needs a mutable static
buffer to use internally, which the Console capsule declares. However writing
global statics is unsafe. To avoid the unsafe operation in the Console
capsule itself, we make it the responsibility of the instantiator to give the
Console a buffer to use, without burdening the instantiator with sizing the
buffer.</p>
</blockquote>
<h3><a class="header" href="#lets-make-an-imix-1" id="lets-make-an-imix-1">Let's make an imix!</a></h3>
<p>The code continues on, creating all of the other capsules that are needed
by the imix platform. By the time we get down to around line 360, we've
created all of the capsules we need, and it's time to create the actual
imix platform structure (<code>let imix = Imix {</code> ...).</p>
<h3><a class="header" href="#capsule-initialization-1" id="capsule-initialization-1">Capsule <em>initialization</em></a></h3>
<p>Up to this point we have been creating numerous structures and setting some
static configuration options and mappings, but nothing dynamic has occurred
(said another way, all methods invoked by <code>static_init!</code> must be <code>const fn</code>,
however Tock's <code>static_init!</code> macro predates stabilization of <code>const fn</code>'s.
A future iteration could possibly leverage these and obviate the need for the
macro).</p>
<p>Some capsules require <em>initialization</em>, some code that must be executed
before they can be used. For example, a few lines after creating the imix
struct, we initialize the console:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
imix.nrf51822.initialize();
#}</code></pre></pre>
<p>This method is responsible for actually writing the hardware registers that
configure the associated UART peripheral for use as a text console
(8 data bits, 1 stop bit, no parity bit, no hardware flow control).</p>
<h3><a class="header" href="#inter-capsule-dependencies-1" id="inter-capsule-dependencies-1">Inter-capsule dependencies</a></h3>
<p>Just after initializing the console capsule, we find this line:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::debug::assign_console_driver(Some(imix.console), kc);
#}</code></pre></pre>
<p>This configures the kernel's <code>debug!</code> macro to print messages to this console
we've just created. The <code>debug!</code> mechanism can be very helpful during
development and testing. Today we're going to use it to print output from the
capsule you create.</p>
<p>Let's try it out really quick:</p>
<pre><code class="language-diff">--- a/boards/imix/src/main.rs
+++ b/boards/imix/src/main.rs
@@ -10,7 +10,7 @@
 extern crate capsules;
 extern crate cortexm4;
 extern crate compiler_builtins;
-#[macro_use(static_init)]
+#[macro_use(debug, static_init)]
 extern crate kernel;
 extern crate sam4l;

@@ -388,6 +388,8 @@ pub unsafe fn reset_handler() {
         capsules::console::App::default());
     kernel::debug::assign_console_driver(Some(imix.console), kc);

+    debug!(&quot;Testing 1, 2, 3...&quot;);
+
     imix.nrf51822.initialize();
</code></pre>
<p>Compile and flash the kernel (<code>make program</code>) then look at the output
(<code>tockloader listen</code>).</p>
<ul>
<li>What happens if you put the <code>debug!</code> before <code>assign_console_driver</code>?</li>
<li>What happens if you put <code>imix.console.initialize()</code> after
<code>assign_console_driver</code>?</li>
</ul>
<p>As you can see, sometimes there are dependencies between capsules, and board
authors must take care during initialization to ensure correctness.</p>
<blockquote>
<p><strong>Note:</strong> The <code>debug!</code> implementation is <em>asynchronous</em>. It copies messages
into a buffer and the console prints them via DMA as the UART peripheral is
available, interleaved with other console users (i.e. processes). You
shouldn't need to worry about the mechanics of this for now.</p>
</blockquote>
<h3><a class="header" href="#loading-processes-1" id="loading-processes-1">Loading processes</a></h3>
<p>Once the platform is all set up, the board is responsible for loading processes
into memory:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::process::load_processes(&amp;_sapps as *const u8,
                                &amp;mut APP_MEMORY,
                                &amp;mut PROCESSES,
                                FAULT_RESPONSE);
#}</code></pre></pre>
<p>A Tock process is represented by a <code>kernel::Process</code> struct. In principle, a
platform could load processes by any means. In practice, all existing platforms
write an array of Tock Binary Format (TBF) entries to flash. The kernel provides
the <code>load_processes</code> helper function that takes in a flash address and begins
iteratively parsing TBF entries and making <code>Process</code>es.</p>
<h3><a class="header" href="#starting-the-kernel-1" id="starting-the-kernel-1">Starting the kernel</a></h3>
<p>Finally, the board passes a reference to the current platform, the chip the
platform is built on (used for interrupt and power handling), the processes to
run, and an IPC server instance to the main loop of the kernel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::main(&amp;imix, &amp;mut chip, &amp;mut PROCESSES, &amp;imix.ipc);
#}</code></pre></pre>
<p>From here, Tock is initialized, the kernel event loop takes over, and the
system enters steady state operation.</p>
<h3><a class="header" href="#create-a-hello-world-capsule-1" id="create-a-hello-world-capsule-1">Create a &quot;Hello World&quot; capsule</a></h3>
<p>Now that you've seen how Tock initializes and uses capsules, you're going to
write a new one. At the end of this section, your capsule will sample the
humidity sensor once a second and print the results as serial output. But
you'll start with something simpler: printing &quot;Hello World&quot; to the debug
console once on boot.</p>
<p>The <code>imix</code> board configuration you've looked through has a capsule for the this
tutorial already set up. The capsule is a separate Rust crate located in
<code>excercises/capsule</code>. You'll complete this excercise by filling it in.</p>
<p>In addition to a constructor, Our capsule has <code>start</code> function defined that is
currently empty. The board configuration calls this function once it has
initialized the capsule.</p>
<p>Eventually, the <code>start</code> method will kick off a state machine for periodic
humidity readings, but for now, let's just print something to the debug console
and return:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
debug!(&quot;Hello from the kernel!&quot;);
#}</code></pre></pre>
<pre><code class="language-bash">$ cd [PATH_TO_BOOK]/imix
$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Hello from the kernel!
</code></pre>
<h2><a class="header" href="#extend-your-capsule-to-print-hello-world-every-second-1" id="extend-your-capsule-to-print-hello-world-every-second-1">Extend your capsule to print &quot;Hello World&quot; every second</a></h2>
<p>In order for your capsule to keep track of time, it will need to depend on
another capsule that implements the Alarm interface. We'll have to do something
similar for reading the accelerometer, so this is good practice.</p>
<p>The Alarm HIL includes several traits, <code>Alarm</code>, <code>Client</code>, and <code>Frequency</code>, all
in the <code>kernel::hil::time</code> module. You'll use the <code>set_alarm</code> and <code>now</code> methods
from the <code>Alarm</code> trait to set an alarm for a particular value of the clock.
Note that both methods accept arguments in the alarm's native clock frequency,
which is available using the Alarm trait's associated <code>Frequency</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// native clock frequency in Herz
let frequency = &lt;A::Frequency&gt;::frequency();
#}</code></pre></pre>
<p>Your capsule already implements the <code>alarm::Client</code> trait so it can receive
alarm events. The <code>alarm::Client</code> trait has a single method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fired(&amp;self)
#}</code></pre></pre>
<p>Your capsule should now set an alarm in the <code>start</code> method, print the debug
message and set an alarm again when the alarm fires.</p>
<p>Compile and program your new kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
</code></pre>
<p><a href="https://gist.github.com/alevy/73fca7b0dddcb5449088cebcbfc035f1">Sample Solution</a></p>
<h2><a class="header" href="#extend-your-capsule-to-sample-the-humidity-once-a-second-1" id="extend-your-capsule-to-sample-the-humidity-once-a-second-1">Extend your capsule to sample the humidity once a second</a></h2>
<p>The steps for reading an accelerometer from your capsule are similar to using
the alarm. You'll use a capsule that implements the humidity HIL, which
includes the <code>HumidityDriver</code> and <code>HumidityClient</code> traits, both in
<code>kernel::hil::sensors</code>.</p>
<p>The <code>HumidityDriver</code> trait includes the method <code>read_accelerometer</code> which
initiates an accelerometer reading. The <code>HumidityClient</code> trait has a single
method for receiving readings:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn callback(&amp;self, humidity: usize);
#}</code></pre></pre>
<p>Implement logic to initiate a accelerometer reading every second and report the
results.</p>
<p><img src="rustconf.png" alt="Structure of rustconf capsule" /></p>
<p>Compile and program your kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Humidity 2731
Humidity 2732
</code></pre>
<p><a href="https://gist.github.com/alevy/798d11dbfa5409e0aa56d870b4b7afcf">Sample solution</a></p>
<h2><a class="header" href="#some-further-questions-and-directions-to-explore-1" id="some-further-questions-and-directions-to-explore-1">Some further questions and directions to explore</a></h2>
<p>Your capsule used the si7021 and virtual alarm. Take a look at the
code behind each of these services:</p>
<ol>
<li>
<p>Is the humidity sensor on-chip or a separate chip connected over a bus?</p>
</li>
<li>
<p>What happens if you request two humidity sensors back-to-back?</p>
</li>
<li>
<p>Is there a limit on how many virtual alarms can be created?</p>
</li>
<li>
<p>How many virtual alarms does the imix boot sequence create?</p>
</li>
</ol>
<h3><a class="header" href="#extra-credit-write-a-virtualization-capsule-for-humidity-sensor--1" id="extra-credit-write-a-virtualization-capsule-for-humidity-sensor--1"><strong>Extra credit</strong>: Write a virtualization capsule for humidity sensor (∞)</a></h3>
<p>If you have extra time, try writing a virtualization capsule for the <code>Humidity</code>
HIL that will allow multiple clients to use it. This is a fairly open ended
task, but you might find inspiration in the <code>virtua_alarm</code> and <code>virtual_i2c</code>
capsules.</p>
<h1><a class="header" href="#tock-mini-tutorials-1" id="tock-mini-tutorials-1">Tock Mini Tutorials</a></h1>
<p>These tutorials walk through how to use some various features of Tock. They are
narrower in scope than the course, but try to explain in detail how various Tock
apps work.</p>
<p>You will need the <code>libtock-c</code> repository to run these tutorials. You should
check out a copy of <code>libtock-c</code> by running:</p>
<pre><code>$ git clone https://github.com/tock/libtock-c
</code></pre>
<p><code>libtock-c</code> contains many example Tock applications as well as the library
support code for running C and C++ apps on Tock. If you are looking to develop
Tock applications you will likely want to start with an existing app in
<code>libtock-c</code> and modify it.</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>You need to be able to compile and load the Tock kernel and Tock applications.
See the <a href="tutorials/../prerequisites.html">prerequisites guide</a> on how to get setup.</p>
<p>You also need <a href="https://tockos.org/hardware">hardware</a> that supports Tock.</p>
<p>The tutorials assume you have a Tock kernel loaded on your hardware board. To
get a kernel installed, follow these steps.</p>
<ol>
<li>
<p><strong>Obtain the Tock Source</strong>. You can clone a copy of the Tock repository to
get the kernel source:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/tock
$ cd tock
</code></pre>
</li>
<li>
<p><strong>Compile Tock</strong>. In the root of the Tock directory, compile the kernel for
your hardware platform. You can find a list of boards by running <code>make list</code>.
For example if your board is <code>imix</code> then:</p>
<pre><code class="language-bash">$ make list
$ cd boards/imix
$ make
</code></pre>
<p>If you have another board just replace &quot;imix&quot; with <code>&lt;your-board&gt;</code></p>
<p>This will create binaries of the Tock kernel. Tock is compiled with Cargo, a
package manager for Rust applications. The first time Tock is built all of
the crates must be compiled. On subsequent builds, crates that haven't
changed will not have to be rebuilt and the compilation will be faster.</p>
</li>
<li>
<p><strong>Load the Tock Kernel</strong>. The next step is to program the Tock kernel onto
your hardware. Generally, two options are supported for loading the kernel:
<code>make program</code> and <code>make flash</code>. You should likely try <code>make program</code> first.
Alternatively, the README file for the board should show which options are
available. To load the kernel, run:</p>
<pre><code class="language-bash">$ make program  # Load code via bootloader
  -- or --      # Check the README in your board folder
$ make flash    # Load code via jtag
</code></pre>
<p>in the board directory. Now you have the kernel loaded onto the hardware.
The kernel configures the hardware and provides drivers for many hardware
resources, but does not actually include any application logic. For that, we
need to load an application.</p>
<p>Note, you only need to program the kernel once. Loading applications does
not alter the kernel, and applications can be re-programed without
re-programming the kernel.</p>
</li>
</ol>
<p>With the kernel setup, you are ready to try the mini tutorials.</p>
<h2><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h2>
<ol>
<li><strong><a href="tutorials/01_running_blink.html">Blink an LED</a></strong>: Get your first Tock app running.</li>
<li><strong><a href="tutorials/02_button_print.html">Button to Printf()</a></strong>: Print to terminal in response
to button presses.</li>
<li><strong><a href="tutorials/03_ble_scan.html">BLE Advertisement Scanning</a></strong>: Sense nearby BLE packets.</li>
<li><strong><a href="tutorials/04_sensors_and_drivers.html">Sample Sensors and Use Drivers</a></strong>: Use syscalls
to interact with kernel drivers.</li>
<li><strong><a href="tutorials/05_ipc.html">Inter-process Communication</a></strong>: Tock's IPC mechanism.</li>
</ol>
<h3><a class="header" href="#board-compatiblity-matrix" id="board-compatiblity-matrix">Board compatiblity matrix</a></h3>
<table><thead><tr><th>Tutorial #</th><th>Supported boards</th></tr></thead><tbody>
<tr><td>1</td><td>All</td></tr>
<tr><td>2</td><td>All Cortex-M based boards</td></tr>
<tr><td>3</td><td>Hail and imix</td></tr>
<tr><td>4</td><td>Hail and imix</td></tr>
<tr><td>5</td><td>All that support IPC</td></tr>
</tbody></table>
<h1><a class="header" href="#blink-running-your-first-app" id="blink-running-your-first-app">Blink: Running Your First App</a></h1>
<p>This guide will help you get the <code>blink</code> app running on top of Tock kernel.</p>
<h2><a class="header" href="#instructions" id="instructions">Instructions</a></h2>
<ol>
<li>
<p><strong>Erase any existing applications</strong>. First, we need to remove any applications already
on the board. Note that Tockloader by default will install any application in
addition to whatever is already installed on the board.</p>
<pre><code class="language-bash">$ tockloader erase-apps
</code></pre>
</li>
<li>
<p><strong>Install Blink</strong>. Tock supports an &quot;app store&quot; of sorts. That is, tockloader
can install apps from a remote repository, including Blink. To do this:</p>
<pre><code class="language-bash">$ tockloader install blink
</code></pre>
<p>You will have to tell Tockloader that you are OK with fetching the app from
the Internet.</p>
<p>Your specific board may require additional arguments, please see the readme
in the <code>boards/</code> folder for more details.</p>
</li>
<li>
<p><strong>Compile and Install Blink</strong>. We can also compile the blink app and load our
compiled version. The basic C version of blink is located in the
<a href="https://github.com/tock/libtock-c">libtock-c</a> repository. Clone that
repository, then navigate to <code>examples/blink</code>. From there, you should be able
to compile it and install it by:</p>
<pre><code class="language-bash">$ make
$ tockloader install
</code></pre>
<p>When the blink app is installed you should see the LEDs on the board
blinking. Congratulations! You have just programmed your first Tock
application.</p>
</li>
</ol>
<h1><a class="header" href="#say-hello-on-every-button-press" id="say-hello-on-every-button-press">Say &quot;Hello!&quot; On Every Button Press</a></h1>
<p>This tutorial will walk you through calling <code>printf()</code> in response to a
button press.</p>
<ol>
<li>
<p><strong>Start a new application</strong>. A Tock application in C looks like a typical C
application. Lets start with the basics:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
  return 0;
}
</code></pre>
<p>You also need a makefile. Copying a makefile from an existing app is
the easiest way to get started.</p>
</li>
<li>
<p><strong>Setup a button callback handler</strong>. A button press in Tock is treated as an
interrupt, and in an application this translates to a function being called,
much like in any other event-driven system. To listen for button presses, we
first need to define a callback function, then tell the kernel that the
callback exists.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
}

int main(void) {
  button_subscribe(button_callback, NULL);

  return 0;
}
</code></pre>
<p>All callbacks from the kernel are passed four arguments, and the meaning of
the four arguments depends on the driver. The first three are integers,
and can be used to represent buffer lengths, pin numbers, button numbers,
and other simple data. The fourth argument is a pointer to user defined
object. This pointer is set in the subscribe call (in this example
it is set to <code>NULL</code>), and returned when the callback fires.</p>
</li>
<li>
<p><strong>Enable the button interrupts</strong>. By default, the interrupts for the buttons
are not enabled. To enable them, we make a syscall. Buttons, like other
drivers in Tock, follow the convention that applications can ask the kernel
how many there are. This is done by calling <code>button_count()</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
}

int main(void) {
  button_subscribe(button_callback, NULL);

  // Ensure there is a button to use.
  int count = button_count();
  if (count &lt; 1) {
    // There are no buttons on this platform.
    printf(&quot;Error! No buttons on this platform.&quot;);
  } else {
    // Enable an interrupt on the first button.
    button_enable_interrupt(0);
  }

  // Can just return here. The application will continue to execute.
  return 0;
}
</code></pre>
<p>The button count is checked, and the app only continues if there
exists at least one button. To enable the button interrupt,
<code>button_enable_interrupt()</code> is called with the index of the button
to use. In this example we just use the first button.</p>
</li>
<li>
<p><strong>Call <code>printf()</code> on button press</strong>. To print a message, we call <code>printf()</code>
in the callback.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
  // Only print on the down press.
  if (val == 1) {
    printf(&quot;Hello!\n&quot;);
  }
}

int main(void) {
  button_subscribe(button_callback, NULL);

  // Ensure there is a button to use.
  int count = button_count();
  if (count &lt; 1) {
    // There are no buttons on this platform.
    printf(&quot;Error! No buttons on this platform.\n&quot;);
  } else {
    // Enable an interrupt on the first button.
    button_enable_interrupt(0);
  }

  // Can just return here. The application will continue to execute.
  return 0;
}
</code></pre>
</li>
<li>
<p><strong>Run the application</strong>. To try this tutorial application, you can find it in
the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/02_button_print">tutorials app
folder</a>.
See the first tutorial for details on how to compile and install a C
application.</p>
<p>Once installed, when you press the button, you should see &quot;Hello!&quot; printed
to the terminal!</p>
</li>
</ol>
<h1><a class="header" href="#look-a-wild-ble-packet-appeared" id="look-a-wild-ble-packet-appeared">Look! A Wild BLE Packet Appeared!</a></h1>
<blockquote>
<p>Note! This tutorial will only work on Hail and imix boards.</p>
</blockquote>
<p>This tutorial will walk you through getting an app running that scans
for BLE advertisements. Most BLE devices typically broadcast advertisements
periodically (usually once a second) to allow smartphones and other devices
to discover them. The advertisements typically contain the BLE device's ID
and name, as well as as which services the device provides, and sometimes
raw data as well.</p>
<p>To provide BLE connectivity, several Tock boards use the Nordic nRF51822
as a BLE co-processor. In this configuration, the nRF51822 runs all of
the BLE operations and exposes a command interface over a UART bus. Luckily for
us, Nordic has defined and implemented the entire interface. Better yet, they
made it interoperable with their nRF51 SDK. What this means is any BLE app
that would run on the nRF51822 directly can be compiled to run on a different
microcontroller, and any function calls that would have interacted with
the BLE hardware are instead packaged and sent to the nRF51822 co-processor.
Nordic calls this tool &quot;BLE Serialization&quot;, and Tock has a port of the
serialization libraries that Tock applications can use.</p>
<p>So, with that introduction, lets get going.</p>
<ol>
<li>
<p><strong>Initialize the BLE co-processor</strong>. The first step a BLE serialization app
must do is initialize the BLE stack on the co-processor. This can be done
with Nordic's SDK, but to simplify things Tock supports the <a href="https://github.com/lab11/nrf5x-base/tree/master/lib">Simple
BLE</a> library. The goal
of <code>simple_ble.c</code> is to wrap the details of the nRF5 SDK and the intricacies
of BLE in an easy-to-use library so you can get going with creating BLE
devices and not learning the entire spec.</p>
<pre><code class="language-c">#include &lt;simple_ble.h&gt;

// Intervals for advertising and connections.
// These are some basic settings for BLE devices. However, since we are
// only interesting in scanning, these are not particularly relevant.
simple_ble_config_t ble_config = {
  .platform_id       = 0x00, // used as 4th octet in device BLE address
  .device_id         = DEVICE_ID_DEFAULT,
  .adv_name          = &quot;Tock&quot;,
  .adv_interval      = MSEC_TO_UNITS(500, UNIT_0_625_MS),
  .min_conn_interval = MSEC_TO_UNITS(1000, UNIT_1_25_MS),
  .max_conn_interval = MSEC_TO_UNITS(1250, UNIT_1_25_MS)
};

int main () {
    printf(&quot;[Tutorial] BLE Scanning\n&quot;);

    // Setup BLE.
    simple_ble_init(&amp;ble_config);
}
</code></pre>
</li>
<li>
<p><strong>Scan for advertisements</strong>. With <code>simple_ble</code> this is pretty
straightforward.</p>
<pre><code class="language-c">int main () {
    printf(&quot;[Tutorial] BLE Scanning\n&quot;);

    // Setup BLE.
    simple_ble_init(&amp;ble_config);

    // Scan for advertisements.
    simple_ble_scan_start();
}
</code></pre>
</li>
<li>
<p><strong>Handle the advertisement received event</strong>. Just as the main Tock
microcontroller can send commands to the nRF co-processor, the co-processor
can send events back. When these occur, a variety of callbacks are generated
in <code>simple_ble</code> and then passed to users of the library. In this case, we
only care about <code>ble_evt_adv_report()</code> which is called on each advertisement
reception.</p>
<pre><code class="language-c">// Called when each advertisement is received.
void ble_evt_adv_report (ble_evt_t* p_ble_evt) {
  ble_gap_evt_adv_report_t* adv = (ble_gap_evt_adv_report_t*) &amp;p_ble_evt-&gt;evt.gap_evt.params.adv_report;
}
</code></pre>
<p>The <code>ble_evt_adv_report()</code> function is passed a pointer to a <code>ble_evt_t</code>
struct. This is a type from the Nordic nRF51 SDK, and more information
can be found in the SDK documentation.</p>
</li>
<li>
<p><strong>Display a message for each advertisement</strong>. Once we have the advertisement
callback, we can use <code>printf()</code> like normal.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;led.h&gt;

// Called when each advertisement is received.
void ble_evt_adv_report (ble_evt_t* p_ble_evt) {
  ble_gap_evt_adv_report_t* adv = (ble_gap_evt_adv_report_t*) &amp;p_ble_evt-&gt;evt.gap_evt.params.adv_report;

  // Print some details about the discovered advertisement.
  printf(&quot;Recv Advertisement: [%02x:%02x:%02x:%02x:%02x:%02x] RSSI: %d, Len: %d\n&quot;,
    adv-&gt;peer_addr.addr[5], adv-&gt;peer_addr.addr[4], adv-&gt;peer_addr.addr[3],
    adv-&gt;peer_addr.addr[2], adv-&gt;peer_addr.addr[1], adv-&gt;peer_addr.addr[0],
    adv-&gt;rssi, adv-&gt;dlen);

  // Also toggle the first LED.
  led_toggle(0);
}
</code></pre>
</li>
<li>
<p><strong>Handle some BLE annoyances</strong>. The last step to getting a working app is to
handle some annoyances using BLE serialization with the <code>simple_ble</code> library.
Typically errors generated by the nRF51 SDK are severe and mean there is a
significant bug in the code. With serialization, however, messages between
the two processors can be corrupted or misframed, causing parsing errors. We
can ignore these errors safely and just drop the corrupted packet.</p>
<p>Additionally, the <code>simple_ble</code> library makes it easy to set the address
of a BLE device. However, this functionality only works when running
on an actual nRF51822. To disable this, we override the weakly defined
<code>ble_address_set()</code> function with an empty function.</p>
<pre><code class="language-c">void app_error_fault_handler(uint32_t error_code, uint32_t line_num, uint32_t info) { }
void ble_address_set () { }
</code></pre>
</li>
<li>
<p><strong>Run the app and see the packets!</strong> To try this tutorial application, you
can find it in the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/03_ble_scan">tutorials app
folder</a>.</p>
<p>For any new applications, ensure that the following is in the makefile
so that the BLE serialization library is included.</p>
<pre><code> include $(TOCK_USERLAND_BASE_DIR)/libnrfserialization/Makefile.app
</code></pre>
</li>
</ol>
<h2><a class="header" href="#details" id="details">Details</a></h2>
<p>This section contains a few notes about the specific versions of BLE
serialization used.</p>
<p>Tock currently supports the S130 softdevice version 2.0.0 and SDK 11.0.0.</p>
<h1><a class="header" href="#reading-sensors-from-scratch" id="reading-sensors-from-scratch">Reading Sensors From Scratch</a></h1>
<blockquote>
<p>Note! This tutorial will only work on Hail and imix boards.</p>
</blockquote>
<p>In this tutorial we will cover how to use the syscall interface from
applications to kernel drivers, and guide things based on reading the
<a href="http://www.intersil.com/en/products/optoelectronics/ambient-light-sensors/light-to-digital-sensors/ISL29035.html">ISL29035</a>
digital light sensor and printing the readings over UART.</p>
<p>OK, lets get started.</p>
<ol>
<li>
<p><strong>Setup a generic app for handling asynchronous events</strong>. As with most
sensors, the ISL29035 is read asynchronously, and a callback is generated
from the kernel to userspace when the reading is ready. Therefore, to use
this sensor, our application needs to do two things: 1) setup a callback the
kernel driver can call when the reading is ready, and 2) instruct the kernel
driver to start the measurement. Lets first sketch this out:</p>
<pre><code class="language-c">#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {

}

int main() {
    // Tell the kernel about the callback.

    // Instruct the ISL29035 driver to begin a reading.

    // Wait until the reading is complete.

    // Print the resulting value.

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Fill in the application with syscalls</strong>. The standard <a href="tutorials/../Syscalls.html">Tock
syscalls</a> can be used to actually implement the sketch we
made above. We first use the <code>subscribe</code> syscall to inform the kernel about
the callback in our application. We then use the <code>command</code> syscall to start
the measurement. To wait, we use the <code>yield</code> call to wait for the callback to
actually fire. We do not need to use <code>allow</code> for this application, and
typically it is not required for reading sensors.</p>
<p>For all syscalls that interact with drivers, the major number is set by
the platform. In the case of the ISL29035, it is <code>0x60002</code>. The minor numbers
are set by the driver and are specific to the particular driver.</p>
<p>To save the value from the callback to use in the print statement, we will
store it in a global variable.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

static int isl29035_reading;

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {
    // Save the reading when the callback fires.
    isl29035_reading = intensity;
}

int main() {
    // Tell the kernel about the callback.
    subscribe(DRIVER_NUM, 0, isl29035_callback, NULL);

    // Instruct the ISL29035 driver to begin a reading.
    command(DRIVER_NUM, 1, 0);

    // Wait until the reading is complete.
    yield();

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Be smarter about waiting for the callback</strong>. While the above application
works, it's really relying on the fact that we are only sampling a single
sensor. In the current setup, if instead we had two sensors with outstanding
commands, the first callback that fired would trigger the <code>yield()</code> call to
return and then the <code>printf()</code> would execute. If, for example, sampling the
ISL29035 takes 100 ms, and the new sensor only needs 10 ms, the new sensor's
callback would fire first and the <code>printf()</code> would execute with an incorrect
value.</p>
<p>To handle this, we can instead use the <code>yield_for()</code> call, which takes
a flag and only returns when that flag has been set. We can then set this
flag in the callback to make sure that our <code>printf()</code> only occurs when
the light reading has completed.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

static int isl29035_reading;
static bool isl29035_done = false;

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {
    // Save the reading when the callback fires.
    isl29035_reading = intensity;

    // Mark our flag true so that the `yield_for()` returns.
    isl29035_done = true;
}

int main() {
    // Tell the kernel about the callback.
    subscribe(DRIVER_NUM, 0, isl29035_callback, NULL);

    // Instruct the ISL29035 driver to begin a reading.
    command(DRIVER_NUM, 1, 0);

    // Wait until the reading is complete.
    yield_for(&amp;isl29035_done);

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Use the <code>libtock</code> library functions</strong>. Normally, applications don't use the
bare <code>command</code> and <code>subscribe</code> syscalls. Typically, these are wrapped
together into helpful commands inside of <code>libtock</code> and come with a function
that hides the <code>yield_for()</code> to a make a synchronous function which is useful
for developing applications quickly. Lets port the ISL29035 sensing app to
use the Tock Standard Library:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;isl29035.h&gt;

int main() {
    // Take the ISL29035 measurement synchronously.
    int isl29035_reading = isl29035_read_light_intensity();

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Explore more sensors</strong>. This tutorial highlights only one sensor. See the
<a href="https://github.com/tock/libtock-c/tree/master/examples/sensors">sensors</a> app
for a more complete sensing application.</p>
</li>
</ol>
<h1><a class="header" href="#friendly-apps-share-data" id="friendly-apps-share-data">Friendly Apps Share Data</a></h1>
<p>This tutorial covers how to use Tock's IPC mechanism to allow applications
to communicate and share memory.</p>
<h2><a class="header" href="#tock-ipc-basics" id="tock-ipc-basics">Tock IPC Basics</a></h2>
<p>IPC in Tock uses a client-server model. Applications can provide a service by
telling the Tock kernel that they provide a service. Each application can only
provide a single service, and that service's name is set to the name of the
application. Other applications can then discover that service and explicitly
share a buffer with the server. Once a client shares a buffer, it can then
notify the server to instruct the server to somehow interact with the shared
buffer. The protocol for what the server should do with the buffer is service
specific and not specified by Tock. Servers can also notify clients, but when
and why servers notify clients is service specific.</p>
<h2><a class="header" href="#example-application" id="example-application">Example Application</a></h2>
<p>To provide an overview of IPC, we will build an example system consisting of
three apps: a random number service, a LED control service, and a main
application that uses the two services. While simple, this example both
demonstrates the core aspects of the IPC mechanism and should run on any
hardware platform.</p>
<h3><a class="header" href="#led-service" id="led-service">LED Service</a></h3>
<p>Lets start with the LED service. The goal of this service is to allow other
applications to use the shared buffer as a command message to instruct the
LED service on how to turn on or off the system's LEDs.</p>
<ol>
<li>
<p>We must tell the kernel that our app wishes to provide a service. All that we
have to do is call <code>ipc_register_svc()</code>.</p>
<pre><code class="language-c">#include &quot;ipc.h&quot;

int main(void) {
  ipc_register_svc(ipc_callback, NULL);
  return 0;
}
</code></pre>
</li>
<li>
<p>We also need that callback (<code>ipc_callback</code>) to handle IPC requests from other
applications. This callback will be called when the client app notifies the
service.</p>
<pre><code class="language-c">static void ipc_callback(int pid, int len, int buf, void* ud) {
  // pid: An identifier for the app that notified us.
  // len: How long the buffer is that the client shared with us.
  // buf: Pointer to the shared buffer.
}
</code></pre>
</li>
<li>
<p>Now lets fill in the callback for the LED application. This is a simplified
version for illustration. The full example can be found in the
<code>examples/tutorials</code> folder.</p>
<pre><code class="language-c">#include &quot;led.h&quot;

static void ipc_callback(int pid, int len, int buf, void* ud) {
  uint8_t* buffer = (uint8_t*) buf;

  // First byte is the command, second byte is the LED index to set,
  // and the third byte is whether the LED should be on or off.
  uint8_t command = buffer[0];
  if (command == 1) {
      uint8_t led_id = buffer[1];
      uint8_t led_state = buffer[2] &gt; 0;

      if (led_state == 0) {
        led_off(led_id);
      } else {
        led_on(led_id);
      }

      // Tell the client that we have finished setting the specified LED.
      ipc_notify_client(pid);
      break;
  }
}
</code></pre>
</li>
</ol>
<h3><a class="header" href="#rng-service" id="rng-service">RNG Service</a></h3>
<p>The RNG service returns the requested number of random bytes in the shared
folder.</p>
<ol>
<li>
<p>Again, register that this service exists.</p>
<pre><code class="language-c">int main(void) {
  ipc_register_svc(ipc_callback, NULL);
  return 0;
}
</code></pre>
</li>
<li>
<p>Also need a callback function for when the client signals the service. The
client specifies how many random bytes it wants by setting the first byte of
the shared buffer before calling notify.</p>
<pre><code class="language-c">#include &lt;rng.h&gt;

static void ipc_callback(int pid, int len, int buf, void* ud) {
  uint8_t* buffer = (uint8_t*) buf;
  uint8_t rng[len];

  uint8_t number_of_bytes = buffer[0];

  // Fill the buffer with random bytes.
  int number_of_bytes_received = rng_sync(rng, len, number_of_bytes);
  memcpy(buffer, rng, number_of_bytes_received);

  // Signal the client that we have the number of random bytes requested.
  ipc_notify_client(pid);
}
</code></pre>
<p>This is again not a complete example but illustrates the key aspects.</p>
</li>
</ol>
<h3><a class="header" href="#main-logic-client-application" id="main-logic-client-application">Main Logic Client Application</a></h3>
<p>The third application uses the two services to randomly control the LEDs on
the board. This application is not a server but instead is a client of the
two service applications.</p>
<ol>
<li>
<p>When using an IPC service, the first step is to discover the service and
record its identifier. This will allow the application to share memory with
it and notify it. Services are discovered by the name of the application that
provides them. Currently these are set in the application Makefile or by
default based on the folder name of the application. The examples in Tock
commonly use a Java style naming format.</p>
<pre><code class="language-c">int main(void) {
  int led_service = ipc_discover(&quot;org.tockos.tutorials.ipc.led&quot;);
  int rng_service = ipc_discover(&quot;org.tockos.tutorials.ipc.rng&quot;);

  return 0;
}
</code></pre>
<p>If the services requested are valid and exist the return value from
<code> ipc_discover</code> is the identifier of the found service. If the service
cannot be found an error is returned.</p>
</li>
<li>
<p>Next we must share a buffer with each service (the buffer is the only way to
share between processes), and setup a callback that is called when the server
notifies us as a client. Once shared, the kernel will permit both
applications to read/modify that memory.</p>
<pre><code class="language-c">char led_buf[64] __attribute__((aligned(64)));
char rng_buf[64] __attribute__((aligned(64)));

int main(void) {
  int led_service = ipc_discover(&quot;org.tockos.tutorials.ipc.led&quot;);
  int rng_service = ipc_discover(&quot;org.tockos.tutorials.ipc.rng&quot;);

  // Setup IPC for LED service
  ipc_register_client_cb(led_service, ipc_callback, NULL);
  ipc_share(led_service, led_buf, 64);

  // Setup IPC for RNG service
  ipc_register_client_cb(rng_service, ipc_callback, NULL);
  ipc_share(rng_service, rng_buf, 64);

  return 0;
}
</code></pre>
</li>
<li>
<p>We of course need the callback too. For this app we use the <code>yield_for</code>
function to implement the logical synchronously, so all the callback needs to
do is set a flag to signal the end of the <code>yield_for</code>.</p>
<pre><code class="language-c">bool done = false;

static void ipc_callback(int pid, int len, int arg2, void* ud) {
  done = true;
}
</code></pre>
</li>
<li>
<p>Now we use the two services to implement our application.</p>
<pre><code class="language-c">#include &lt;timer.h&gt;

void app() {
  while (1) {
    // Get two random bytes from the RNG service
    done = false;
    rng_buf[0] = 2; // Request two bytes.
    ipc_notify_svc(rng_service);
    yield_for(&amp;done);

    // Control the LEDs based on those two bytes.
    done = false;
    led_buf[0] = 1;                     // Control LED command.
    led_buf[1] = rng_buf[0] % NUM_LEDS; // Choose the LED index.
    led_buf[2] = rng_buf[1] &amp; 0x01;     // On or off.
    ipc_notify_svc(led_service);        // Notify to signal LED service.
    yield_for(&amp;done);

    delay_ms(500);
  }
}
</code></pre>
</li>
</ol>
<h2><a class="header" href="#try-it-out" id="try-it-out">Try It Out</a></h2>
<p>To test this out, see the complete apps in the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/05_ipc">IPC tutorial
example</a>
folder.</p>
<p>To install all of the apps on a board:</p>
<pre><code>$ cd examples/tutorials/05_ipc
$ tockloader erase-apps
$ pushd led &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
$ pushd rng &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
$ pushd logic &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
</code></pre>
<p>You should see the LEDs randomly turning on and off!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
