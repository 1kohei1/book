<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tock Tutorial</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="guides.html"><strong aria-hidden="true">1.</strong> Hands-on Guides</a></li><li><ol class="section"><li><a href="course.html"><strong aria-hidden="true">1.1.</strong> Tock Course</a></li><li><ol class="section"><li><a href="prerequisites.html"><strong aria-hidden="true">1.1.1.</strong> Prerequisites</a></li><li><a href="environment.html"><strong aria-hidden="true">1.1.2.</strong> Environment Setup</a></li><li><a href="modules.html"><strong aria-hidden="true">1.1.3.</strong> Modules</a></li><li><ol class="section"><li><a href="application.html"><strong aria-hidden="true">1.1.3.1.</strong> Application</a></li><li><a href="important_client.html"><strong aria-hidden="true">1.1.3.2.</strong> Important Client</a></li><li><a href="capsule.html"><strong aria-hidden="true">1.1.3.3.</strong> Capsule</a></li></ol></li><li><a href="graduation.html"><strong aria-hidden="true">1.1.4.</strong> Graduation</a></li></ol></li><li><a href="tutorials/tutorials.html"><strong aria-hidden="true">1.2.</strong> Mini Tutorials</a></li><li><ol class="section"><li><a href="tutorials/01_running_blink.html"><strong aria-hidden="true">1.2.1.</strong> Blink an LED</a></li><li><a href="tutorials/02_button_print.html"><strong aria-hidden="true">1.2.2.</strong> Button to Printf()</a></li><li><a href="tutorials/03_ble_scan.html"><strong aria-hidden="true">1.2.3.</strong> BLE Advertisement Scanning</a></li><li><a href="tutorials/04_sensors_and_drivers.html"><strong aria-hidden="true">1.2.4.</strong> Sample Sensors and Use Drivers</a></li><li><a href="tutorials/05_ipc.html"><strong aria-hidden="true">1.2.5.</strong> Inter-process Communication</a></li></ol></li></ol></li><li><a href="development/guides.html"><strong aria-hidden="true">2.</strong> Kernel Development Guides</a></li><li><ol class="section"><li><a href="development/peripheral.html"><strong aria-hidden="true">2.1.</strong> Chip Peripheral Driver</a></li><li><a href="development/sensor.html"><strong aria-hidden="true">2.2.</strong> Sensor Driver</a></li><li><a href="development/syscall.html"><strong aria-hidden="true">2.3.</strong> Syscall Interface</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Tock Tutorial</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#tock-os-book" id="tock-os-book">Tock OS Book</a></h1>
<img src="../imgs/tock.svg" style="float:right;" />
This book introduces you to Tock, a secure embedded operating system for sensor
networks and the Internet of Things. Tock is the first operating system to allow
multiple untrusted applications to run concurrently on a microcontroller-based
computer. The Tock kernel is written in Rust, a memory-safe systems language
that does not rely on a garbage collector. Userspace applications are run in
single-threaded processes that can be written in any language.
<h1><a class="header" href="#hands-on-guides" id="hands-on-guides">Hands-on Guides</a></h1>
<p>This portion of the book includes workshops and tutorials to teach how to use
and develop with Tock, and is divided into two sections: the course and a series
of mini tutorials. The course is a good place to start, and provides a
structured introduction to Tock that should take a few hours to complete (it was
designed for a half day workshop). The tutorials are smaller examples that
highlight specific features.</p>
<h2><a class="header" href="#tock-course" id="tock-course">Tock Course</a></h2>
<p>In this hands-on guide, we will look at some of the high-level services provided
by Tock.  We will start with an understanding of the OS and its programming
environment.  Then we'll look at how a process management application can help
afford remote debugging, diagnosing and fixing a resource-intensive app over the
network.  The last part of the tutorial is a bit more free-form, inviting
attendees to further explore the networking and application features of Tock or
to dig into the kernel a bit and explore how to enhance and extend the kernel.</p>
<p>This course assumes some experience programming embedded devices and fluency in
C. It assumes no knowledge of Rust, although knowing Rust will allow you to be
more creative during the kernel exploration at the end.</p>
<h3><a class="header" href="#course-outline" id="course-outline">Course Outline</a></h3>
<p>You should first make sure you have the <a href="prerequisites.html">requisite</a>
hardware and software to complete the guide.</p>
<p>The guide is divided into sections, each with an brief introduction to
introduce concepts, followed by hands-on exercises.</p>
<ol>
<li>
<p><a href="environment.html">Environment Setup</a>: Get familiar with the Tock tools and
getting a board setup.</p>
</li>
<li>
<p><a href="application.html">Userland programming</a>: write a basic sensing application
in C.</p>
</li>
<li>
<p><a href="important_client.html">Import Client</a>: debug a problem for an important
client.</p>
</li>
<li>
<p><a href="capsule.html">Kernel programming</a>: understand the kernel's boot sequence and
write a simple driver in Rust.</p>
</li>
</ol>
<h2><a class="header" href="#tock-mini-tutorials" id="tock-mini-tutorials">Tock Mini Tutorials</a></h2>
<p>These <a href="./tutorials/tutorials.html">tutorials</a> feature specific examples of Tock
applications. They can be completed after the course to learn about different
capabilities of Tock apps.</p>
<h1><a class="header" href="#tock-course-1" id="tock-course-1">Tock Course</a></h1>
<p>The Tock course includes several different modules that guide you through
various aspects of Tock and Tock applications. Each module is designed to be
standalone such that a full course can be composed of different modules
depending on the interests and backgrounds of those doing the course.</p>
<h1><a class="header" href="#prerequisites" id="prerequisites">Prerequisites</a></h1>
<p>We will go over setting up a development environment during the course and help
out with possible problems you run into. You must ensure you have the proper
hardware before you begin---an development board and a workstation---and
software development environment.</p>
<h2><a class="header" href="#hardware" id="hardware">Hardware</a></h2>
<p>To complete the hands-on exercises in this guide, you'll need an <em>imix</em>
hardware platform (pictured below), a workstation running either Linux or OS X
(you can also work in a <a href="prerequisites.html#virtual-machine">Virtual Machine</a>), and a micro-USB
cable to connect your imix to your workstation.</p>
<p>To complete the 6LoWPAN networking portion of this guide, you'll need an
additional <em>imix</em> to act as a hub, but multiple participants can use the same
hub <em>imix</em>.</p>
<p><img src="../imgs/imix.svg" alt="" /></p>
<h2><a class="header" href="#software" id="software">Software</a></h2>
<p>You can either download a <a href="prerequisites.html#virtual-machine">virtual machine</a> with all
development environment pre-installed (<strong>RECOMMENDED</strong>), or, if you have a Linux or OS X
workstation, you may install the development environment
<a href="prerequisites.html#native-installation">natively</a>. Using a virtual machine is quicker and easier
to set up, while installing natively will yield the most comfortable
development environment and is better for long term use.</p>
<h3><a class="header" href="#virtual-machine" id="virtual-machine">Virtual Machine</a></h3>
<p>If you're comfortable working inside a Debian virtual machine, you can download
an image with all of the dependencies already installed
<a href="https://cesar.cs.princeton.edu/Tock.ova">here</a> or
<a href="https://www.cs.virginia.edu/%7Ebjc8c/archive/Tock.ova">here</a>. Using <code>curl</code> to
download the image is recommended, but your browser should be able to download
it as well:</p>
<pre><code>$ curl -O &lt;url&gt;
</code></pre>
<p>With the virtual machine image downloaded, you can run it with VirtualBox or
VMWare:</p>
<ul>
<li>VirtualBox users: <a href="https://docs.oracle.com/cd/E26217_01/E26796/html/qs-import-vm.html">File → Import Appliance...</a>,</li>
<li>VMWare users: <a href="https://pubs.vmware.com/workstation-9/index.jsp?topic=%2Fcom.vmware.ws.using.doc%2FGUID-DDCBE9C0-0EC9-4D09-8042-18436DA62F7A.html">File → Open...</a></li>
</ul>
<p>The VM account is &quot;tock&quot; with password &quot;tock&quot;. Feel free to customize it with
whichever editors, window managers, etc. you like before the training starts.</p>
<blockquote>
<p>If the Host OS is Linux, you may need to add your user to the <code>vboxusers</code>
group on your machine in order to connect the hardware boards to the virtual
machine.</p>
</blockquote>
<h3><a class="header" href="#native-installation" id="native-installation">Native Installation</a></h3>
<p>If you choose to install the development environment natively on an existing
operating system install, you will need the following software:</p>
<ol>
<li>
<p>Command line utilities: <code>curl</code>, <code>make</code>, and <code>git</code>.</p>
</li>
<li>
<p>Python 3 and <code>pip3</code></p>
</li>
<li>
<p>A local clone of this book source, containing the exercises</p>
<pre><code> $ git clone https://github.com/tock/book.git tock-book
</code></pre>
</li>
<li>
<p><a href="http://rustup.rs/">rustup</a>. This tool helps manage installations of the
Rust compiler and related tools.</p>
<pre><code> $ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>and the Rust core libraries for the Cortex-M4:</p>
<pre><code> $ rustup target add thumbv7em-none-eabi
</code></pre>
</li>
<li>
<p><a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">arm-none-eabi toolchain</a> (version &gt;= 5.2)</p>
<pre><code> # mac
 $ brew tap ARMmbed/homebrew-formulae &amp;&amp; brew update &amp;&amp; brew install arm-none-eabi-gcc

 # linux
 $ sudo add-apt-repository ppa:team-gcc-arm-embedded/ppa &amp;&amp; sudo apt update &amp;&amp; sudo apt install gcc-arm-embedded
</code></pre>
<p>OS-specific installation instructions can be found
<a href="https://github.com/tock/tock/blob/master/doc/Getting_Started.md#arm-none-eabi-toolchain">here</a></p>
</li>
<li>
<p><a href="https://crates.io/crates/elf2tab/">elf2tab</a></p>
<pre><code> $ cargo install elf2tab
</code></pre>
</li>
<li>
<p><a href="https://github.com/tock/tockloader">tockloader</a></p>
<pre><code> $ pip3 install -U --user tockloader
</code></pre>
<blockquote>
<p>Note: On MacOS, you may need to add <code>tockloader</code> to your path. If you
cannot run it after installation, run the following:</p>
</blockquote>
<pre><code> $ export PATH=$HOME/Library/Python/3.6/bin/:$PATH
</code></pre>
<blockquote>
<p>Similarly, on Linux distributions, this will typically install to
<code>$HOME/.local/bin</code>, and you may need to add that to your <code>$PATH</code> if not
already present:</p>
</blockquote>
<pre><code> $ PATH=$HOME/.local/bin:$PATH
</code></pre>
</li>
</ol>
<h3><a class="header" href="#testing" id="testing">Testing</a></h3>
<p>To test if your environment is working, go to the <code>tock/boards/imix</code> directory
and type <code>make program</code>. This should compile the kernel for the default board,
Imix, and try to program it over a USB serial connection. It may need to compile
several supporting libraries first (so may take 30 seconds or so the first
time). You should see output like this:</p>
<pre><code>$ make program
   Compiling tock-registers v0.2.0 (file:///Users/bradjc/git/tock/libraries/tock-register-interface)
   Compiling tock-cells v0.1.0 (file:///Users/bradjc/git/tock/libraries/tock-cells)
   Compiling enum_primitive v0.1.0 (file:///Users/bradjc/git/tock/libraries/enum_primitive)
   Compiling imix v0.1.0 (file:///Users/bradjc/git/tock/boards/imix)
   Compiling kernel v0.1.0 (file:///Users/bradjc/git/tock/kernel)
   Compiling cortexm v0.1.0 (file:///Users/bradjc/git/tock/arch/cortex-m)
   Compiling capsules v0.1.0 (file:///Users/bradjc/git/tock/capsules)
   Compiling cortexm4 v0.1.0 (file:///Users/bradjc/git/tock/arch/cortex-m4)
   Compiling sam4l v0.1.0 (file:///Users/bradjc/git/tock/chips/sam4l)
    Finished release [optimized + debuginfo] target(s) in 23.89s
   text    data     bss     dec     hex filename
 148192    5988   34968  189148   2e2dc target/thumbv7em-none-eabi/release/imix
tockloader  flash --address 0x10000 target/thumbv7em-none-eabi/release/imix.bin
No device name specified. Using default &quot;tock&quot;
No serial ports found. Is the board connected?

make: *** [program] Error 1
</code></pre>
<p>That is, since you don't yet have a board plugged in it can't program it. But
the above output indicates that it can compile correctly and invoke <code>tockloader</code>
to program a board.</p>
<h1><a class="header" href="#environment" id="environment">Environment</a></h1>
<p>The goal of this part of the course is to make sure you have a working
development environment for Tock.</p>
<p>During this portion of the course you will:</p>
<ul>
<li>Get a high-level overview of how Tock works.</li>
<li>Learn how to compile and flash the kernel onto an Imix board.</li>
</ul>
<h2><a class="header" href="#compile-and-program-the-kernel" id="compile-and-program-the-kernel">Compile and program the kernel</a></h2>
<p>All of the hands-on excercises will be done within the source code for this
book. So pop open a terminal, and navigate to the repository. If you're using
the VM, that'll be:</p>
<pre><code>$ cd ~/book
</code></pre>
<h3><a class="header" href="#make-sure-your-tock-repository-is-up-to-date" id="make-sure-your-tock-repository-is-up-to-date">Make sure your Tock repository is up to date</a></h3>
<pre><code>$ git pull
</code></pre>
<h3><a class="header" href="#build-the-kernel" id="build-the-kernel">Build the kernel</a></h3>
<p>To build the kernel, just type make in the <code>imix/</code> subdirectory.</p>
<pre><code>$ cd imix/
$ make
</code></pre>
<p>If this is the first time you are trying to make the kernel, the build system
will use cargo and rustup to install various Tock dependencies.</p>
<p>If this is your first time building a Tock kernel for this particular
architecture, you may get an error complaining that you don't have the proper
the <code>cargo</code> target installed. We can use <code>rustup</code> to fix that:</p>
<pre><code>$ rustup target add thumbv7em-none-eabi 
</code></pre>
<blockquote>
<p><code>imix</code> is based around an ARM Cortex-M4 microcontroller, which uses the
thumbv7em instruction set. The rustup command above just downloads Rust core
libraries for this architecture.</p>
</blockquote>
<h3><a class="header" href="#connect-to-an-imix-board" id="connect-to-an-imix-board">Connect to an imix board</a></h3>
<blockquote>
<h4><a class="header" href="#one-time-fixups" id="one-time-fixups">One-Time Fixups</a></h4>
<ul>
<li>
<p>On Linux, you might need to give your user access to the imix's serial port.
If you are using the VM, this is already done for you.
You can do this by adding a udev rule:</p>
<pre><code>$ sudo bash -c &quot;echo 'ATTRS{idVendor}==\&quot;0403\&quot;, ATTRS{idProduct}==\&quot;6015\&quot;, MODE=\&quot;0666\&quot;' &gt; /etc/udev/rules.d/99-imix&quot;
</code></pre>
<p>Afterwards, detach and re-attach the imix to reload the rule.</p>
</li>
<li>
<p>With the virtual machine, you might need to attach the USB device to the
VM. To do so, after plugging in imix, select in the VirtualBox/VMWare menu bar:</p>
<pre><code>Devices -&gt; USB Devices -&gt; imix IoT Module - TockOS
</code></pre>
<p>If this generates an error, often unplugging/replugging fixes it. You can also
create a rule in the VM USB settings which will auto-attach the imix to the VM.</p>
</li>
</ul>
</blockquote>
<p>To connect your development machine to the imix, connect them with a micro-USB
cable. Any cable will do, but notice that there are two USB ports on the imix.
Make sure you connect to the micro-USB port labeled 'debug' on the imix.</p>
<p>The imix board should appear as a regular serial device (e.g.
<code>/dev/tty.usbserial-c098e5130006</code> on my Mac and <code>/dev/ttyUSB0</code> on my Linux box).
While you can connect with any standard serial program (set to 115200 baud),
tockloader makes this easier. Tockloader can read attributes from connected
serial devices, and will automatically find your connected imix. Simply run:</p>
<pre><code>$ tockloader listen
No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/ttyUSB0 - Imix - TockOS&quot;

Listening for serial output.
Initialization complete. Entering main loop
Hello World!
</code></pre>
<h3><a class="header" href="#flash-the-kernel" id="flash-the-kernel">Flash the kernel</a></h3>
<p>Now that the imix board is connected and you have verified that the kernel
compiles, we can flash the imix board with the latest Tock kernel:</p>
<pre><code>$ cd imix/
$ make program
</code></pre>
<p>This command will compile the kernel if needed, and then use <code>tockloader</code> to
flash it onto the imix.</p>
<h3><a class="header" href="#install-some-applications" id="install-some-applications">Install some applications</a></h3>
<p>We have the kernel flashed, but the kernel doesn't actually <em>do</em> anything.
Applications do! We're going to install some pre-built applications, but first,
let's make sure we're in a clean state, in case your imix already had some
applications installed.</p>
<pre><code>$ tockloader erase-apps
</code></pre>
<p>This command removes any processes that may have already been installed.</p>
<p>Now, let's install two pre-compiled example apps.</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/blink.tab
</code></pre>
<p>The board should restart and the user LED should start blinking. Let's also
install a simple &quot;Hello World&quot; application:</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/c_hello.tab
</code></pre>
<blockquote>
<p>The <code>install</code> subcommand takes a path or URL to an TAB (Tock Application Binary) file to install.</p>
</blockquote>
<h3><a class="header" href="#clear-out-the-applications-and-re-flash-the-test-app" id="clear-out-the-applications-and-re-flash-the-test-app">Clear out the applications and re-flash the test app.</a></h3>
<p>Lets check what's on the board right now:</p>
<pre><code>$ tockloader list
...
[App 0]
  Name:                  blink
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes

[App 1]
  Name:                  c_hello
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   1024 bytes
</code></pre>
<p>As you can see, the old apps are still installed on the board.
This also nicely demonstrates that user applications are isolated from the
kernel: it is possible to update one independently of the other.
We can remove apps with the following command:</p>
<pre><code>$ tockloader uninstall
</code></pre>
<p>Following the prompt, if you remove the <code>blink</code> app, the LED will stop
blinking, however the console will still print <code>Hello World</code>.</p>
<p>Now let's try adding a more interesting app:</p>
<pre><code>$ tockloader install https://www.tockos.org/assets/tabs/sensors.tab
</code></pre>
<p>The <code>sensors</code> app will automatically discover all available sensors,
sample them once a second, and print the results.</p>
<pre><code>Listening for serial output.
Starting process console
Initialization complete. Entering main loop
[Sensors] Starting Sensors App.
Hello World!
[Sensors] All available sensors on the platform will be sampled.
ISL29035:   Light Intensity: 453
Temperature:                 24 deg C
Humidity:                    63%

ISL29035:   Light Intensity: 453
Temperature:                 24 deg C
Humidity:                    63%
</code></pre>
<h2><a class="header" href="#familiarize-yourself-with-tockloader-commands" id="familiarize-yourself-with-tockloader-commands">Familiarize yourself with <code>tockloader</code> commands</a></h2>
<p>The <code>tockloader</code> tool is a useful and versatile tool for managing and installing
applications on Tock. It supports a number of commands, and a more complete
list can be found in the tockloader repository, located at
<a href="https://github.com/tock/tockloader#usage">github.com/tock/tockloader</a>.
Below is a list of the more useful and important commands for programming and
querying a board.</p>
<h3><a class="header" href="#tockloader-install" id="tockloader-install"><code>tockloader install</code></a></h3>
<p>This is the main tockloader command, used to load Tock applications onto a
board.  By default, <code>tockloader install</code> adds the new application, but does not
erase any others, replacing any already existing application with the same
name.  Use the <code>--no-replace</code> flag to install multiple copies of the same app.
In order to install an app, either specify the <code>tab</code> file as an argument, or
navigate to the app's source directory, build it (probably using <code>make</code>), then
issue the install command:</p>
<pre><code>$ tockloader install
</code></pre>
<blockquote>
<p><em>Tip:</em> You can add the <code>--make</code> flag to have tockloader automatically
run make before installing, i.e. <code>tockloader install --make</code></p>
</blockquote>
<blockquote>
<p><em>Tip:</em> You can add the <code>--erase</code> flag to have tockloader automatically
remove other applications when installing a new one.</p>
</blockquote>
<h3><a class="header" href="#tockloader-uninstall-application-names" id="tockloader-uninstall-application-names"><code>tockloader uninstall [application name(s)]</code></a></h3>
<p>Removes one or more applications from the board by name.</p>
<h3><a class="header" href="#tockloader-erase-apps" id="tockloader-erase-apps"><code>tockloader erase-apps</code></a></h3>
<p>Removes all applications from the board.</p>
<h3><a class="header" href="#tockloader-list" id="tockloader-list"><code>tockloader list</code></a></h3>
<p>Prints basic information about the apps currently loaded onto the board.</p>
<h3><a class="header" href="#tockloader-info" id="tockloader-info"><code>tockloader info</code></a></h3>
<p>Shows all properties of the board, including information about currently
loaded applications, their sizes and versions, and any set attributes.</p>
<h3><a class="header" href="#tockloader-listen" id="tockloader-listen"><code>tockloader listen</code></a></h3>
<p>This command prints output from Tock apps to the terminal. It listens via UART,
and will print out anything written to stdout/stderr from a board.</p>
<blockquote>
<p><em>Tip:</em> As a long-running command, <code>listen</code> interacts with other tockloader
sessions. You can leave a terminal window open and listening. If another
tockloader process needs access to the board (e.g. to install an app update),
tockloader will automatically pause and resume listening.</p>
</blockquote>
<h3><a class="header" href="#tockloader-flash" id="tockloader-flash"><code>tockloader flash</code></a></h3>
<p>Loads binaries onto hardware platforms that are running a compatible bootloader.
This is used by the Tock Make system when kernel binaries are programmed to the
board with <code>make program</code>.</p>
<h2><a class="header" href="#explore-other-example-applications" id="explore-other-example-applications">Explore other example applications</a></h2>
<p>Other applications can be found in the <code>examples</code> subdirectory of the libtock-c repository:</p>
<pre><code>$ git clone https://github.com/tock/libtock-c
</code></pre>
<p>Try loading them on your imix and then try modifying them. By default,
<code>tockloader install</code> adds the new application, but does not erase any others.
Be aware, not all applications will work well together if they need the same
resources (Tock is in active development to add virtualization to all resources
to remove this issue!).</p>
<p><strong>Note:</strong> By default, the imix platform is limited to only running four
concurrent processes at once. Tockloader is (currently) unaware of this
limitation, and will allow to you to load additional apps. However the kernel
will only load the first four apps. One option for the free-form section at the
end of the tutorial will be to explore this limitation and allow more apps.</p>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<p>The various modules are independent lessons that guide you through certain
aspects of Tock. You should be able to do the lessons that are of interest to
you.</p>
<h1><a class="header" href="#write-an-environment-sensing-application" id="write-an-environment-sensing-application">Write an environment sensing application</a></h1>
<h2><a class="header" href="#process-overview-relocation-model-and-system-call-api" id="process-overview-relocation-model-and-system-call-api">Process overview, relocation model and system call API</a></h2>
<p>In this section, we're going to learn about processes (a.k.a applications) in
Tock, and build our own applications in C.</p>
<h2><a class="header" href="#get-a-c-application-running-on-your-board" id="get-a-c-application-running-on-your-board">Get a C application running on your board</a></h2>
<p>You'll find the outline of a C application in the directory
<code>exercises/app</code>.</p>
<p>Take a look at the code in <code>main.c</code>. So far, this application merely prints
&quot;Hello, World!&quot;.</p>
<p>The code uses the standard C library routine <code>printf</code> to compose a message
using a format string and print it to the console. Let's break down what the
code layers are here:</p>
<ol>
<li>
<p><code>printf</code> is provided by the C standard library (implemented by
<a href="https://sourceware.org/newlib/">newlib</a>). It takes the format string and
arguments, and generates an output string from them. To actually write the
string to standard out, <code>printf</code> calls <code>_write</code>.</p>
</li>
<li>
<p><code>_write</code> (in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/sys.c"><code>sys.c</code></a>) is a
wrapper for actually writing to output streams (in this case, standard out
a.k.a. the console). It calls the Tock-specific console writing function
<code>putnstr</code>.</p>
</li>
<li>
<p><code>putnstr</code>(in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/console.c"><code>console.c</code></a>)
is a buffers data to be written, calls <code>putnstr_async</code>, and acts as a
synchronous wrapper, yielding until the operation is complete.</p>
</li>
<li>
<p>Finally, <code>putnstr_async</code> (in <code>libtock-c</code>'s
<a href="https://github.com/tock/libtock-c/tree/master/libtock/console.c"><code>console.c</code></a>)
performs the actual system calls, calling to <code>allow</code>, <code>subscribe</code>, and
<code>command</code> to enable the kernel to access the buffer, request a callback when
the write is complete, and begin the write operation respectively.</p>
</li>
</ol>
<p>The application could accomplish all of this by invoking Tock system calls
directly, but using libraries makes for a much cleaner interface and allows
users to not need to know the inner workings of the OS.</p>
<h3><a class="header" href="#loading-an-application" id="loading-an-application">Loading an application</a></h3>
<p>Okay, let's build and load this simple program.</p>
<ol>
<li>
<p>Erase all other applications from the development board:</p>
<pre><code> $ tockloader erase-apps
</code></pre>
</li>
<li>
<p>Build the application and load it (Note: <code>tockloader install</code> automatically searches the
current working directory and its subdirectories for Tock binaries.)</p>
<pre><code> $ tockloader install --make
</code></pre>
</li>
<li>
<p>Check that it worked:</p>
<pre><code> $ tockloader listen
</code></pre>
</li>
</ol>
<p>The output should look something like:</p>
<pre><code>$ tockloader listen
No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/cu.usbserial-c098e5130012 - Hail IoT Module - TockOS&quot;

Listening for serial output.
Hello, World!
</code></pre>
<h2><a class="header" href="#creating-your-own-application" id="creating-your-own-application">Creating your own application</a></h2>
<p>Now that you've got a basic app working, modify it so that it continuously
prints out <code>Hello World</code> twice per second.  You'll want to use the user
library's timer facilities to manage this:</p>
<h3><a class="header" href="#timer" id="timer">Timer</a></h3>
<p>You'll find the interface for timers in <code>libtock/timer.h</code>. The
function you'll find useful today is:</p>
<pre><code class="language-c">#include &lt;timer.h&gt;
void delay_ms(uint32_t ms);
</code></pre>
<p>This function sleeps until the specified number of milliseconds have passed, and
then returns.  So we call this function &quot;synchronous&quot;: no further code will run
until the delay is complete.</p>
<h2><a class="header" href="#write-an-app-that-periodically-samples-the-on-board-sensors" id="write-an-app-that-periodically-samples-the-on-board-sensors">Write an app that periodically samples the on-board sensors</a></h2>
<p>Now that we have the ability to write applications, let's do something a little
more complex. The development board you are using has several sensors on it.
These sensors include a light sensor, a humidity sensor, and a temperature
sensor. Each sensing medium can be accessed separately via the Tock user
library. We'll just be using the light and temperature for this excercise.</p>
<h4><a class="header" href="#light" id="light">Light</a></h4>
<p>The interface in <code>libtock/ambient_light.h</code> is used to measure ambient
light conditions in <a href="https://en.wikipedia.org/wiki/Lux">lux</a>. imix uses the
<a href="https://www.intersil.com/en/products/optoelectronics/ambient-light-sensors/light-to-digital-sensors/ISL29035.html">ISL29035</a>
sensor, but the userland library is abstracted from the details of particular
sensors.  It contains the function:</p>
<pre><code class="language-c">#include &lt;ambient_light.h&gt;
int ambient_light_read_intensity_sync(int* lux);
</code></pre>
<p>Note that the light reading is written to the location passed as an
argument, and the function returns non-zero in the case of an error.</p>
<h4><a class="header" href="#temperature" id="temperature">Temperature</a></h4>
<p>The interface in <code>libtock/temperature.h</code> is used to measure ambient
temperature in degrees Celsius, times 100. imix uses the
<a href="https://www.silabs.com/products/sensors/humidity-sensors/Pages/si7013-20-21.aspx">SI7021</a>
sensor. It contains the function:</p>
<pre><code class="language-c">#include &lt;temperature.h&gt;
int temperature_read_sync(int* temperature);
</code></pre>
<p>Again, this function returns non-zero in the case of an error.</p>
<h3><a class="header" href="#read-sensors-in-a-tock-application" id="read-sensors-in-a-tock-application">Read sensors in a Tock application</a></h3>
<p>Using the example program you're working on, write an application that reads
all of the sensors on your development board and reports their readings over
the serial port.</p>
<p>As a bonus, experiment with toggling an LED when readings are above or below a
certain threshold:</p>
<h4><a class="header" href="#led" id="led">LED</a></h4>
<p>The interface in <code>libtock/led.h</code> is used to control lights on Tock boards. On the Hail
board, there are three LEDs which can be controlled: Red, Blue, and Green. The
functions in the LED module are:</p>
<pre><code class="language-c">#include &lt;led.h&gt;
int led_count(void);
</code></pre>
<p>Which returns the number of LEDs available on the board.</p>
<pre><code class="language-c">int led_on(int led_num);
</code></pre>
<p>Which turns an LED on, accessed by its number.</p>
<pre><code class="language-c">int led_off(int led_num);
</code></pre>
<p>Which turns an LED off, accessed by its number.</p>
<pre><code class="language-c">int led_toggle(int led_num);
</code></pre>
<p>Which toggles the state of an LED, accessed by its number.</p>
<h1><a class="header" href="#keep-the-client-happy" id="keep-the-client-happy">Keep the client happy</a></h1>
<p>You, an engineer newly added to a top-secret project in your organization, have
been directed to commission a new imix node for your most important client. The
directions you receive are terse, but helpful:</p>
<pre><code>On Sunday, Nov 4, 2018, Director Hines wrote:

Welcome to the team, need you to get started right away. The client needs an
imix setup with their two apps -- ASAP. Make sure it is working, we need to keep
this client happy.

- DH
</code></pre>
<p>Hmm, ok, not a lot to go on, but luckily in orientation you learned how to flash
a kernel and apps on to the imix board, so you are all set for your first
assignment.</p>
<p>Poking around, you notice a folder called &quot;important-client&quot;. While that is a
good start, you also notice that it has two apps inside of it! &quot;Alright!&quot; you
are thinking, &quot;My first day is shaping up to go pretty smoothly.&quot;</p>
<p>After installing those two apps, which are a little mysterious still, you decide
that it would also be a good idea to install an app you are more familiar with:
the &quot;blink&quot; app. After doing all of that, you run <code>tockloader list</code> and see the
following:</p>
<pre><code>$ tockloader list

No device name specified. Using default &quot;tock&quot;
Using &quot;/dev/ttyUSB1 - imix IoT Module - TockOS&quot;

[App 0]
  Name:                  app2
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   16384 bytes


[App 1]
  Name:                  app1
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   8192 bytes


[App 2]
  Name:                  blink
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes


Finished in 1.959 seconds
</code></pre>
<hr />
<blockquote>
<p><strong>Checkpoint</strong></p>
<p>Make sure you have these apps installed correctly and <code>tockloader list</code>
produces similar output as shown here.</p>
</blockquote>
<hr />
<p>Great! Now you check that the LED is blinking, and sure enough, no problems
there. The blink app was just for testing, so you <code>tockloader uninstall blink</code>
to remove that. So far, so good, Tock! But, before you prepare to head home
after a successful day, you start to wonder if maybe this was a little too easy.
Also, if you get this wrong, it's not going to look good as the new person on
the team.</p>
<p>Looking in the folders for the two applications, you notice a brief description
of the apps, and a URL. Ok, maybe you can check if everything is working.
After trying things for a little bit, everything seems to be in order. You
tell the director the board is ready and head home a little early—you did
just successfully complete your first project for a major client after all.</p>
<h2><a class="header" href="#back-at-work-the-next-day" id="back-at-work-the-next-day">Back at Work the Next Day</a></h2>
<p>Expecting a more challenging project after how well things went yesterday, you
are instead greeted by this email:</p>
<pre><code>On Monday, Nov 5, 2018, Director Hines wrote:

I know you are new, but what did you do?? I've been getting calls all morning
from the client, the imix board you gave them ran out battery already!! Are you
sure you set up the board correctly? Fix it, and get it back to me later today.

- DH
</code></pre>
<p>Well, that's not good. You already removed the blink app, so it can't be that.
What you need is some way to inspect the board and see if something looks like
it is going awry. You first try:</p>
<pre><code>$ tockloader listen
</code></pre>
<p>to see if any debugging information is being printed. A little, but nothing
helpful. Before trying to look around the code, you decided to try sending the
board a plea for help:</p>
<pre><code>help
</code></pre>
<p>and, surprisingly, it responded!</p>
<pre><code>Welcome to the process console.
Valid commands are: help status list stop start
</code></pre>
<p>Ok! Maybe the process console can help. Try the <code>status</code> command:</p>
<pre><code>Total processes: 2
Active processes: 2
Timeslice expirations: 4277
</code></pre>
<p>It seems this tool is actually able to inspect the current system and the active
processes! But hmmm, it seems there are a lot of &quot;timeslice expirations&quot;. From
orientation, you remember that processes are allocated only a certain quantum of
time to execute, and if they exceed that the kernel forces a context switch back
to the kernel. If that is happening a lot, then the board is likely unable to go
to sleep! That could explain why the battery is draining so fast!</p>
<p>But which process is at fault? Perhaps we should try another command.
Maybe <code>list</code>:</p>
<pre><code> PID    Name                Quanta  Syscalls  Dropped Callbacks    State
  00	app2                     0       336                  0  Yielded
  01	app1                  8556   1439951                  0  Running
</code></pre>
<p>Ok! Now we have the status of individual applications. And aha! We can clearly
see the faulty application. From our testing we know that one app detects
button presses and one app is transmitting sensor data. Let's see if we can
disable the faulty app somehow and see which data packets we are still getting.
Going back to the help command, the <code>stop</code> command seems promising:</p>
<pre><code>stop &lt;app name&gt;
</code></pre>
<h2><a class="header" href="#time-to-fix-the-app" id="time-to-fix-the-app">Time to Fix the App</a></h2>
<p>After debugging, we now know a couple things about the issue:</p>
<ul>
<li>The name of the faulty app.</li>
<li>That it is functionally correct but is for some reason consuming excess CPU
cycles.</li>
</ul>
<p>Using this information, dig into the the faulty app.</p>
<h3><a class="header" href="#a-quick-fix" id="a-quick-fix">A Quick Fix</a></h3>
<p>To get the director off your back, you should be able to introduce a simple fix
that will reduce wakeups by waiting a bit between samples.</p>
<h3><a class="header" href="#a-better-way" id="a-better-way">A Better Way</a></h3>
<p>While the quick fix will slow the number of wakeups, you know that you can do
better than polling for something like a button press! Tock supports
asynchronous operations allowing user processes to <em>subscribe</em> to interrupts.</p>
<p>Looking at the button interface (in button.h), it looks like we'll first have to
enable interrupts and then sign up to listen to them.</p>
<p>Once this energy-optimal patch is in place, it'll be time to kick off a
triumphant e-mail to the director, and then off to celebrate!</p>
<h1><a class="header" href="#capsule" id="capsule">Capsule</a></h1>
<p>The goal of this part of the course is to make you comfortable with the
Tock kernel and writing code for it. By the end of this part, you'll have
written a new capsule that reads a humidity sensor and outputs its readings
over the serial port.</p>
<p>During this you will:</p>
<ol>
<li>Learn how Tock uses Rust's memory safety to provide isolation for free</li>
<li>Read the Tock boot sequence, seeing how Tock uses static allocation</li>
<li>Learn about Tock's event-driven programming</li>
<li>Write a new capsule that reads a humidity sensor and prints it over serial</li>
</ol>
<h2><a class="header" href="#read-the-tock-boot-sequence-20m" id="read-the-tock-boot-sequence-20m">Read the Tock boot sequence (20m)</a></h2>
<p>Open <code>imix/src/main.rs</code> in your favorite editor. This file defines the
imix platform: how it boots, what capsules it uses, and what system calls it
supports for userland applications.</p>
<h3><a class="header" href="#how-is-everything-organized" id="how-is-everything-organized">How is everything organized?</a></h3>
<p>Find the declaration of <code>struct Imix</code> (it's pretty early in the file).
This declares the structure representing the platform. It has many fields,
all of which are capsules. These are the capsules that make up the imix
platform. For the most part, these map directly to hardware peripherals,
but there are exceptions such as <code>IPC</code> (inter-process communication).</p>
<p>Recall the discussion about how everything in the kernel is statically
allocated? We can see that here. Every field in <code>struct Imix</code> is a reference to
an object with a static lifetime.</p>
<p>The capsules themselves take a lifetime as a parameter, which is currently
always <code> `static</code>.  The implementations of these capsules, however, do not
rely on this assumption.</p>
<p>The boot process is primarily the construction of this <code>Imix</code> structure. Once
everything is set up, the board will pass the constructed <code>imix</code> to
<code>kernel::kernel_loop</code> and we're off to the races.</p>
<h3><a class="header" href="#how-do-things-get-started" id="how-do-things-get-started">How do things get started?</a></h3>
<p>The method <code>reset_handler</code> is invoked when the chip resets (i.e., boots).
It's pretty long because imix has a lot of drivers that need to be created
and initialized, and many of them depend on other, lower layer abstractions
that need to be created and initialized as well.</p>
<p>Take a look at the first few lines of the <code>reset_handler</code>. The boot sequence
initializes memory (copies initialized variables into RAM, clears the BSS),
sets up the system clocks, and configures the GPIO pins.</p>
<h3><a class="header" href="#how-do-capsules-get-created" id="how-do-capsules-get-created">How do capsules get created?</a></h3>
<p>The next lines of <code>reset_handler</code> create and initialize the system console,
which is what turns calls to <code>println</code> into bytes sent to the USB serial port:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let uart_mux = static_init!(
    MuxUart&lt;'static&gt;,
    MuxUart::new(
        &amp;sam4l::usart::USART3,
        &amp;mut capsules::virtual_uart::RX_BUF,
        115200
    )
);
uart_mux.initialize();

hil::uart::Transmit::set_transmit_client(&amp;sam4l::usart::USART3, uart_mux);
hil::uart::Receive::set_receive_client(&amp;sam4l::usart::USART3, uart_mux);

let console = ConsoleComponent::new(board_kernel, uart_mux).finalize();
#}</code></pre></pre>
<p>Eventually, once all of the capsules have been created, we will populate
a imix structure with them:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let imix = Imix {
    console: console,
    gpio: gpio,
    ...
#}</code></pre></pre>
<p>The <code>static_init!</code> macro is simply an easy way to allocate a static
variable with a call to <code>new</code>. The first parameter is the type, the second
is the expression to produce an instance of the type. This call creates
a <code>Console</code> that uses serial port 3 (<code>USART3</code>) at 115200 bits per second.</p>
<blockquote>
<h4><a class="header" href="#a-brief-aside-on-buffers" id="a-brief-aside-on-buffers">A brief aside on buffers:</a></h4>
<p>Notice that you have to pass a write buffer to the console for it to use:
this buffer has to have a <code> `static</code> lifetime. This is because low-level
hardware drivers, especially those that use DMA, require <code> `static</code> buffers.
Since Tock doesn't promise when a DMA operation will complete, and you
need to be able to promise that the buffer outlives the operation, the
one lifetime that is assured to be alive at the end of an operation is
<code> `static</code>. So that other code which has buffers
without a <code> `static</code> lifetime, such as userspace processes, can use the
<code>Console</code>, it copies them into its own internal <code> `static</code> buffer before
passing it to the serial port. So the buffer passing architecture looks like
this:</p>
<p><img src="../imgs/console.svg" alt="Console/UART buffer lifetimes" /></p>
<p>It's a little weird that Console's <code>new</code> method takes in a reference to
itself. This is an ergonomics tradeoff. The Console needs a mutable static
buffer to use internally, which the Console capsule declares. However writing
global statics is unsafe. To avoid the unsafe operation in the Console
capsule itself, we make it the responsibility of the instantiator to give the
Console a buffer to use, without burdening the instantiator with sizing the
buffer.</p>
</blockquote>
<h3><a class="header" href="#lets-make-an-imix" id="lets-make-an-imix">Let's make an imix!</a></h3>
<p>The code continues on, creating all of the other capsules that are needed
by the imix platform. By the time we get down to around line 360, we've
created all of the capsules we need, and it's time to create the actual
imix platform structure (<code>let imix = Imix {</code> ...).</p>
<h3><a class="header" href="#capsule-initialization" id="capsule-initialization">Capsule <em>initialization</em></a></h3>
<p>Up to this point we have been creating numerous structures and setting some
static configuration options and mappings, but nothing dynamic has occurred
(said another way, all methods invoked by <code>static_init!</code> must be <code>const fn</code>,
however Tock's <code>static_init!</code> macro predates stabilization of <code>const fn</code>'s.
A future iteration could possibly leverage these and obviate the need for the
macro).</p>
<p>Some capsules require <em>initialization</em>, some code that must be executed
before they can be used. For example, a few lines after creating the imix
struct, we initialize the console:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
imix.nrf51822.initialize();
#}</code></pre></pre>
<p>This method is responsible for actually writing the hardware registers that
configure the associated UART peripheral for use as a text console
(8 data bits, 1 stop bit, no parity bit, no hardware flow control).</p>
<h3><a class="header" href="#inter-capsule-dependencies" id="inter-capsule-dependencies">Inter-capsule dependencies</a></h3>
<p>Just after initializing the console capsule, we find this line:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::debug::assign_console_driver(Some(imix.console), kc);
#}</code></pre></pre>
<p>This configures the kernel's <code>debug!</code> macro to print messages to this console
we've just created. The <code>debug!</code> mechanism can be very helpful during
development and testing. Today we're going to use it to print output from the
capsule you create.</p>
<p>Let's try it out really quick:</p>
<pre><code class="language-diff">--- a/boards/imix/src/main.rs
+++ b/boards/imix/src/main.rs
@@ -10,7 +10,7 @@
 extern crate capsules;
 extern crate cortexm4;
 extern crate compiler_builtins;
-#[macro_use(static_init)]
+#[macro_use(debug, static_init)]
 extern crate kernel;
 extern crate sam4l;

@@ -388,6 +388,8 @@ pub unsafe fn reset_handler() {
         capsules::console::App::default());
     kernel::debug::assign_console_driver(Some(imix.console), kc);

+    debug!(&quot;Testing 1, 2, 3...&quot;);
+
     imix.nrf51822.initialize();
</code></pre>
<p>Compile and flash the kernel (<code>make program</code>) then look at the output
(<code>tockloader listen</code>).</p>
<ul>
<li>What happens if you put the <code>debug!</code> before <code>assign_console_driver</code>?</li>
<li>What happens if you put <code>imix.console.initialize()</code> after
<code>assign_console_driver</code>?</li>
</ul>
<p>As you can see, sometimes there are dependencies between capsules, and board
authors must take care during initialization to ensure correctness.</p>
<blockquote>
<p><strong>Note:</strong> The <code>debug!</code> implementation is <em>asynchronous</em>. It copies messages
into a buffer and the console prints them via DMA as the UART peripheral is
available, interleaved with other console users (i.e. processes). You
shouldn't need to worry about the mechanics of this for now.</p>
</blockquote>
<h3><a class="header" href="#loading-processes" id="loading-processes">Loading processes</a></h3>
<p>Once the platform is all set up, the board is responsible for loading processes
into memory:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::process::load_processes(&amp;_sapps as *const u8,
                                &amp;mut APP_MEMORY,
                                &amp;mut PROCESSES,
                                FAULT_RESPONSE);
#}</code></pre></pre>
<p>A Tock process is represented by a <code>kernel::Process</code> struct. In principle, a
platform could load processes by any means. In practice, all existing platforms
write an array of Tock Binary Format (TBF) entries to flash. The kernel provides
the <code>load_processes</code> helper function that takes in a flash address and begins
iteratively parsing TBF entries and making <code>Process</code>es.</p>
<h3><a class="header" href="#starting-the-kernel" id="starting-the-kernel">Starting the kernel</a></h3>
<p>Finally, the board passes a reference to the current platform, the chip the
platform is built on (used for interrupt and power handling), the processes to
run, and an IPC server instance to the main loop of the kernel:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
kernel::main(&amp;imix, &amp;mut chip, &amp;mut PROCESSES, &amp;imix.ipc);
#}</code></pre></pre>
<p>From here, Tock is initialized, the kernel event loop takes over, and the
system enters steady state operation.</p>
<h3><a class="header" href="#create-a-hello-world-capsule" id="create-a-hello-world-capsule">Create a &quot;Hello World&quot; capsule</a></h3>
<p>Now that you've seen how Tock initializes and uses capsules, you're going to
write a new one. At the end of this section, your capsule will sample the
humidity sensor once a second and print the results as serial output. But
you'll start with something simpler: printing &quot;Hello World&quot; to the debug
console once on boot.</p>
<p>The <code>imix</code> board configuration you've looked through has a capsule for the this
tutorial already set up. The capsule is a separate Rust crate located in
<code>excercises/capsule</code>. You'll complete this excercise by filling it in.</p>
<p>In addition to a constructor, Our capsule has <code>start</code> function defined that is
currently empty. The board configuration calls this function once it has
initialized the capsule.</p>
<p>Eventually, the <code>start</code> method will kick off a state machine for periodic
humidity readings, but for now, let's just print something to the debug console
and return:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
debug!(&quot;Hello from the kernel!&quot;);
#}</code></pre></pre>
<pre><code class="language-bash">$ cd [PATH_TO_BOOK]/imix
$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Hello from the kernel!
</code></pre>
<h2><a class="header" href="#extend-your-capsule-to-print-hello-world-every-second" id="extend-your-capsule-to-print-hello-world-every-second">Extend your capsule to print &quot;Hello World&quot; every second</a></h2>
<p>In order for your capsule to keep track of time, it will need to depend on
another capsule that implements the Alarm interface. We'll have to do something
similar for reading the accelerometer, so this is good practice.</p>
<p>The Alarm HIL includes several traits, <code>Alarm</code>, <code>Client</code>, and <code>Frequency</code>, all
in the <code>kernel::hil::time</code> module. You'll use the <code>set_alarm</code> and <code>now</code> methods
from the <code>Alarm</code> trait to set an alarm for a particular value of the clock.
Note that both methods accept arguments in the alarm's native clock frequency,
which is available using the Alarm trait's associated <code>Frequency</code> type:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// native clock frequency in Herz
let frequency = &lt;A::Frequency&gt;::frequency();
#}</code></pre></pre>
<p>Your capsule already implements the <code>alarm::Client</code> trait so it can receive
alarm events. The <code>alarm::Client</code> trait has a single method:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn fired(&amp;self)
#}</code></pre></pre>
<p>Your capsule should now set an alarm in the <code>start</code> method, print the debug
message and set an alarm again when the alarm fires.</p>
<p>Compile and program your new kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
TOCK_DEBUG(0): /home/alevy/hack/helena/rustconf/tock/boards/imix/src/accelerate.rs:31: Hello World
</code></pre>
<p><a href="https://gist.github.com/alevy/73fca7b0dddcb5449088cebcbfc035f1">Sample Solution</a></p>
<h2><a class="header" href="#extend-your-capsule-to-sample-the-humidity-once-a-second" id="extend-your-capsule-to-sample-the-humidity-once-a-second">Extend your capsule to sample the humidity once a second</a></h2>
<p>The steps for reading an accelerometer from your capsule are similar to using
the alarm. You'll use a capsule that implements the humidity HIL, which
includes the <code>HumidityDriver</code> and <code>HumidityClient</code> traits, both in
<code>kernel::hil::sensors</code>.</p>
<p>The <code>HumidityDriver</code> trait includes the method <code>read_accelerometer</code> which
initiates an accelerometer reading. The <code>HumidityClient</code> trait has a single
method for receiving readings:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn callback(&amp;self, humidity: usize);
#}</code></pre></pre>
<p>Implement logic to initiate a accelerometer reading every second and report the
results.</p>
<p><img src="../imgs/rustconf.svg" alt="Structure of rustconf capsule" /></p>
<p>Compile and program your kernel:</p>
<pre><code class="language-bash">$ make program
$ tockloader listen
No device name specified. Using default &quot;tock&quot;                                                                         Using &quot;/dev/ttyUSB0 - Imix IoT Module - TockOS&quot;
Listening for serial output.
Humidity 2731
Humidity 2732
</code></pre>
<p><a href="https://gist.github.com/alevy/798d11dbfa5409e0aa56d870b4b7afcf">Sample solution</a></p>
<h2><a class="header" href="#some-further-questions-and-directions-to-explore" id="some-further-questions-and-directions-to-explore">Some further questions and directions to explore</a></h2>
<p>Your capsule used the si7021 and virtual alarm. Take a look at the
code behind each of these services:</p>
<ol>
<li>
<p>Is the humidity sensor on-chip or a separate chip connected over a bus?</p>
</li>
<li>
<p>What happens if you request two humidity sensors back-to-back?</p>
</li>
<li>
<p>Is there a limit on how many virtual alarms can be created?</p>
</li>
<li>
<p>How many virtual alarms does the imix boot sequence create?</p>
</li>
</ol>
<h3><a class="header" href="#extra-credit-write-a-virtualization-capsule-for-humidity-sensor-" id="extra-credit-write-a-virtualization-capsule-for-humidity-sensor-"><strong>Extra credit</strong>: Write a virtualization capsule for humidity sensor (∞)</a></h3>
<p>If you have extra time, try writing a virtualization capsule for the <code>Humidity</code>
HIL that will allow multiple clients to use it. This is a fairly open ended
task, but you might find inspiration in the <code>virtua_alarm</code> and <code>virtual_i2c</code>
capsules.</p>
<h1><a class="header" href="#graduation" id="graduation">Graduation</a></h1>
<p>Now that you have the basics of Tock down, we encourage you to continue to
explore and develop with Tock! This book includes a &quot;slimmed down&quot; version of
Tock to make it easy to get started, but you will likely want to get a more
complete development environment setup to continue. Luckily, this shouldn't be
too difficult since you have the tools installed already.</p>
<h2><a class="header" href="#using-the-latest-kernel" id="using-the-latest-kernel">Using the latest kernel</a></h2>
<p>The Tock kernel is actively developed, and you likely want to build upon the
latest features. To do this, you should get the Tock source from the repository:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/tock
</code></pre>
<p>While the <code>master</code> branch tends to be relatively stable, you may want to use the
latest <a href="https://github.com/tock/tock/releases">release</a> instead. Tock is
thoroughly tested before a release, so this should be a reliable place to start.
To select a release, you should checkout the correct tag. For example, for the
1.4 release this looks like:</p>
<pre><code class="language-bash">$ cd tock
$ git checkout release-1.4
</code></pre>
<p>You should use the latest release. Check the <a href="https://github.com/tock/tock/releases">releases
page</a> for the name of the latest release.</p>
<p>Now, you can compile the board-specific kernel in the Tock repository. For
example, to compile the kernel for imix:</p>
<pre><code class="language-bash">$ cd boards/imix
$ make
</code></pre>
<p>All of the operations described in the course should work the same way on the
main repository.</p>
<h2><a class="header" href="#using-the-full-selection-of-apps" id="using-the-full-selection-of-apps">Using the full selection of apps</a></h2>
<p>The book includes some very minimal apps, and many more can be found in the
<code>libtock-c</code> repository. To use this, you should start by cloning the repository:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/libtock-c
</code></pre>
<p>Now you can compile and run apps inside of the examples folder. For instance,
you can install the basic &quot;Hello World!&quot; app:</p>
<pre><code class="language-bash">$ cd libtock-c/examples/c_hello
$ make
$ tockloader install
</code></pre>
<p>With the <code>libtock-c</code> repository you have access to the full suite of Tock apps,
and additional libraries include BLE and Lua support.</p>
<h1><a class="header" href="#tock-mini-tutorials-1" id="tock-mini-tutorials-1">Tock Mini Tutorials</a></h1>
<p>These tutorials walk through how to use some various features of Tock. They are
narrower in scope than the course, but try to explain in detail how various Tock
apps work.</p>
<p>You will need the <code>libtock-c</code> repository to run these tutorials. You should
check out a copy of <code>libtock-c</code> by running:</p>
<pre><code>$ git clone https://github.com/tock/libtock-c
</code></pre>
<p><code>libtock-c</code> contains many example Tock applications as well as the library
support code for running C and C++ apps on Tock. If you are looking to develop
Tock applications you will likely want to start with an existing app in
<code>libtock-c</code> and modify it.</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>You need to be able to compile and load the Tock kernel and Tock applications.
See the <a href="tutorials/../prerequisites.html">prerequisites guide</a> on how to get setup.</p>
<p>You also need <a href="https://tockos.org/hardware">hardware</a> that supports Tock.</p>
<p>The tutorials assume you have a Tock kernel loaded on your hardware board. To
get a kernel installed, follow these steps.</p>
<ol>
<li>
<p><strong>Obtain the Tock Source</strong>. You can clone a copy of the Tock repository to
get the kernel source:</p>
<pre><code class="language-bash">$ git clone https://github.com/tock/tock
$ cd tock
</code></pre>
</li>
<li>
<p><strong>Compile Tock</strong>. In the root of the Tock directory, compile the kernel for
your hardware platform. You can find a list of boards by running <code>make list</code>.
For example if your board is <code>imix</code> then:</p>
<pre><code class="language-bash">$ make list
$ cd boards/imix
$ make
</code></pre>
<p>If you have another board just replace &quot;imix&quot; with <code>&lt;your-board&gt;</code></p>
<p>This will create binaries of the Tock kernel. Tock is compiled with Cargo, a
package manager for Rust applications. The first time Tock is built all of
the crates must be compiled. On subsequent builds, crates that haven't
changed will not have to be rebuilt and the compilation will be faster.</p>
</li>
<li>
<p><strong>Load the Tock Kernel</strong>. The next step is to program the Tock kernel onto
your hardware. Generally, two options are supported for loading the kernel:
<code>make program</code> and <code>make flash</code>. You should likely try <code>make program</code> first.
Alternatively, the README file for the board should show which options are
available. To load the kernel, run:</p>
<pre><code class="language-bash">$ make program  # Load code via bootloader
  -- or --      # Check the README in your board folder
$ make flash    # Load code via jtag
</code></pre>
<p>in the board directory. Now you have the kernel loaded onto the hardware.
The kernel configures the hardware and provides drivers for many hardware
resources, but does not actually include any application logic. For that, we
need to load an application.</p>
<p>Note, you only need to program the kernel once. Loading applications does
not alter the kernel, and applications can be re-programed without
re-programming the kernel.</p>
</li>
</ol>
<p>With the kernel setup, you are ready to try the mini tutorials.</p>
<h2><a class="header" href="#tutorials" id="tutorials">Tutorials</a></h2>
<ol>
<li><strong><a href="tutorials/01_running_blink.html">Blink an LED</a></strong>: Get your first Tock app running.</li>
<li><strong><a href="tutorials/02_button_print.html">Button to Printf()</a></strong>: Print to terminal in response
to button presses.</li>
<li><strong><a href="tutorials/03_ble_scan.html">BLE Advertisement Scanning</a></strong>: Sense nearby BLE packets.</li>
<li><strong><a href="tutorials/04_sensors_and_drivers.html">Sample Sensors and Use Drivers</a></strong>: Use syscalls
to interact with kernel drivers.</li>
<li><strong><a href="tutorials/05_ipc.html">Inter-process Communication</a></strong>: Tock's IPC mechanism.</li>
</ol>
<h3><a class="header" href="#board-compatiblity-matrix" id="board-compatiblity-matrix">Board compatiblity matrix</a></h3>
<table><thead><tr><th>Tutorial #</th><th>Supported boards</th></tr></thead><tbody>
<tr><td>1</td><td>All</td></tr>
<tr><td>2</td><td>All Cortex-M based boards</td></tr>
<tr><td>3</td><td>Hail and imix</td></tr>
<tr><td>4</td><td>Hail and imix</td></tr>
<tr><td>5</td><td>All that support IPC</td></tr>
</tbody></table>
<h1><a class="header" href="#blink-running-your-first-app" id="blink-running-your-first-app">Blink: Running Your First App</a></h1>
<p>This guide will help you get the <code>blink</code> app running on top of Tock kernel.</p>
<h2><a class="header" href="#instructions" id="instructions">Instructions</a></h2>
<ol>
<li>
<p><strong>Erase any existing applications</strong>. First, we need to remove any applications already
on the board. Note that Tockloader by default will install any application in
addition to whatever is already installed on the board.</p>
<pre><code class="language-bash">$ tockloader erase-apps
</code></pre>
</li>
<li>
<p><strong>Install Blink</strong>. Tock supports an &quot;app store&quot; of sorts. That is, tockloader
can install apps from a remote repository, including Blink. To do this:</p>
<pre><code class="language-bash">$ tockloader install blink
</code></pre>
<p>You will have to tell Tockloader that you are OK with fetching the app from
the Internet.</p>
<p>Your specific board may require additional arguments, please see the readme
in the <code>boards/</code> folder for more details.</p>
</li>
<li>
<p><strong>Compile and Install Blink</strong>. We can also compile the blink app and load our
compiled version. The basic C version of blink is located in the
<a href="https://github.com/tock/libtock-c">libtock-c</a> repository.</p>
<ol>
<li>
<p>Clone that repository:</p>
<pre><code class="language-bash">$ cd tock-book
$ git clone https://github.com/tock/libtock-c
</code></pre>
</li>
<li>
<p>Then navigate to <code>examples/blink</code>:</p>
<pre><code class="language-bash">$ cd libtock-c/examples/blink
</code></pre>
</li>
<li>
<p>From there, you should be able to compile it and install it by:</p>
<pre><code class="language-bash">$ make
$ tockloader install
</code></pre>
</li>
</ol>
<p>When the blink app is installed you should see the LEDs on the board
blinking. Congratulations! You have just programmed your first Tock
application.</p>
</li>
</ol>
<h1><a class="header" href="#say-hello-on-every-button-press" id="say-hello-on-every-button-press">Say &quot;Hello!&quot; On Every Button Press</a></h1>
<p>This tutorial will walk you through calling <code>printf()</code> in response to a
button press.</p>
<ol>
<li>
<p><strong>Start a new application</strong>. A Tock application in C looks like a typical C
application. Lets start with the basics:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void) {
  return 0;
}
</code></pre>
<p>You also need a makefile. Copying a makefile from an existing app is
the easiest way to get started.</p>
</li>
<li>
<p><strong>Setup a button callback handler</strong>. A button press in Tock is treated as an
interrupt, and in an application this translates to a function being called,
much like in any other event-driven system. To listen for button presses, we
first need to define a callback function, then tell the kernel that the
callback exists.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
}

int main(void) {
  button_subscribe(button_callback, NULL);

  return 0;
}
</code></pre>
<p>All callbacks from the kernel are passed four arguments, and the meaning of
the four arguments depends on the driver. The first three are integers,
and can be used to represent buffer lengths, pin numbers, button numbers,
and other simple data. The fourth argument is a pointer to user defined
object. This pointer is set in the subscribe call (in this example
it is set to <code>NULL</code>), and returned when the callback fires.</p>
</li>
<li>
<p><strong>Enable the button interrupts</strong>. By default, the interrupts for the buttons
are not enabled. To enable them, we make a syscall. Buttons, like other
drivers in Tock, follow the convention that applications can ask the kernel
how many there are. This is done by calling <code>button_count()</code>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
}

int main(void) {
  button_subscribe(button_callback, NULL);

  // Ensure there is a button to use.
  int count = button_count();
  if (count &lt; 1) {
    // There are no buttons on this platform.
    printf(&quot;Error! No buttons on this platform.&quot;);
  } else {
    // Enable an interrupt on the first button.
    button_enable_interrupt(0);
  }

  // Can just return here. The application will continue to execute.
  return 0;
}
</code></pre>
<p>The button count is checked, and the app only continues if there
exists at least one button. To enable the button interrupt,
<code>button_enable_interrupt()</code> is called with the index of the button
to use. In this example we just use the first button.</p>
</li>
<li>
<p><strong>Call <code>printf()</code> on button press</strong>. To print a message, we call <code>printf()</code>
in the callback.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;button.h&gt;

// Callback for button presses.
//   btn_num: The index of the button associated with the callback
//   val:     1 if pressed, 0 if depressed
static void button_callback(int btn_num,
                            int val,
                            int arg2 __attribute__ ((unused)),
                            void *user_data __attribute__ ((unused)) ) {
  // Only print on the down press.
  if (val == 1) {
    printf(&quot;Hello!\n&quot;);
  }
}

int main(void) {
  button_subscribe(button_callback, NULL);

  // Ensure there is a button to use.
  int count = button_count();
  if (count &lt; 1) {
    // There are no buttons on this platform.
    printf(&quot;Error! No buttons on this platform.\n&quot;);
  } else {
    // Enable an interrupt on the first button.
    button_enable_interrupt(0);
  }

  // Can just return here. The application will continue to execute.
  return 0;
}
</code></pre>
</li>
<li>
<p><strong>Run the application</strong>. To try this tutorial application, you can find it in
the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/02_button_print">tutorials app
folder</a>.
See the first tutorial for details on how to compile and install a C
application.</p>
<p>Once installed, when you press the button, you should see &quot;Hello!&quot; printed
to the terminal!</p>
</li>
</ol>
<h1><a class="header" href="#look-a-wild-ble-packet-appeared" id="look-a-wild-ble-packet-appeared">Look! A Wild BLE Packet Appeared!</a></h1>
<blockquote>
<p>Note! This tutorial will only work on Hail and imix boards.</p>
</blockquote>
<p>This tutorial will walk you through getting an app running that scans
for BLE advertisements. Most BLE devices typically broadcast advertisements
periodically (usually once a second) to allow smartphones and other devices
to discover them. The advertisements typically contain the BLE device's ID
and name, as well as as which services the device provides, and sometimes
raw data as well.</p>
<p>To provide BLE connectivity, several Tock boards use the Nordic nRF51822
as a BLE co-processor. In this configuration, the nRF51822 runs all of
the BLE operations and exposes a command interface over a UART bus. Luckily for
us, Nordic has defined and implemented the entire interface. Better yet, they
made it interoperable with their nRF51 SDK. What this means is any BLE app
that would run on the nRF51822 directly can be compiled to run on a different
microcontroller, and any function calls that would have interacted with
the BLE hardware are instead packaged and sent to the nRF51822 co-processor.
Nordic calls this tool &quot;BLE Serialization&quot;, and Tock has a port of the
serialization libraries that Tock applications can use.</p>
<p>So, with that introduction, lets get going.</p>
<ol>
<li>
<p><strong>Initialize the BLE co-processor</strong>. The first step a BLE serialization app
must do is initialize the BLE stack on the co-processor. This can be done
with Nordic's SDK, but to simplify things Tock supports the <a href="https://github.com/lab11/nrf5x-base/tree/master/lib">Simple
BLE</a> library. The goal
of <code>simple_ble.c</code> is to wrap the details of the nRF5 SDK and the intricacies
of BLE in an easy-to-use library so you can get going with creating BLE
devices and not learning the entire spec.</p>
<pre><code class="language-c">#include &lt;simple_ble.h&gt;

// Intervals for advertising and connections.
// These are some basic settings for BLE devices. However, since we are
// only interesting in scanning, these are not particularly relevant.
simple_ble_config_t ble_config = {
  .platform_id       = 0x00, // used as 4th octet in device BLE address
  .device_id         = DEVICE_ID_DEFAULT,
  .adv_name          = &quot;Tock&quot;,
  .adv_interval      = MSEC_TO_UNITS(500, UNIT_0_625_MS),
  .min_conn_interval = MSEC_TO_UNITS(1000, UNIT_1_25_MS),
  .max_conn_interval = MSEC_TO_UNITS(1250, UNIT_1_25_MS)
};

int main () {
    printf(&quot;[Tutorial] BLE Scanning\n&quot;);

    // Setup BLE.
    simple_ble_init(&amp;ble_config);
}
</code></pre>
</li>
<li>
<p><strong>Scan for advertisements</strong>. With <code>simple_ble</code> this is pretty
straightforward.</p>
<pre><code class="language-c">int main () {
    printf(&quot;[Tutorial] BLE Scanning\n&quot;);

    // Setup BLE.
    simple_ble_init(&amp;ble_config);

    // Scan for advertisements.
    simple_ble_scan_start();
}
</code></pre>
</li>
<li>
<p><strong>Handle the advertisement received event</strong>. Just as the main Tock
microcontroller can send commands to the nRF co-processor, the co-processor
can send events back. When these occur, a variety of callbacks are generated
in <code>simple_ble</code> and then passed to users of the library. In this case, we
only care about <code>ble_evt_adv_report()</code> which is called on each advertisement
reception.</p>
<pre><code class="language-c">// Called when each advertisement is received.
void ble_evt_adv_report (ble_evt_t* p_ble_evt) {
  ble_gap_evt_adv_report_t* adv = (ble_gap_evt_adv_report_t*) &amp;p_ble_evt-&gt;evt.gap_evt.params.adv_report;
}
</code></pre>
<p>The <code>ble_evt_adv_report()</code> function is passed a pointer to a <code>ble_evt_t</code>
struct. This is a type from the Nordic nRF51 SDK, and more information
can be found in the SDK documentation.</p>
</li>
<li>
<p><strong>Display a message for each advertisement</strong>. Once we have the advertisement
callback, we can use <code>printf()</code> like normal.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;led.h&gt;

// Called when each advertisement is received.
void ble_evt_adv_report (ble_evt_t* p_ble_evt) {
  ble_gap_evt_adv_report_t* adv = (ble_gap_evt_adv_report_t*) &amp;p_ble_evt-&gt;evt.gap_evt.params.adv_report;

  // Print some details about the discovered advertisement.
  printf(&quot;Recv Advertisement: [%02x:%02x:%02x:%02x:%02x:%02x] RSSI: %d, Len: %d\n&quot;,
    adv-&gt;peer_addr.addr[5], adv-&gt;peer_addr.addr[4], adv-&gt;peer_addr.addr[3],
    adv-&gt;peer_addr.addr[2], adv-&gt;peer_addr.addr[1], adv-&gt;peer_addr.addr[0],
    adv-&gt;rssi, adv-&gt;dlen);

  // Also toggle the first LED.
  led_toggle(0);
}
</code></pre>
</li>
<li>
<p><strong>Handle some BLE annoyances</strong>. The last step to getting a working app is to
handle some annoyances using BLE serialization with the <code>simple_ble</code> library.
Typically errors generated by the nRF51 SDK are severe and mean there is a
significant bug in the code. With serialization, however, messages between
the two processors can be corrupted or misframed, causing parsing errors. We
can ignore these errors safely and just drop the corrupted packet.</p>
<p>Additionally, the <code>simple_ble</code> library makes it easy to set the address
of a BLE device. However, this functionality only works when running
on an actual nRF51822. To disable this, we override the weakly defined
<code>ble_address_set()</code> function with an empty function.</p>
<pre><code class="language-c">void app_error_fault_handler(uint32_t error_code, uint32_t line_num, uint32_t info) { }
void ble_address_set () { }
</code></pre>
</li>
<li>
<p><strong>Run the app and see the packets!</strong> To try this tutorial application, you
can find it in the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/03_ble_scan">tutorials app
folder</a>.</p>
<p>For any new applications, ensure that the following is in the makefile
so that the BLE serialization library is included.</p>
<pre><code> include $(TOCK_USERLAND_BASE_DIR)/libnrfserialization/Makefile.app
</code></pre>
</li>
</ol>
<h2><a class="header" href="#details" id="details">Details</a></h2>
<p>This section contains a few notes about the specific versions of BLE
serialization used.</p>
<p>Tock currently supports the S130 softdevice version 2.0.0 and SDK 11.0.0.</p>
<h1><a class="header" href="#reading-sensors-from-scratch" id="reading-sensors-from-scratch">Reading Sensors From Scratch</a></h1>
<blockquote>
<p>Note! This tutorial will only work on Hail and imix boards.</p>
</blockquote>
<p>In this tutorial we will cover how to use the syscall interface from
applications to kernel drivers, and guide things based on reading the
<a href="http://www.intersil.com/en/products/optoelectronics/ambient-light-sensors/light-to-digital-sensors/ISL29035.html">ISL29035</a>
digital light sensor and printing the readings over UART.</p>
<p>OK, lets get started.</p>
<ol>
<li>
<p><strong>Setup a generic app for handling asynchronous events</strong>. As with most
sensors, the ISL29035 is read asynchronously, and a callback is generated
from the kernel to userspace when the reading is ready. Therefore, to use
this sensor, our application needs to do two things: 1) setup a callback the
kernel driver can call when the reading is ready, and 2) instruct the kernel
driver to start the measurement. Lets first sketch this out:</p>
<pre><code class="language-c">#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {

}

int main() {
    // Tell the kernel about the callback.

    // Instruct the ISL29035 driver to begin a reading.

    // Wait until the reading is complete.

    // Print the resulting value.

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Fill in the application with syscalls</strong>. The standard <a href="tutorials/../Syscalls.html">Tock
syscalls</a> can be used to actually implement the sketch we
made above. We first use the <code>subscribe</code> syscall to inform the kernel about
the callback in our application. We then use the <code>command</code> syscall to start
the measurement. To wait, we use the <code>yield</code> call to wait for the callback to
actually fire. We do not need to use <code>allow</code> for this application, and
typically it is not required for reading sensors.</p>
<p>For all syscalls that interact with drivers, the major number is set by
the platform. In the case of the ISL29035, it is <code>0x60002</code>. The minor numbers
are set by the driver and are specific to the particular driver.</p>
<p>To save the value from the callback to use in the print statement, we will
store it in a global variable.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

static int isl29035_reading;

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {
    // Save the reading when the callback fires.
    isl29035_reading = intensity;
}

int main() {
    // Tell the kernel about the callback.
    subscribe(DRIVER_NUM, 0, isl29035_callback, NULL);

    // Instruct the ISL29035 driver to begin a reading.
    command(DRIVER_NUM, 1, 0);

    // Wait until the reading is complete.
    yield();

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Be smarter about waiting for the callback</strong>. While the above application
works, it's really relying on the fact that we are only sampling a single
sensor. In the current setup, if instead we had two sensors with outstanding
commands, the first callback that fired would trigger the <code>yield()</code> call to
return and then the <code>printf()</code> would execute. If, for example, sampling the
ISL29035 takes 100 ms, and the new sensor only needs 10 ms, the new sensor's
callback would fire first and the <code>printf()</code> would execute with an incorrect
value.</p>
<p>To handle this, we can instead use the <code>yield_for()</code> call, which takes
a flag and only returns when that flag has been set. We can then set this
flag in the callback to make sure that our <code>printf()</code> only occurs when
the light reading has completed.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#include &lt;tock.h&gt;

#define DRIVER_NUM 0x60002

static int isl29035_reading;
static bool isl29035_done = false;

// Callback when the ISL29035 has a light intensity measurement ready.
static void isl29035_callback(int intensity, int unused1, int unused2, void* ud) {
    // Save the reading when the callback fires.
    isl29035_reading = intensity;

    // Mark our flag true so that the `yield_for()` returns.
    isl29035_done = true;
}

int main() {
    // Tell the kernel about the callback.
    subscribe(DRIVER_NUM, 0, isl29035_callback, NULL);

    // Instruct the ISL29035 driver to begin a reading.
    command(DRIVER_NUM, 1, 0);

    // Wait until the reading is complete.
    yield_for(&amp;isl29035_done);

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Use the <code>libtock</code> library functions</strong>. Normally, applications don't use the
bare <code>command</code> and <code>subscribe</code> syscalls. Typically, these are wrapped
together into helpful commands inside of <code>libtock</code> and come with a function
that hides the <code>yield_for()</code> to a make a synchronous function which is useful
for developing applications quickly. Lets port the ISL29035 sensing app to
use the Tock Standard Library:</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

#include &lt;isl29035.h&gt;

int main() {
    // Take the ISL29035 measurement synchronously.
    int isl29035_reading = isl29035_read_light_intensity();

    // Print the resulting value.
    printf(&quot;Light intensity reading: %d\n&quot;, isl29035_reading);

    return 0;
}
</code></pre>
</li>
<li>
<p><strong>Explore more sensors</strong>. This tutorial highlights only one sensor. See the
<a href="https://github.com/tock/libtock-c/tree/master/examples/sensors">sensors</a> app
for a more complete sensing application.</p>
</li>
</ol>
<h1><a class="header" href="#friendly-apps-share-data" id="friendly-apps-share-data">Friendly Apps Share Data</a></h1>
<p>This tutorial covers how to use Tock's IPC mechanism to allow applications
to communicate and share memory.</p>
<h2><a class="header" href="#tock-ipc-basics" id="tock-ipc-basics">Tock IPC Basics</a></h2>
<p>IPC in Tock uses a client-server model. Applications can provide a service by
telling the Tock kernel that they provide a service. Each application can only
provide a single service, and that service's name is set to the name of the
application. Other applications can then discover that service and explicitly
share a buffer with the server. Once a client shares a buffer, it can then
notify the server to instruct the server to somehow interact with the shared
buffer. The protocol for what the server should do with the buffer is service
specific and not specified by Tock. Servers can also notify clients, but when
and why servers notify clients is service specific.</p>
<h2><a class="header" href="#example-application" id="example-application">Example Application</a></h2>
<p>To provide an overview of IPC, we will build an example system consisting of
three apps: a random number service, a LED control service, and a main
application that uses the two services. While simple, this example both
demonstrates the core aspects of the IPC mechanism and should run on any
hardware platform.</p>
<h3><a class="header" href="#led-service" id="led-service">LED Service</a></h3>
<p>Lets start with the LED service. The goal of this service is to allow other
applications to use the shared buffer as a command message to instruct the
LED service on how to turn on or off the system's LEDs.</p>
<ol>
<li>
<p>We must tell the kernel that our app wishes to provide a service. All that we
have to do is call <code>ipc_register_svc()</code>.</p>
<pre><code class="language-c">#include &quot;ipc.h&quot;

int main(void) {
  ipc_register_svc(ipc_callback, NULL);
  return 0;
}
</code></pre>
</li>
<li>
<p>We also need that callback (<code>ipc_callback</code>) to handle IPC requests from other
applications. This callback will be called when the client app notifies the
service.</p>
<pre><code class="language-c">static void ipc_callback(int pid, int len, int buf, void* ud) {
  // pid: An identifier for the app that notified us.
  // len: How long the buffer is that the client shared with us.
  // buf: Pointer to the shared buffer.
}
</code></pre>
</li>
<li>
<p>Now lets fill in the callback for the LED application. This is a simplified
version for illustration. The full example can be found in the
<code>examples/tutorials</code> folder.</p>
<pre><code class="language-c">#include &quot;led.h&quot;

static void ipc_callback(int pid, int len, int buf, void* ud) {
  uint8_t* buffer = (uint8_t*) buf;

  // First byte is the command, second byte is the LED index to set,
  // and the third byte is whether the LED should be on or off.
  uint8_t command = buffer[0];
  if (command == 1) {
      uint8_t led_id = buffer[1];
      uint8_t led_state = buffer[2] &gt; 0;

      if (led_state == 0) {
        led_off(led_id);
      } else {
        led_on(led_id);
      }

      // Tell the client that we have finished setting the specified LED.
      ipc_notify_client(pid);
      break;
  }
}
</code></pre>
</li>
</ol>
<h3><a class="header" href="#rng-service" id="rng-service">RNG Service</a></h3>
<p>The RNG service returns the requested number of random bytes in the shared
folder.</p>
<ol>
<li>
<p>Again, register that this service exists.</p>
<pre><code class="language-c">int main(void) {
  ipc_register_svc(ipc_callback, NULL);
  return 0;
}
</code></pre>
</li>
<li>
<p>Also need a callback function for when the client signals the service. The
client specifies how many random bytes it wants by setting the first byte of
the shared buffer before calling notify.</p>
<pre><code class="language-c">#include &lt;rng.h&gt;

static void ipc_callback(int pid, int len, int buf, void* ud) {
  uint8_t* buffer = (uint8_t*) buf;
  uint8_t rng[len];

  uint8_t number_of_bytes = buffer[0];

  // Fill the buffer with random bytes.
  int number_of_bytes_received = rng_sync(rng, len, number_of_bytes);
  memcpy(buffer, rng, number_of_bytes_received);

  // Signal the client that we have the number of random bytes requested.
  ipc_notify_client(pid);
}
</code></pre>
<p>This is again not a complete example but illustrates the key aspects.</p>
</li>
</ol>
<h3><a class="header" href="#main-logic-client-application" id="main-logic-client-application">Main Logic Client Application</a></h3>
<p>The third application uses the two services to randomly control the LEDs on
the board. This application is not a server but instead is a client of the
two service applications.</p>
<ol>
<li>
<p>When using an IPC service, the first step is to discover the service and
record its identifier. This will allow the application to share memory with
it and notify it. Services are discovered by the name of the application that
provides them. Currently these are set in the application Makefile or by
default based on the folder name of the application. The examples in Tock
commonly use a Java style naming format.</p>
<pre><code class="language-c">int main(void) {
  int led_service = ipc_discover(&quot;org.tockos.tutorials.ipc.led&quot;);
  int rng_service = ipc_discover(&quot;org.tockos.tutorials.ipc.rng&quot;);

  return 0;
}
</code></pre>
<p>If the services requested are valid and exist the return value from
<code> ipc_discover</code> is the identifier of the found service. If the service
cannot be found an error is returned.</p>
</li>
<li>
<p>Next we must share a buffer with each service (the buffer is the only way to
share between processes), and setup a callback that is called when the server
notifies us as a client. Once shared, the kernel will permit both
applications to read/modify that memory.</p>
<pre><code class="language-c">char led_buf[64] __attribute__((aligned(64)));
char rng_buf[64] __attribute__((aligned(64)));

int main(void) {
  int led_service = ipc_discover(&quot;org.tockos.tutorials.ipc.led&quot;);
  int rng_service = ipc_discover(&quot;org.tockos.tutorials.ipc.rng&quot;);

  // Setup IPC for LED service
  ipc_register_client_cb(led_service, ipc_callback, NULL);
  ipc_share(led_service, led_buf, 64);

  // Setup IPC for RNG service
  ipc_register_client_cb(rng_service, ipc_callback, NULL);
  ipc_share(rng_service, rng_buf, 64);

  return 0;
}
</code></pre>
</li>
<li>
<p>We of course need the callback too. For this app we use the <code>yield_for</code>
function to implement the logical synchronously, so all the callback needs to
do is set a flag to signal the end of the <code>yield_for</code>.</p>
<pre><code class="language-c">bool done = false;

static void ipc_callback(int pid, int len, int arg2, void* ud) {
  done = true;
}
</code></pre>
</li>
<li>
<p>Now we use the two services to implement our application.</p>
<pre><code class="language-c">#include &lt;timer.h&gt;

void app() {
  while (1) {
    // Get two random bytes from the RNG service
    done = false;
    rng_buf[0] = 2; // Request two bytes.
    ipc_notify_svc(rng_service);
    yield_for(&amp;done);

    // Control the LEDs based on those two bytes.
    done = false;
    led_buf[0] = 1;                     // Control LED command.
    led_buf[1] = rng_buf[0] % NUM_LEDS; // Choose the LED index.
    led_buf[2] = rng_buf[1] &amp; 0x01;     // On or off.
    ipc_notify_svc(led_service);        // Notify to signal LED service.
    yield_for(&amp;done);

    delay_ms(500);
  }
}
</code></pre>
</li>
</ol>
<h2><a class="header" href="#try-it-out" id="try-it-out">Try It Out</a></h2>
<p>To test this out, see the complete apps in the <a href="https://github.com/tock/libtock-c/tree/master/examples/tutorials/05_ipc">IPC tutorial
example</a>
folder.</p>
<p>To install all of the apps on a board:</p>
<pre><code>$ cd examples/tutorials/05_ipc
$ tockloader erase-apps
$ pushd led &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
$ pushd rng &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
$ pushd logic &amp;&amp; make &amp;&amp; tockloader install &amp;&amp; popd
</code></pre>
<p>You should see the LEDs randomly turning on and off!</p>
<h1><a class="header" href="#kernel-development-guides" id="kernel-development-guides">Kernel Development Guides</a></h1>
<p>These guides provide walkthroughs for specific kernel development tasks. For
example, there is a guide on how to add a new syscall interface for userspace
applications. The guides are intended to be general and provide high-level
instructions which will have to be adapted for the specific functionality to be
added.</p>
<p>Overtime, these guides will inevitably become out-of-date in that the specific
code examples will fail to compile. However, the general design aspects and
considerations should still be relevant even if the specific code details have
changed. You are encourage to use these guides as just that, a general guide,
and to copy from up-to-date examples contained in the Tock repository.</p>
<h1><a class="header" href="#implementing-a-chip-peripheral-driver" id="implementing-a-chip-peripheral-driver">Implementing a Chip Peripheral Driver</a></h1>
<p>This guide covers how to implement a peripheral driver for a particular
microcontroller (MCU). For example, if you wanted to add an analog to digital
converter (ADC) driver for the Nordic nRF52840 MCU, you would follow the general
steps described in this guide.</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The general steps you will follow are:</p>
<ol>
<li>Determine the HIL you will implement.</li>
<li>Create a register mapping for the peripheral.</li>
<li>Create a struct for the peripheral.</li>
<li>Implement the HIL interface for the peripheral.</li>
<li>Create the peripheral driver object and cast the registers to the correct
memory location.</li>
</ol>
<p>The guide will walk through how to do each of these steps.</p>
<h2><a class="header" href="#background" id="background">Background</a></h2>
<p>Implementing a chip peripheral driver increases Tock's support for a particular
microcontroller and allows capsules and userspace apps to take more advantage of
the hardware provided by the MCU. Peripheral drivers for an MCU are generally
implemented on an as-needed basis to support a particular use case, and as such
the chips in Tock generally do not have all of the peripheral drivers
implemented already.</p>
<p>Peripheral drivers are included in Tock as &quot;trusted code&quot; in the kernel. This
means that they can use the <code>unsafe</code> keyword (in fact, they must). However, it
also means more care must be taken to ensure they are correct. The use of
<code>unsafe</code> should be kept to an absolute minimum and only used where absolutely
necessary. This guide explains the one use of <code>unsafe</code> that is required. All
other uses of <code>unsafe</code> in a peripheral driver will likely be very scrutinized
during the pull request review period.</p>
<h2><a class="header" href="#step-by-step-guide" id="step-by-step-guide">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Determine the HIL you will implement.</strong></p>
<p>The HILs in Tock are the contract between the MCU-specific hardware and the
more generic capsules which use the hardware resources. They provide a
common interface that is consistent between different microcontrollers,
enabling code higher in the stack to use the interfaces without needing to
know any details about the underlying hardware. This common interface also
allows the same higher-level code to be portable across different
microcontrollers. HILs are implemented as
<a href="https://doc.rust-lang.org/1.8.0/book/traits.html">traits</a> in Rust.</p>
<p>All HILs are defined in the <code>kernel/src/hil</code> directory. You should find a
HIL that exposes the interface the peripheral you are writing a driver for
can provide. There should only be one HIL that matches your peripheral.</p>
<blockquote>
<p>Note: As of Dec 2019, the <code>hil</code> directory also contains interfaces that
are only provided by capsules for other capsules. For example, the ambient
light HIL interface is likely not something an MCU would implement.</p>
</blockquote>
<p>It is possible Tock does not currently include a HIL that matches the
peripheral you are implementing a driver for. In that case you will also
need to create a HIL, which is explained in a different development guide.</p>
<p><strong>Checkpoint</strong>: You have identified the HIL your driver will implement.</p>
</li>
<li>
<p><strong>Create a register mapping for the peripheral.</strong></p>
<p>To start implementing the peripheral driver, you must create a new source
file within the MCU-specific directory inside of <code>chips/src</code> directory. The
name of this file generally should match the name of the peripheral in the
the MCU's datasheet.</p>
<p>Include the name of this file inside of the <code>lib.rs</code> (or potentially
<code>mod.rs</code>) file inside the same directory. This should look like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod ast;
#}</code></pre></pre>
<p>Inside of the new file, you will first need to define the memory-mapped
input/output (MMIO) registers that correspond to the peripheral. Different
embedded code ecosystems have devised different methods for doing this, and
Tock is no different. Tock has a special library and set of Rust macros to
make defining the register map straightforward and using the registers
intuitive.</p>
<p>The full register library is
<a href="https://github.com/tock/tock/tree/master/libraries/tock-register-interface">here</a>,
but to get started, you will first create a structure like this:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use tock_registers::registers::{ReadOnly, ReadWrite, WriteOnly};

register_structs! {
    XyzPeripheralRegisters {
        /// Control register.
        /// The 'Control' parameter constrains this register to only use
        /// fields from a certain group (defined below in the bitfields
        /// section).
        (0x000 =&gt; cr: ReadWrite&lt;u32, Control::Register&gt;),
        // Status register.
        (0x004 =&gt; s: ReadOnly&lt;u8, Status::Register&gt;),
        /// spacing between registers in memory
        (0x008 =&gt; _reserved),
        /// Another register with no meaningful fields.
        (0x014 =&gt; word: ReadWrite&lt;u32&gt;),

        // Etc.

        // The end of the struct is marked as follows.
        (0x100 =&gt; @END),
    }
}
#}</code></pre></pre>
<p>You should replace <code>XyzPeripheral</code> with the name of the peripheral you are
writing a driver for. Then, for each register defined in the datasheet, you
must specify an entry in the macro. For example, a register is defined like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
(0x000 =&gt; cr: ReadWrite&lt;u32, Control::Register&gt;),
#}</code></pre></pre>
<p>where:</p>
<ul>
<li><code>0x000</code> is the offset (in bytes) of the register from the beginning of the
register map.</li>
<li><code>cr</code> is the name of the register in the datasheet.</li>
<li><code>ReadWrite</code> is the access control of the register as defined in the
datasheet.</li>
<li><code>u32</code> is the size of the register.</li>
<li><code>Control::Register</code> maps to the actual bitfields used in the register. You
will create this type for this particular peripheral, so you can name this
whatever makes sense at this point. Note that it will always end with
<code>::Register</code> due to how Rust macros work. If it doesn't make sense to
define the specific bitfields in this register, you can omit this field.
For example, an esoteric field in the register map that the implementation
does not use likely does not need its bitfields mapped.</li>
</ul>
<p>Once the register map is defined, you must specify the bitfields for any
registers that you gave a specific type to. This looks like the following:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
register_bitfields! [
    // First parameter is the register width for the bitfields. Can be u8,
    // u16, u32, or u64.
    u32,

    // Each subsequent parameter is a register abbreviation, its descriptive
    // name, and its associated bitfields. The descriptive name defines this
    // 'group' of bitfields. Only registers defined as
    // ReadWrite&lt;_, Control::Register&gt; can use these bitfields.
    Control [
        // Bitfields are defined as:
        // name OFFSET(shift) NUMBITS(num) [ /* optional values */ ]

        // This is a two-bit field which includes bits 4 and 5
        RANGE OFFSET(4) NUMBITS(3) [
            // Each of these defines a name for a value that the bitfield
            // can be written with or matched against. Note that this set is
            // not exclusive--the field can still be written with arbitrary
            // constants.
            VeryHigh = 0,
            High = 1,
            Low = 2
        ],

        // A common case is single-bit bitfields, which usually just mean
        // 'enable' or 'disable' something.
        EN  OFFSET(3) NUMBITS(1) [],
        INT OFFSET(2) NUMBITS(1) []
    ],

    // Another example:
    // Status register
    Status [
        TXCOMPLETE  OFFSET(0) NUMBITS(1) [],
        TXINTERRUPT OFFSET(1) NUMBITS(1) [],
        RXCOMPLETE  OFFSET(2) NUMBITS(1) [],
        RXINTERRUPT OFFSET(3) NUMBITS(1) [],
        MODE        OFFSET(4) NUMBITS(3) [
            FullDuplex = 0,
            HalfDuplex = 1,
            Loopback = 2,
            Disabled = 3
        ],
        ERRORCOUNT OFFSET(6) NUMBITS(3) []
    ],
]
#}</code></pre></pre>
<p>The name in each entry of the <code>register_bitfields! []</code> list must match the
register type provided in the register map declaration. Each register that
is used in the driver implementation should have its bitfields declared.</p>
<p><strong>Checkpoint</strong>: The register map is correctly described in the driver source
file.</p>
</li>
<li>
<p><strong>Create a struct for the peripheral.</strong></p>
<p>Each peripheral driver is implemented with a struct which is later used to
create an object that can be passed to code that will use this peripheral
driver. The actual fields of the struct are very peripheral specific, but
should contain any state that the driver needs to correctly function.</p>
<p>An example struct looks for a timer peripheral called the AST by the MCU
datasheet looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Ast&lt;'a&gt; {
    registers: StaticRef&lt;AstRegisters&gt;,
    callback: OptionalCell&lt;&amp;'a dyn hil::time::AlarmClient&gt;,
}
#}</code></pre></pre>
<p>The struct should contain a reference to the registers defined above (we
will explain the <code>StaticRef</code> later). Typically, many drivers respond to
certain events (like in this case a timer firing) and therefore need a
reference to a client to notify when that event occurs. Notice that the type
of the callback handler is specified in the HIL interface.</p>
<p>Peripheral structs typically need a lifetime for references like the
callback client reference. By convention Tock peripheral structs use <code>'a</code>
for this lifetime, and you likely want to copy that as well.</p>
<p>Think of what state your driver might need to keep around. This could
include a direct memory access (DMA) reference, some configuration flags
like the baud rate, or buffer indices. See other Tock peripheral drivers for
more examples.</p>
<blockquote>
<p>Note: you will most likely need to update this struct as you implement the
driver, so to start with this just has to be a best guess.</p>
</blockquote>
<blockquote>
<p>Hint: you should avoid keeping any state in the peripheral driver struct
that is already stored by the hardware itself. For example, if there is an
&quot;enabled&quot; bit in a register, then you do not need an &quot;enabled&quot; flag in the
struct. Replicating this state leads to bugs when those values get out of
sync, and makes it difficult to update the driver in the future.</p>
</blockquote>
<p>Peripheral driver structs make extensive use of different &quot;cell&quot; types to
hold references to various shared state. The general wisdom is that if the
value will ever need to be updated, then it needs to be contained in a cell.
See the Tock cell documentation for more details on the cell types and when
to use which one. In this example, the callback is stored in an
<code>OptionalCell</code>, which can contain a value or not (if the callback is not
set), and can be updated if the callback needs to change.</p>
<p>With the struct defined, you should next create a <code>new()</code> function for that
struct. This will look like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ast {
    const fn new(registers: StaticRef&lt;AstRegisters&gt;) -&gt; Ast {
        Ast {
            registers: registers,
            callback: OptionalCell::empty(),
        }
    }
}
#}</code></pre></pre>
<p><strong>Checkpoint</strong>: There is a struct for the peripheral that can be created.</p>
</li>
<li>
<p><strong>Implement the HIL interface for the peripheral.</strong></p>
<p>With the peripheral driver struct created, now the main work begins. You can
now write the actual logic for the peripheral driver that implements the HIL
interface you identified earlier. Implementing the HIL interface is done
just like implementing a trait in Rust. For example, to implement the <code>Time</code>
HIL for the AST:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl hil::time::Time for Ast&lt;'a&gt; {
    type Frequency = Freq16KHz;

    fn now(&amp;self) -&gt; u32 {
        self.get_counter()
    }

    fn max_tics(&amp;self) -&gt; u32 {
        core::u32::MAX
    }
}
#}</code></pre></pre>
<p>You should include all of the functions from the HIL and decide how to
implement them.</p>
<p>Some operations will be shared among multiple HIL functions. These should be
implemented as functions for the original struct. For example, in the <code>Ast</code>
example the HIL function <code>now()</code> uses the <code>get_counter()</code> function. This should be
implemented on the main <code>Ast</code> struct:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ast {
    const fn new(registers: StaticRef&lt;AstRegisters&gt;) -&gt; Ast {
        Ast {
            registers: registers,
            callback: OptionalCell::empty(),
        }
    }

    fn get_counter(&amp;self) -&gt; u32 {
        let regs = &amp;*self.registers;
        while self.busy() {}
        regs.cv.read(Value::VALUE)
    }
}
#}</code></pre></pre>
<p>Note the <code>get_counter()</code> function also illustrates how to use the register
reference and the Tock register library. The <a href="https://github.com/tock/tock/tree/master/libraries/tock-register-interface">register
library</a>
includes much more detail on the various register operations enabled by the
library.</p>
<p><strong>Checkpoint</strong>: All of the functions in the HIL interface have MCU
peripheral-specific implementations.</p>
</li>
<li>
<p><strong>Create the peripheral driver object and cast the registers to the correct
memory location.</strong></p>
<p>The last step is to actually create the object so that the peripheral driver
can be used by other code. Start by casting the register map to the correct
memory address where the registers are actually mapped to. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use kernel::common::StaticRef;

const AST_BASE: StaticRef&lt;AstRegisters&gt; =
    unsafe { StaticRef::new(0x400F0800 as *const AstRegisters) };
#}</code></pre></pre>
<p><code>StaticRef</code> is a type in Tock designed explicitly for this operation of
casting register maps to the correct location in memory. The <code>0x400F0800</code> is
the address in memory of the start of the registers and this location will
be specified by the datasheet.</p>
<blockquote>
<p>Note that creating the <code>StaticRef</code> requires using the <code>unsafe</code> keyword.
This is because doing this cast is a fundamentally memory-unsafe
operation: this allows whatever is at that address in memory to be
accessed through the register interface (which is exposed as a safe
interface). In the normal case where the correct memory address is
provided there is no concern for system safety as the register interface
faithfully represents the underlying hardware. However, suppose an
incorrect address was used, and that address actually points to live
memory used by the Tock kernel. Now kernel data structures could be
altered through the register interface, and this would violate memory
safety.</p>
</blockquote>
<p>With the address reference created, we can now create the actual driver
object:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub static mut AST: Ast = Ast::new(AST_BASE);
#}</code></pre></pre>
<p>This object will be used by a board's main.rs file to pass, in this case,
the driver for the timer hardware to various capsules and other code that
needs the underlying timer hardware.</p>
</li>
</ol>
<h2><a class="header" href="#wrap-up" id="wrap-up">Wrap-Up</a></h2>
<p>Congratulations! You have implemented a peripheral driver for a microcontroller
in Tock! We encourage you to submit a pull request to upstream this to the Tock
repository.</p>
<h1><a class="header" href="#implementing-a-sensor-driver" id="implementing-a-sensor-driver">Implementing a Sensor Driver</a></h1>
<p>This guide describes the steps necessary to implement a capsule in Tock that
interfaces with an external IC, like a sensor, memory chip, or display. These
are devices which are not part of the same chip as the main microcontroller
(MCU), but are on the same board and connected via some physical connection.</p>
<blockquote>
<p>Note: to attempt to be generic, this guide will use the term &quot;IC&quot; to refer to
the device the driver is for.</p>
</blockquote>
<blockquote>
<p>Note: &quot;driver&quot; is a bit of an overloaded term in Tock. In this guide, &quot;driver&quot;
is used in the generic sense to mean code that interfaces with the external
IC.</p>
</blockquote>
<p>To illustrate the steps, this guide will use a generic light sensor as the
running example. You will need to adapt the generic steps for your particular
use case.</p>
<p>Often the goal of an IC driver is to expose an interface to that sensor or other
IC to userspace applications. This guide does not cover creating that userspace
interface as that is covered in a different guide.</p>
<h2><a class="header" href="#background-1" id="background-1">Background</a></h2>
<p>As mentioned, this guide describes creating a capsule. Capsules in Tock are
units of Rust code that extend the kernel to add interesting features, like
interfacing with new sensors. Capsules are &quot;untrusted&quot;, meaning they cannot call
unsafe code in Rust and cannot use the <code>unsafe</code> keyword.</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Create a struct for the IC driver.</li>
<li>Implement the logic to interface with the IC.</li>
</ol>
<p>Optional:</p>
<ol>
<li>Provide a HIL interface for the IC driver.</li>
<li>Provide a userspace interface for the IC driver.</li>
</ol>
<h2><a class="header" href="#step-by-step-guide-1" id="step-by-step-guide-1">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Create a struct for the IC driver.</strong></p>
<p>The driver will be implemented as a capsule, so the first step is to create
a new file in the <code>capsules/src</code> directory. The name of this file should be
<code>[chipname].rs</code> where <code>[chipname]</code> is the part number of the IC you are
writing the driver for. There are several other examples in the capsules
folder.</p>
<p>For our example we will assume the part number is <code>ls1234</code>.</p>
<p>You then need to add the filename to <code>capsules/src/lib.rs</code> like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub mod ls1234;
#}</code></pre></pre>
<p>Now inside of the new file you should create a struct with the fields
necessary to implement the driver for the IC. In our example we will assume
the IC is connected to the MCU with an I2C bus. Your IC might use SPI, UART,
or some other standard interface. You will need to adjust how you create the
struct based on the interface. You should be able to find examples in the
capsules directory to copy from.</p>
<p>The struct will look something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Ls1234 {
    i2c: &amp;'a dyn I2CDevice,
    state: Cell&lt;State&gt;,
    buffer: TakeCell&lt;'static, [u8]&gt;,
    client: OptionalCell&lt;&amp;'a dyn Ls1234Client&gt;,
}
#}</code></pre></pre>
<p>You can see the resources this driver requires to successfully interface
with the light sensor:</p>
<ul>
<li>
<p><code>i2c</code>: This is a reference to the I2C bus that the driver will use to
communicate with the IC. Notice in Tock the type is <code>I2CDevice</code>, and no
address is provided. This is because the <code>I2CDevice</code> type wraps the
address in internally, so that the driver code can <em>only</em> communicate with
the correct address.</p>
</li>
<li>
<p><code>alarm</code>:</p>
</li>
<li>
<p><code>state</code>: Often drivers will iterate through various states as they
communicate with the IC, and it is common for drivers to keep some state
variable to manage this. Our <code>State</code> is defined as an enum, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[derive(Copy, Clone, PartialEq)]
enum State {
    Disabled,
    Enabling,
    ReadingLight,
}
#}</code></pre></pre>
<p>Also note that the <code>state</code> variable uses a <code>Cell</code>. This is so that the
driver can update the state.</p>
</li>
<li>
<p><code>buffer</code>: This holds a reference to a buffer of memory the driver will use
to send messages over the I2C bus. By convention, these buffers are
defined statically in the same file as the driver, but then passed to the
driver when the board boots. This provides the board flexibility on the
buffer to use, while still allowing the driver to hint at the size
required for successful operation. In our case the static buffer is
defined as:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub static mut BUF: [u8; 3] = [0; 3];
#}</code></pre></pre>
<p>Note the buffer is wrapped in a <code>TakeCell</code> such that it can be passed
to the I2C hardware when necessary, and re-stored in the driver struct
when the I2C code returns the buffer.</p>
</li>
<li>
<p><code>client</code>: This is the callback that will be called after the driver has
received a reading from the sensor. All execution is event-based in Tock,
so the caller will not block waiting for a sample, but instead will expect
a callback via the client when the same is ready. The driver has to define
the type of the callback by defining the <code>Ls1234Client</code> trait in this
case:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub trait Ls1234Client {
	 fn callback(light_reading: usize);
}
#}</code></pre></pre>
<p>Note that the client is stored in an <code>OptionalCell</code>. This allows the
callback to not be set initially, and configured at bootup.</p>
</li>
</ul>
<p>Your driver may require other state to be stored as well. You can update
this struct as needed to for state required to successfully implement the
driver. Note that if the state needs to be updated at runtime it will need
to be stored in a cell type. See the cell documentation for more information
on the various cell types in Tock.</p>
<blockquote>
<p>Note: your driver should not keep any state in the struct that is also
stored by the hardware. This easily leads to bugs when that state becomes
out of sync, and makes further development on the driver difficult.</p>
</blockquote>
<p>The last step is to write a function that enables creating an instance of
your driver. By convention, the function is called <code>new()</code> and looks
something like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ls1234&lt;'a&gt; {
    pub fn new(i2c: &amp;'a dyn I2CDevice, buffer: &amp;'static mut [u8]) -&gt; Ls1234&lt;'a&gt; {
        Ls1234 {
            i2c: i2c,
            alarm: alarm,
            state: Cell::new(State::Disabled),
            client: OptionalCell::empty(),
        }
    }
}
#}</code></pre></pre>
<p>This function will get called by the board's <code>main.rs</code> file when the driver
is instantiated. All of the static objects or configuration that the driver
requires must be passed in here. In this example, a reference to the I2C
device and the static buffer for passing messages must be provided.</p>
<p><strong>Checkpoint</strong>: You have defined the struct which will become the driver for
the IC.</p>
</li>
<li>
<p><strong>Implement the logic to interface with the IC.</strong></p>
<p>Now, you will actually write the code that interfaces with the IC. This
requires extending the <code>impl</code> of the driver struct with additional functions
appropriate for your particular IC.</p>
<p>With our light sensor example, we likely want to write a sample function for
reading a light sensor value:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ls1234&lt;'a&gt; {
    pub fn new(...) -&gt; Ls1234&lt;'a&gt; {...}

    pub fn start_light_reading(&amp;self) {...}
}
#}</code></pre></pre>
<p>Note that the function name is &quot;start light reading&quot;, which is appropriate
because of the event-driven, non-blocking nature of the Tock kernel.
Actually communicating with the sensor will take some time, and likely
requires multiple messages to be sent to and received from the sensor.
Therefore, our sample function will not be able to return the result
directly. Instead, the reading will be provided in the callback function
described earlier.</p>
<p>The start reading function will likely prepare the message buffer in a way
that is IC-specific, then send the command to the IC. A rough example of
that operation looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Ls1234&lt;'a&gt; {
    pub fn new(...) -&gt; Ls1234&lt;'a&gt; {...}

    pub fn start_light_reading(&amp;self) {
        if self.state.get() == State::Disabled {
            self.buffer.take().map(|buf| {
                self.i2c.enable();

                // Set the first byte of the buffer to the &quot;on&quot; command.
                // This is IC-specific and will be described in the IC
                // datasheet.
                buf[0] = 0b10100000;

                // Send the command to the chip and update our state
                // variable.
                self.i2c.write(buf, 1);
                self.state.set(State::Enabling);
            });
        }
    }
}
#}</code></pre></pre>
<p>The <code>start_light_reading()</code> function kicks off reading the light value from
the IC and updates our internal state machine state to mark that we are
waiting for the IC to turn on. Now the <code>Ls1234</code> code is finished for the
time being and we now wait for the I2C message to finish being sent. We will
know when this has completed based on a callback from the I2C hardware.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], error: Error) {
        // Handle what happens with the I2C send is complete here.
    }
}
#}</code></pre></pre>
<p>In our example, we have to send a new command after turning on the light
sensor to actually read a sampled value. We use our state machine here to
organize the code as in this example:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: Error) {
        match self.state.get() {
            State::Enabling =&gt; {
                // Put the read command in the buffer and send it back to
                // the sensor.
                buffer[0] = 0b10100001;
                self.i2c.write_read(buf, 1, 2);
                // Update our state machine state.
                self.state.set(State::ReadingLight);
            }
            _ =&gt; {}
        }
    }
}
#}</code></pre></pre>
<p>This will send another command to the sensor to read the actual light
measurement. We also update our <code>self.state</code> variable because when this I2C
transaction finishes the exact same <code>command_complete</code> callback will be
called, and we must be able to remember where we are in the process of
communicating with the sensor.</p>
<p>When the read finishes, the <code>command_complete()</code> callback will fire again,
and we must handle the result. Since we now have the reading we can call our
client's callback after updating out state machine.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl I2CClient for Ls1234&lt;'a&gt; {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: Error) {
        match self.state.get() {
            State::Enabling =&gt; {
                // Put the read command in the buffer and send it back to
                // the sensor.
                buffer[0] = 0b10100001;
                self.i2c.write_read(buf, 1, 2);
                // Update our state machine state.
                self.state.set(State::ReadingLight);
            }
            State::ReadingLight =&gt; {
                // Extract the light reading value.
                let mut reading: u16 = buffer[0] as 16;
                reading |= (buffer[1] as u16) &lt;&lt; 8;

                // Update our state machine state.
                self.state.set(State::Disabled);

                // Trigger our callback with the result.
                self.client.map(|client| client.callback(reading));
            }
            _ =&gt; {}
        }
    }
}
#}</code></pre></pre>
<blockquote>
<p>Note: likely the sensor would need to be disabled and returned to a low
power state.</p>
</blockquote>
<p>At this point your driver can read the IC and return the information from
the IC. For your IC you will likely need to expand on this general template.
You can add additional functions to the main struct implementation, and then
expand the state machine to implement those functions. You may also need
additional resources, like GPIO pins or timer alarms to implement the state
machine for the IC. There are examples in the <code>capsules/src</code> folder with
drivers that need different resources.</p>
</li>
</ol>
<h2><a class="header" href="#optional-steps" id="optional-steps">Optional Steps</a></h2>
<ol>
<li>
<p><strong>Provide a HIL interface for the IC driver.</strong></p>
<p>The driver so far has a very IC-specific interface. That is, any code that
uses the driver must be written specifically with that IC in mind. In some
cases that may be reasonable, for example if the IC is very unusual or has a
very unique set of features. However, many ICs provide similar
functionality, and higher-level code can be written without knowing what
specific IC is being used on a particular hardware platform.</p>
<p>To enable this, some IC types have HILs in the <code>kernel/src/hil</code> folder in
the <code>sensors.rs</code> file. Drivers can implement one of these HILs and then
higher-level code can use the HIL interface rather than a specific IC.</p>
<p>To implement the HIL, you must implement the HIL trait functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl AmbientLight for Ls1234&lt;'a&gt; {
    fn set_client(&amp;self, client: &amp;'static dyn AmbientLightClient) {

    }

    fn read_light_intensity(&amp;self) -&gt; ReturnCode {

    }
}
#}</code></pre></pre>
<p>The user of the <code>AmbientLight</code> HIL will implement the <code>AmbientLightClient</code>
and provide the client through the <code>set_client()</code> function.</p>
</li>
<li>
<p><strong>Provide a userspace interface for the IC driver.</strong></p>
<p>Sometimes the IC is needed by userspace, and therefore needs a syscall
interface so that userspace applications can use the IC. Please refer to a
separate guide on how to implement a userspace interface for a capsule.</p>
</li>
</ol>
<h2><a class="header" href="#wrap-up-1" id="wrap-up-1">Wrap-Up</a></h2>
<p>Congratulations! You have implemented an IC driver as a capsule in Tock! We
encourage you to submit a pull request to upstream this to the Tock repository.
Tock is happy to accept capsule drivers even if no boards in the Tock repository
currently use the driver.</p>
<h1><a class="header" href="#implementing-a-syscall-interface-for-userspace" id="implementing-a-syscall-interface-for-userspace">Implementing a Syscall Interface for Userspace</a></h1>
<p>This guide provides an overview and walkthrough on how to add a syscall
interface for userspace applications in Tock. This syscall interface exposes
some kernel functionality to applications. For example, this could be the
ability to sample a new sensor, or use some service like doing AES encryption.</p>
<p>In this guide we will use a running example of providing a userspace interface
for a hypothetical water level sensor (the &quot;WS00123&quot; water level sensor). This
interface will allow applications to query the current water level, as well as
get notified when the water level exceeds a certain threshold.</p>
<h2><a class="header" href="#setup-1" id="setup-1">Setup</a></h2>
<p>This guide assumes you already have existing kernel code that needs a
userspace interface. Likely that means there is already a capsule implemented.
Please see the other guides if you also need to implement the capsule.</p>
<p>We will assume there is a <code>struct WS00123 {...}</code> object already implemented
that includes all of the logic needed to interface with this particular water sensor.</p>
<h2><a class="header" href="#overview-2" id="overview-2">Overview</a></h2>
<p>The high-level steps required are:</p>
<ol>
<li>Decide on the interface to expose to userspace.</li>
<li>Map the interface to the existing syscalls in Tock.</li>
<li>Create grant space for the application.</li>
<li>Implement the <code>Driver</code> trait.</li>
<li>Document the interface.</li>
<li>Expose the interface to userspace.</li>
<li>Implement the syscall library in userspace.</li>
</ol>
<h2><a class="header" href="#step-by-step-guide-2" id="step-by-step-guide-2">Step-by-Step Guide</a></h2>
<p>The steps from the overview are elaborated on here.</p>
<ol>
<li>
<p><strong>Decide on the interface to expose to userspace.</strong></p>
<p>Creating the interface for userspace means making design decisions on how
applications should be able to interface with the kernel capsule. This can
have a lasting impact, and is worth spending some time on up-front to avoid
implementing an interface that is difficult to use or does not match the
needs of applications.</p>
<p>While there is not a fixed algorithm on how to create such an interface,
there are a couple tips that can help with creating the interface:</p>
<ul>
<li>Consider the interface for the same or similar functionality in other
systems (e.g. Linux, Contiki, TinyOS, RIOT, etc.). These may have iterated
on the design and include useful features.</li>
<li>Ignore the specific details of the capsule that exists or how the
particular sensor the syscall interface is for works, and instead consider
what a user of that capsule might want. That is, if you were writing an
application, how would you expect to use the interface? This might be
different from how the sensor or other hardware exposes features.</li>
<li>Consider other chips that provide similar functionality to the specific
one you have. For example, imagine there is a competing water level sensor
the &quot;OWlS789&quot;. What features do both provide? How would a single interface
be usable if a hardware board swapped one out for the other?</li>
</ul>
<p>The interface should include both actions (called &quot;commands&quot; in Tock) that
the application can take (for example, &quot;sample this sensor now&quot;), as well as
events (called subscribe callbacks in Tock) that the kernel can trigger
inside of an application (for example, when the sensed value is ready).</p>
<p>The interface can also include memory sharing between the application and
the kernel. For example, if the application wants to receive a number of
samples at once, or if the kernel needs to operate on many bytes (say for
example encrypting a buffer), then the interface should allow the
application to share some of its memory with the kernel to enable that
functionality.</p>
</li>
<li>
<p><strong>Map the interface to the existing syscalls in Tock.</strong></p>
<p>With a sketch of the interface created, the next step is to map that
interface to the specific syscalls that the Tock kernel supports. Tock has
three main relevant syscall operations that applications can use when
interfacing with the kernel:</p>
<ol>
<li>
<p><code>allow</code>: This lets an application share some of its memory with the
kernel.</p>
</li>
<li>
<p><code>subscribe</code>: This provides a callback function pointer that the kernel
can use to trigger a callback in the application.</p>
</li>
<li>
<p><code>command</code>: This enables the application to direct the kernel to do some
action.</p>
</li>
</ol>
<p>All three also include a couple other parameters to differentiate different
commands, subscriptions, or allows. Refer to the more detailed documentation
on the Tock syscalls for more information.</p>
<p>As the Tock kernel only supports these syscalls, each feature in the design
you created in the first step must be mapped to one or more of these
syscalls. To help, consider these hypothetical interfaces that
an application might have for our water sensor:</p>
<ul>
<li><em>What is the maximum water level?</em> This can be a simple command, where the
return value of the command is the maximum water level.</li>
<li><em>What is the current water level?</em> This will require two steps. First,
there needs to be a subscribe call where the application can setup a
callback function. The kernel will call this when the water level value
has been acquired. Second, there will need to be a command to instruct the
kernel to take the water level reading.</li>
<li><em>Take ten water level samples.</em> This will require three steps. First, the
application must use an allow syscall to share a buffer with the kernel
large enough to hold 10 water level readings. Then it must setup a
subscribe callback that the kernel will call when the 10 readings are
ready (note this callback function can be the same as in the single sample
case). Finally it will use a command to tell the kernel to start sampling.</li>
<li><em>Notify me when the water level exceeds a threshold.</em> A likely way to
implement this would be to first require a subscribe syscall for the
application to set the function that will get called when the high water
level event occurs. Then the application will need to use a command to
enable the high water level detection and to optionally set the threshold.</li>
</ul>
<p><strong>Checkpoint</strong>: You have defined how many allow, subscribe, and command
syscalls you need, and what each will do.</p>
</li>
<li>
<p><strong>Create grant space for the application.</strong></p>
<p>Grants are regions in a process's memory space that are shared with the
kernel. The kernel uses these to store state on behalf of the process. To
provide our syscall interface for the water level sensor, we need to setup a
grant so that we can store state for all of the requests we may get from
processes that want to use the sensor. In particular, we will need to be
able to store the callback that a process registers with us.</p>
<p>The first step to do this is to create a struct that contains fields for all
of the state we want to store for each process that uses our syscall interface. By convention in Tock, this struct is named <code>App</code>, but it could
have a different name. We will need to keep two values, the callback and the
high water alert threshold:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct App {
    callback: Option&lt;Callback&gt;,
    threshold: usize,
}
#}</code></pre></pre>
<p>Now that we have the type we want to store in the grant region we can create
the grant type for it by extending our <code>WS00123</code> struct:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct WS00123 {
	...
    apps: Grant&lt;App&gt;,
}
#}</code></pre></pre>
<p>We will also need the grant region to be created by the board and passed in
to us by adding it to the capsules <code>new()</code> function:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl WS00123 {
    pub fn new(
        ...
        grant: Grant&lt;App&gt;,
    ) -&gt; WS00123 {
        WS00123 {
            ...,
            apps: grant,
        }
    }
}
#}</code></pre></pre>
<p>Now we have somewhere to store values on a per-process basis.</p>
</li>
<li>
<p><strong>Implement the <code>Driver</code> trait.</strong></p>
<p>The <code>Driver</code> trait is how a capsule provides implementations for the various
syscalls an application might call. The basic framework looks like:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Driver for WS00123 {
	fn allow(
	    &amp;self,
	    appid: AppId,
	    allow_num: usize,
	    slice: Option&lt;AppSlice&lt;Shared, u8&gt;&gt;,
	) -&gt; ReturnCode { }

    fn subscribe(
        &amp;self,
        subscribe_num: usize,
        callback: Option&lt;Callback&gt;,
        _app_id: AppId,
    ) -&gt; ReturnCode { }

    fn command(&amp;self,
    	       command_num: usize,
    	       data: usize,
    	       data2: usize,
    	       app: AppId,
    ) -&gt; ReturnCode { }
}
#}</code></pre></pre>
<p>Note: there are default implementations for each of these, so in our water
level sensor case we can simply omit the <code>allow</code> call.</p>
<p>By Tock convention, every syscall interface must at least support the
command call with <code>command_num == 0</code>. This allows applications to check if
the syscall interface is supported on the current platform. If the command
returns <code>&lt;0</code> then the syscall interface is not present. Many implementations
return <code>SUCCESS</code> (i.e. 0), however, some return other positive numbers, like
for example the number of LEDs present on the board. For our example, we use
the simple case:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Driver for WS00123 {
	fn command(&amp;self,
    	       command_num: usize,
    	       data: usize,
    	       data2: usize,
    	       app: AppId,
    ) -&gt; ReturnCode {
		match command_num {
			0 =&gt; ReturnCode::SUCCESS,
			_ =&gt; ReturnCode::ENOSUPPORT,
		}
    }
}
#}</code></pre></pre>
<p>Now let's handle the subscribe call where the app can setup the callback we
should use. For this capsule, we will use a single callback for both when a
measurement is ready and for when a high water alert is triggered, but with
different arguments passed into the callback.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Driver for WS00123 {
    /// Setup callbacks.
    ///
    /// ### `subscribe_num`
    ///
    /// - `0`: Setup the main callback to be used when samples are ready
    ///        and when any alerts are triggered.
    fn subscribe(
        &amp;self,
        subscribe_num: usize,
        callback: Option&lt;Callback&gt;,
        app_id: AppId,
    ) -&gt; ReturnCode {
        self.apps
            .enter(app_id, |app, _| {
                match subscribe_num {
                    0 =&gt; app.callback = callback,
                    _ =&gt; return ReturnCode::ENOSUPPORT,
                }
                ReturnCode::SUCCESS
            })
            .unwrap_or_else(|err| err.into())
    }
}
#}</code></pre></pre>
<p>As you can see, we use the <code>enter()</code> function to &quot;enter&quot; the grant region of
the specific requesting app <code>app_id</code>. This performs checks like ensuring the
grant region exists and that the application is valid. If <code>enter()</code> succeeds
then we can update the <code>App</code> state like normal. Here we only need to save
the callback.</p>
<p>Next we can implement more commands so that the application can direct our
capsule as to what the application wants us to do. We need two commands, one
to sample and one to enable the alert. In both cases the commands must
return a <code>ReturnCode</code>, and call functions that likely already exist in the
original implementation of the <code>WS00123</code> sensor. If the functions don't
quite exist, then they will need to be added as well.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Driver for WS00123 {
	/// Command interface.
	///
	/// ### `command_num`
	///
	/// - `0`: Return SUCCESS if this driver is included on the platform.
	/// - `1`: Start a water level measurement.
	/// - `2`: Enable the water level detection alert. `data` is used as the
	///        height to set as the the threshold for detection.
	fn command(&amp;self,
    	       command_num: usize,
    	       data: usize,
    	       data2: usize,
    	       app: AppId,
    ) -&gt; ReturnCode {
		match command_num {
			0 =&gt; ReturnCode::SUCCESS,

			1 =&gt; self.start_measurement(app),

			2 =&gt; {
				// Save the threshold for this app.
				self.apps
				    .enter(app_id, |app, _| {
				        app.threshold = data;
				        ReturnCode::SUCCESS
				    })
				    .map_or_else(
				    	|err| err.into(),
				    	|ok| self.set_high_level_detection()
				    )
			}

			_ =&gt; ReturnCode::ENOSUPPORT,
		}
    }
}
#}</code></pre></pre>
<p>The last item that needs to be added is to actually use the callback when
the sensor has been sampled or the alert has been triggered. Actually
issuing the callback will need to be added to the existing implementation of
the capsule. As an example, if our water sensor was attached to the board
over I2C, then we might trigger the callback in response to a finished I2C
command:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl i2c::I2CClient for WS00123 {
    fn command_complete(&amp;self, buffer: &amp;'static mut [u8], _error: i2c::Error) {
    	...
    	let app_id = &lt;get saved appid for the app that issued the command&gt;;
    	let measurement = &lt;calculate water level based on returned I2C data&gt;;

    	self.apps.enter(app_id, |app, _| {
    	    app.callback.map(|mut cb| cb.schedule(0, measurement, 0));
    	});
    }
}
#}</code></pre></pre>
<p>There may be other cleanup code required to reset state or prepare the
sensor for another sample by a different application, but these are the
essential elements for implementing the syscall interface.</p>
<p>Finally, we need to assign our new <code>Driver</code> implementation a number so that
the kernel (and userspace apps) can differentiate this syscall interface
from all others that a board supports. By convention this is specified by
a global value at the top of the capsule file:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub const DRIVER_NUM: usize = 0x80000A;
#}</code></pre></pre>
<p>The value cannot conflict with other capsules in use, but can be set
arbitrarily, particularly for testing. Tock has a procedure for assigning
numbers, and you may need to change this number if the capsule is to merged
into the main Tock repository.</p>
<p><strong>Checkpoint</strong>: You have the syscall interface translated from a design to
code that can run inside the Tock kernel.</p>
</li>
<li>
<p><strong>Document the interface.</strong></p>
<p>A syscall interface is a contract between the kernel and any number of
userspace processes, and processes should be able to be developed
independently of the kernel. Therefore, it is helpful to document the new
syscall interface you made so applications know how to use the various
command, subscribe, and allow calls.</p>
<p>An example markdown file documenting our water level syscall interface is
as follows:</p>
<pre><code class="language-md">---
driver number: 0x80000A
---

# Water Level Sensor WS00123

## Overview

The WS00123 water level sensor can sample the depth of water as well as
trigger an event if the water level gets too high.

## Command

  * ### Command number: `0`

    **Description**: Does the driver exist?

    **Argument 1**: unused

    **Argument 2**: unused

    **Returns**: SUCCESS if it exists, otherwise ENODEVICE

  * ### Command number: `1`

    **Description**: Initiate a sensor reading.  When a reading is ready, a
    callback will be delivered if the process has `subscribed`.

    **Argument 1**: unused

    **Argument 2**: unused

    **Returns**: `EBUSY` if a reading is already pending, `ENOMEM` if there
    isn't sufficient grant memory available, or `SUCCESS` if the sensor
    reading was initiated successfully.

  * ### Command number: `2`

    **Description**: Enable the high water detection. THe callback will the
    alert will be delivered if the process has `subscribed`.

    **Argument 1**: The water depth to alert for.

    **Argument 2**: unused

    **Returns**: `EBUSY` if a reading is already pending, `ENOMEM` if there
    isn't sufficient grant memory available, or `SUCCESS` if the sensor
    reading was initiated successfully.

## Subscribe

  * ### Subscribe number: `0`

    **Description**: Subscribe a callback for sensor readings and alerts.

    **Callback signature**: The callback's first argument is `0` if this is
    a measurement, and `1` if the callback is an alert. If it is a
    measurement the second value will be the water level.

    **Returns**: SUCCESS if the subscribe was successful or ENOMEM if the
    driver failed to allocate memory to store the callback.
</code></pre>
<p>This file should be named <code>&lt;driver_num&gt;_&lt;sensor&gt;.md</code>, or in this case:
<code>80000A_ws00123.md</code>.</p>
</li>
<li>
<p><strong>Expose the interface to userspace.</strong></p>
<p>The last kernel implementation step is to let the main kernel know about
this new syscall interface so that if an application tries to use it the
kernel knows which implementation of <code>Driver</code> to call. In each board's
<code>main.rs</code> file (e.g. <code>boards/hail/src/main.rs</code>) there is a implementation of
the <code>Platform</code> trait where the board can setup which syscall interfaces it
supports. To enable our water sensor interface we add a new entry to the
match statement there:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Platform for Hail {
    fn with_driver&lt;F, R&gt;(&amp;self, driver_num: usize, f: F) -&gt; R
    where
        F: FnOnce(Option&lt;&amp;dyn kernel::Driver&gt;) -&gt; R,
    {
        match driver_num {
        	...
            capsules::ws00123::DRIVER_NUM =&gt; f(Some(self.ws00123)),
            ...
            _ =&gt; f(None),
        }
    }
}
#}</code></pre></pre>
</li>
<li>
<p><strong>Implement the syscall library in userspace.</strong></p>
<p>At this point userspace applications can use our new syscall interface and
interact with the water sensor. However, applications would have to call all
of the syscalls directly, and that is fairly difficult to get right and not
user friendly. Therefore, we typically implement a small library layer in
userspace to make using the interface easier.</p>
<p>In this guide we will be setting up a C library, and to do so we will create
<code>libtock-c/libtock/ws00123.h</code> and <code>libtock-c/libtock/ws00123.c</code>, both of
which will be added to the libtock-c repository. The .h file defines the
public interface and constants:</p>
<pre><code class="language-c">#pragma once

#include &quot;tock.h&quot;

#ifdef __cplusplus
extern &quot;C&quot; {
#endif

#define DRIVER_NUM_WS00123 0x80000A

int ws00123_set_callback(subscribe_cb callback, void* callback_args);
int ws00123_read_water_level();
int ws00123_enable_alerts(uint32_t threshold);

#ifdef __cplusplus
}
#endif
</code></pre>
<p>While the .c file provides the implementations:</p>
<pre><code class="language-c">#include &quot;ws00123.h&quot;
#include &quot;tock.h&quot;

int ws00123_set_callback(subscribe_cb callback, void* callback_args) {
  return subscribe(DRIVER_NUM_WS00123, 0, callback, callback_args);
}

int ws00123_read_water_level() {
  return command(DRIVER_NUM_WS00123, 1, 0, 0);
}

int ws00123_enable_alerts(uint32_t threshold) {
  return command(DRIVER_NUM_WS00123, 2, threshold, 0);
}
</code></pre>
<p>This is a very basic implementation of the interface, but it provides some
more readable names to the numbers that make up the syscall interface. See
other examples in libtock for how to make synchronous versions of
asynchronous operations (like reading the sensor).</p>
</li>
</ol>
<h2><a class="header" href="#wrap-up-2" id="wrap-up-2">Wrap-Up</a></h2>
<p>Congratulations! You have added a new API for userspace applications using the
Tock syscall interface! We encourage you to submit a pull request to upstream
this to the Tock repository.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
